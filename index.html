<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>GOBO –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä-–†–µ–¥–∞–∫—Ç–æ—Ä 2.1</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#5a67d8">
    <style>
        html, body { margin: 0; padding: 0; font-family: sans-serif; background: #f0f2f6; color: #333; }
        h1, h2, h3 { text-align: center; margin: 10px 0; color: #2d3748; }
        #app { max-width: 960px; margin: 20px auto; padding: 16px; background: #fff; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
      .step { display: none; padding: 24px; border-radius: 12px; }
      .step.active { display: block; }
      .progress { display: flex; justify-content: space-between; margin: 16px 0 24px; padding-bottom: 10px; border-bottom: 1px solid #e2e8f0; }
      .progress div { flex: 1; text-align: center; font-weight: 700; color: #a0aec0; position: relative; padding: 5px; cursor: default; }
      .progress div::before { content: attr(data-n); display: block; width: 32px; height: 32px; margin: 0 auto 8px; border-radius: 50%; line-height: 32px; border: 2px solid currentColor; background: #fff; }
      .progress div.active { color: #5a67d8; }
      .progress div.done::before { background: #5a67d8; color: #fff; border-color: #5a67d8; }
        
        #photoZone { border: 3px dashed #cbd5e0; padding: 40px; text-align: center; border-radius: 10px; cursor: pointer; background: #f7fafc; margin-bottom: 16px; }
        #photoZone.dragover { background: #edf2f7; border-color: #5a67d8; }
        
      .image-container { position: relative; display: inline-block; border: 1px solid #e2e8f0; border-radius: 10px; overflow: hidden; max-width: 100%; margin: 0 auto; display: block; }
        #bgImg, #bgImgDeform { display: block; max-width: 100%; max-height: 60vh; border-radius: 9px; margin: 0 auto;}
        #deformation-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #svgOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
      .point-marker { position: absolute; width: 14px; height: 14px; background: #e53e3e; border: 2px solid #fff; border-radius: 50%; transform: translate(-50%, -50%); font-size: 9px; line-height: 10px; text-align: center; color: #fff; font-weight: 700; user-select: none; cursor: grab; box-shadow: 0 0 5px rgba(0,0,0,0.3); }
      .point-marker:active { cursor: grabbing; }

      .controls,.export-controls { display: flex; flex-wrap: wrap; gap: 12px; margin-top: 16px; padding: 10px; background: #f9f9f9; border-radius: 8px; }
      .controls label,.export-controls label { font-size: 14px; display: flex; flex-direction: column; gap: 4px; }
      .controls input[type="range"] { width: 150px; }
      .controls input[type="number"] { width: 60px; padding: 4px; border-radius: 4px; border: 1px solid #ccc; }
        
        button, input[type="file"] { padding: 10px 15px; background-color: #5a67d8; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; transition: background-color 0.2s; }
        button:hover, input[type="file"]:hover { background-color: #434190; }
        button:disabled { background-color: #a0aec0; cursor: not-allowed; }
        input[type="file"] { display: block; margin-bottom:10px;}
        #goboPreview { min-height: 100px; border: 2px dashed #cbd5e0; margin: 12px 0; display: flex; align-items: center; justify-content: center; border-radius: 10px; background: #f7fafc; }
        #goboPreview img { max-height: 180px; max-width: 100%; }
      .hidden { display: none; }
        #notification { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background-color: #333; color: white; padding: 10px 20px; border-radius: 5px; z-index: 1000; display: none; }
      .introjs-tooltip { font-family: sans-serif; } /* Basic styling for intro.js */
    </style>
    <script src="https://cdn.jsdelivr.net/npm/delaunator@5.0.1/delaunator.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/transformation-matrix-js@2.7.6/matrix.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-to-tiff@1.0.0/canvasToTIFF.min.js"></script>
</head>
<body>
    <div id="app">
        <h1>GOBO –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä-–†–µ–¥–∞–∫—Ç–æ—Ä 2.1</h1>
        <div class="progress">
            <div id="pStep1" data-n="1" class="active">1. –§–æ—Ç–æ</div>
            <div id="pStep2" data-n="2">2. –ö–æ–Ω—Ç—É—Ä</div>
            <div id="pStep3" data-n="3">3. –ì–æ–±–æ</div>
            <div id="pStep4" data-n="4">4. –î–µ—Ñ–æ—Ä–º–∞—Ü–∏—è</div>
            <div id="pStep5" data-n="5">5. –≠–∫—Å–ø–æ—Ä—Ç</div>
        </div>

        <section id="step1" class="step active">
            <h2>–®–∞–≥ 1: –ó–∞–≥—Ä—É–∑–∫–∞ —ç—Ç–∞–ª–æ–Ω–Ω–æ–≥–æ —Ñ–æ—Ç–æ</h2>
            <p>–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—é –æ–±—ä–µ–∫—Ç–∞ (—Å —Ä–∞–∑–º–µ—á–µ–Ω–Ω—ã–º –∏–ª–∏ –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º—ã–º –∫–æ–Ω—Ç—É—Ä–æ–º) –≤ –æ–±–ª–∞—Å—Ç—å –Ω–∏–∂–µ –∏–ª–∏ –≤—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª.</p>
            <div id="photoZone">üì∑ –ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ —Ñ–æ—Ç–æ —Å—é–¥–∞ –∏–ª–∏ –∫–ª–∏–∫–Ω–∏—Ç–µ –¥–ª—è –≤—ã–±–æ—Ä–∞</div>
            <input id="photoInput" type="file" accept="image/*" class="hidden">
            <button id="setupAppFiles" style="margin-top: 15px; background-color: #f0ad4e;">–°–∫–∞—á–∞—Ç—å manifest.json –∏ sw.js (–¥–ª—è GitHub Pages)</button>
        </section>

        <section id="step2" class="step">
            <h2>–®–∞–≥ 2: –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–æ—á–µ–∫ –∫–æ–Ω—Ç—É—Ä–∞</h2>
            <p>–ö–ª–∏–∫–Ω–∏—Ç–µ –ø–æ —É–≥–ª–∞–º –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º–æ–≥–æ –∫–æ–Ω—Ç—É—Ä–∞ –Ω–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ (–º–∏–Ω–∏–º—É–º 3, –º–∞–∫—Å–∏–º—É–º 12 —Ç–æ—á–µ–∫). –¢–æ—á–∫–∏ –º–æ–∂–Ω–æ –±—É–¥–µ—Ç –¥–≤–∏–≥–∞—Ç—å –Ω–∞ —Å–ª–µ–¥—É—é—â–µ–º —à–∞–≥–µ.</p>
            <div class="image-container" id="contourImageContainer">
                <img id="bgImg" alt="–≠—Ç–∞–ª–æ–Ω–Ω–æ–µ —Ñ–æ—Ç–æ">
                <svg id="svgOverlay" xmlns="http://www.w3.org/2000/svg"></svg>
                </div>
            <div class="controls">
                <span>–¢–æ—á–µ–∫: <b id="pointCount">0</b>/12</span>
                <button id="undoLastPoint">‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∏—Ç—å —Ç–æ—á–∫—É</button>
                <button id="clearPoints">üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å –≤—Å–µ —Ç–æ—á–∫–∏</button>
                <button id="goToStep3" disabled>–î–∞–ª–µ–µ &rarr;</button>
            </div>
        </section>

        <section id="step3" class="step">
            <h2>–®–∞–≥ 3: –ó–∞–≥—Ä—É–∑–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≥–æ–±–æ</h2>
            <p>–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ª–æ–≥–æ—Ç–∏–ø), –∫–æ—Ç–æ—Ä–æ–µ –±—É–¥–µ—Ç –ø—Ä–æ–µ—Ü–∏—Ä–æ–≤–∞—Ç—å—Å—è. –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è PNG —Å –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–º —Ñ–æ–Ω–æ–º.</p>
            <input id="goboInput" type="file" accept="image/*">
            <div id="goboPreview"><span>–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –≥–æ–±–æ</span></div>
            <button id="goToStep4" disabled>–î–∞–ª–µ–µ &rarr;</button>
        </section>

        <section id="step4" class="step">
            <h2>–®–∞–≥ 4: –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏—è –≥–æ–±–æ</h2>
            <p>–ü–µ—Ä–µ–º–µ—â–∞–π—Ç–µ –∫—Ä–∞—Å–Ω—ã–µ –º–∞—Ä–∫–µ—Ä—ã –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ —Å–æ–≤–º–µ—â–µ–Ω–∏—è –≥–æ–±–æ —Å –∫–æ–Ω—Ç—É—Ä–æ–º. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø–æ–ª–∑—É–Ω–∫–∏ –¥–ª—è –æ–±—â–µ–π –∫–æ—Ä—Ä–µ–∫—Ü–∏–∏.</p>
            <div class="image-container" id="deformationContainer">
                <img id="bgImgDeform" alt="–≠—Ç–∞–ª–æ–Ω–Ω–æ–µ —Ñ–æ—Ç–æ –¥–ª—è –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏–∏">
                <canvas id="deformation-canvas"></canvas>
                </div>
            <div class="controls">
                <label>–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å: <input type="range" id="opacitySlider" min="0" max="100" value="100"> <span id="opacityValue">100%</span></label>
                <label>–ú–∞—Å—à—Ç–∞–±: <input type="range" id="scaleSlider" min="10" max="300" value="100"> <span id="scaleValue">100%</span></label>
                <label>–ü–æ–≤–æ—Ä–æ—Ç: <input type="range" id="rotationSlider" min="-180" max="180" value="0"> <span id="rotationValue">0¬∞</span></label>
            </div>
             <div class="controls">
                <button id="toggleGoboVisibility">üëÅÔ∏è –°–∫—Ä—ã—Ç—å/–ü–æ–∫–∞–∑–∞—Ç—å –ì–æ–±–æ</button>
                <button id="undoTransform">‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏–µ</button>
                <button id="resetTransform">üîÑ –°–±—Ä–æ—Å–∏—Ç—å —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏</button>
                <button id="saveProject">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø—Ä–æ–µ–∫—Ç</button>
                <button id="loadProjectInputLabel" onclick="document.getElementById('loadProjectInput').click();">üìÇ –û—Ç–∫—Ä—ã—Ç—å –ø—Ä–æ–µ–∫—Ç</button>
                <input type="file" id="loadProjectInput" class="hidden" accept=".json">
                <button id="runTour">‚ùì –ü–æ–º–æ—â—å</button>
                <button id="goToStep5">–î–∞–ª–µ–µ &rarr;</button>
            </div>
        </section>

        <section id="step5" class="step">
            <h2>–®–∞–≥ 5: –ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –∏ —ç–∫—Å–ø–æ—Ä—Ç</h2>
            <p>–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –ø–µ—á–∞—Ç–∏ –∏ —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–π—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç.</p>
            <div class="export-controls">
                <label>–ü—Ä–µ—Å–µ—Ç –ø–µ—á–∞—Ç–∏:
                    <select id="printPreset">
                        <option value="custom">–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π</option>
                        <option value="32,2700,3401">–°—Ç–µ–∫–ª–æ: 32–º–º @ 2700 DPI (3401px)</option>
                        <option value="37.5,600,886">–°–ª–∞–π–¥ 35–º–º: D=37.5–º–º @ 600 DPI (886px)</option>
                        <option value="37.5,1200,1772">–°–ª–∞–π–¥ 35–º–º: D=37.5–º–º @ 1200 DPI (1772px)</option>
                        <option value="50,600,1181">–°–ª–∞–π–¥ 50–º–º: D=50–º–º @ 600 DPI (1181px)</option>
                    </select>
                </label>
                <label>–î–∏–∞–º–µ—Ç—Ä –ø–µ—á–∞—Ç–∏ (–º–º): <input type="number" id="printDiameter" value="32" step="0.1"></label>
                <label>–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ (DPI): <input type="number" id="printDPI" value="2700" step="50"></label>
                <label>–†–∞–∑–º–µ—Ä –≤ –ø–∏–∫—Å–µ–ª—è—Ö: <input type="text" id="pixelSize" readonly></label>
            </div>
            <div class="controls">
                <button id="exportPNG">–≠–∫—Å–ø–æ—Ä—Ç –≤ PNG</button>
                <button id="exportTIFF">–≠–∫—Å–ø–æ—Ä—Ç –≤ TIFF (RGBA)</button>
            </div>
            <h3>–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä —ç–∫—Å–ø–æ—Ä—Ç–∞:</h3>
            <canvas id="exportPreviewCanvas" style="border:1px solid #ccc; margin-top:10px; max-width: 100%;"></canvas>
        </section>
    </div>

    <div id="notification"></div>

    <script type="text/plain" id="manifest-data">
    {
      "name": "GOBO –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä-–†–µ–¥–∞–∫—Ç–æ—Ä",
      "short_name": "GOBO–†–µ–¥–∞–∫—Ç–æ—Ä",
      "description": "–í–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ –∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –ø—Ä–æ–µ–∫—Ü–∏–π –≥–æ–±–æ.",
      "start_url": "./index.html?source=pwa",
      "display": "standalone",
      "background_color": "#ffffff",
      "theme_color": "#5a67d8",
      "icons": [
        { "src": "icon-192.png", "sizes": "192x192", "type": "image/png", "purpose": "any maskable" },
        { "src": "icon-512.png", "sizes": "512x512", "type": "image/png", "purpose": "any maskable" }
      ]
    }
    </script>

    <script type="text/plain" id="sw-data">
    const CACHE_NAME = 'gobo-calculator-cache-v2.1'; // –û–±–Ω–æ–≤–∏—Ç–µ –≤–µ—Ä—Å–∏—é –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ä–µ—Å—É—Ä—Å–æ–≤
    const assetsToCache = ['./', 'index.html', 'icon-192.png', 'icon-512.png'];

    self.addEventListener('install', event => {
        event.waitUntil(
            caches.open(CACHE_NAME)
              .then(cache => {
                    console.log('–ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏—Ö —Ä–µ—Å—É—Ä—Å–æ–≤');
                    return cache.addAll(assetsToCache.map(url => new Request(url, {cache: 'reload'}))); // Force reload from network for caching
                })
              .catch(err => console.error('–û—à–∏–±–∫–∞ –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è –ø—Ä–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–µ:', err))
        );
        self.skipWaiting();
    });

    self.addEventListener('activate', event => {
        event.waitUntil(
            caches.keys().then(cacheNames => {
                return Promise.all(
                    cacheNames.map(cacheName => {
                        if (cacheName!== CACHE_NAME) {
                            console.log('–£–¥–∞–ª–µ–Ω–∏–µ —Å—Ç–∞—Ä–æ–≥–æ –∫–µ—à–∞:', cacheName);
                            return caches.delete(cacheName);
                        }
                    })
                );
            })
        );
        return self.clients.claim();
    });

    self.addEventListener('fetch', event => {
        event.respondWith(
            caches.match(event.request)
              .then(response => {
                    if (response) {
                        return response; // –í–æ–∑–≤—Ä–∞—Ç –∏–∑ –∫–µ—à–∞
                    }
                    // –ï—Å–ª–∏ –Ω–µ—Ç –≤ –∫–µ—à–µ, –ø—ã—Ç–∞–µ–º—Å—è –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑ —Å–µ—Ç–∏
                    return fetch(event.request).then(
                        networkResponse => {
                            // –ï—Å–ª–∏ —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω–æ, –∫–µ—à–∏—Ä—É–µ–º –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º
                            if(!networkResponse |
| networkResponse.status!== 200 |
| (networkResponse.type!== 'basic' && networkResponse.type!== 'cors')) {
                                return networkResponse;
                            }
                            const responseToCache = networkResponse.clone();
                            caches.open(CACHE_NAME)
                              .then(cache => {
                                    cache.put(event.request, responseToCache);
                                });
                            return networkResponse;
                        }
                    ).catch(() => {
                        // –û—à–∏–±–∫–∞ —Å–µ—Ç–∏, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∑–∞–≥–ª—É—à–∫—É, –µ—Å–ª–∏ –µ—Å—Ç—å
                        // –î–ª—è PWA –≤–∞–∂–Ω–æ –∏–º–µ—Ç—å fallback.html, –Ω–æ –¥–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã –∑–¥–µ—Å—å –æ–Ω –æ–ø—É—â–µ–Ω.
                        // if (event.request.mode === 'navigate') {
                        //     return caches.match('./fallback.html');
                        // }
                    });
                })
        );
    });
    </script>
    
    <script>
        function startTour(stepsConfig) {
            const steps = stepsConfig ||;
            let currentStepIndex = 0;
            let overlay = document.createElement('div');
            let tooltip = document.createElement('div');
            let highlightBox = document.createElement('div');

            function setupOverlay() {
                overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,.7);z-index:9998;';
                highlightBox.style.cssText = 'position:absolute;border:3px solid #5a67d8;border-radius:5px;box-shadow:0 0 0 9999px rgba(0,0,0,.7);pointer-events:none;transition:all 0.3s ease-out;';
                tooltip.style.cssText = 'position:absolute;background:#fff;color:#333;padding:15px;border-radius:5px;max-width:300px;z-index:9999;box-shadow:0 2px 10px rgba(0,0,0,.2);';
                overlay.appendChild(highlightBox); 
                document.body.appendChild(overlay);
                document.body.appendChild(tooltip);
                overlay.onclick = endTour; 
            }

            function showStep() {
                if (currentStepIndex >= steps.length) {
                    endTour();
                    return;
                }
                const step = steps;
                const targetElement = document.querySelector(step.el);
                if (!targetElement) { console.warn('Intro.js: Element not found for step', step); currentStepIndex++; showStep(); return; }

                const rect = targetElement.getBoundingClientRect();
                highlightBox.style.left = `${rect.left - 4}px`;
                highlightBox.style.top = `${rect.top - 4}px`;
                highlightBox.style.width = `${rect.width + 8}px`;
                highlightBox.style.height = `${rect.height + 8}px`;
                
                targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });

                tooltip.innerHTML = `<p>${step.msg}</p><button id="introNextBtn">–î–∞–ª–µ–µ</button> <button id="introSkipBtn" style="float:right;background:transparent;color:#777;border:none;padding:5px;">–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å</button>`;
                
                let tooltipTop = rect.bottom + 15;
                let tooltipLeft = rect.left;
                if (tooltipTop + tooltip.offsetHeight > window.innerHeight) {
                    tooltipTop = rect.top - tooltip.offsetHeight - 15;
                }
                if (tooltipLeft + tooltip.offsetWidth > window.innerWidth) {
                    tooltipLeft = window.innerWidth - tooltip.offsetWidth - 15;
                }
                tooltip.style.top = `${tooltipTop}px`;
                tooltip.style.left = `${tooltipLeft < 0? 15 : tooltipLeft}px`;


                tooltip.querySelector('#introNextBtn').onclick = () => { currentStepIndex++; showStep(); };
                tooltip.querySelector('#introSkipBtn').onclick = endTour;
            }

            function endTour() {
                if(overlay.parentNode) overlay.remove();
                if(tooltip.parentNode) tooltip.remove();
            }
            
            setupOverlay();
            showStep();
        }
    </script>

    <script type="text/javascript">
    // ========== –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ==========
    const $ = q => document.querySelector(q);
    const $$ = q => document.querySelectorAll(q);

    let currentStep = 1;
    let assignedPoints =; 
    let initialGoboContourPoints =; 
    let deformationDestPoints =; 
    
    let bgPhoto = { 
        img: null, 
        dataURL: null, 
        originalWidth: 0,
        originalHeight: 0,
        displayWidth: 0, 
        displayHeight: 0
    };
    let goboImage = { 
        img: null, 
        dataURL: null, 
        originalWidth: 0,
        originalHeight: 0
    };

    let transformState = { 
        x: 0, y: 0, 
        scale: 1,       
        rotation: 0,    
        opacity: 1,
        centerX: 0, 
        centerY: 0,
        baseScale: 1 
    };

    let historyStack =; 

    let contourImageContainer, bgImgElement, svgOverlayElement; 
    let deformationContainer, bgImgDeformElement, deformationCanvas, dCtx; 
    let exportPreviewCanvas, epCtx; 

    const MAX_CONTOUR_POINTS = 12;
    const MAX_PHOTO_DIMENSION = 2000; 

    // ========== –£—Ç–∏–ª–∏—Ç—ã ==========
    function showNotification(message, duration = 3000) {
        const notification = $('#notification');
        notification.textContent = message;
        notification.style.display = 'block';
        setTimeout(() => { notification.style.display = 'none'; }, duration);
    }

    function calculateBoundingBox(pointsArray) {
        if (!pointsArray |
| pointsArray.length === 0) return { minX: 0, minY: 0, maxX: 0, maxY: 0, width: 0, height: 0, cx: 0, cy: 0 };
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        pointsArray.forEach(p => {
            minX = Math.min(minX, p.x);
            minY = Math.min(minY, p.y);
            maxX = Math.max(maxX, p.x);
            maxY = Math.max(maxY, p.y);
        });
        const width = maxX - minX;
        const height = maxY - minY;
        return { minX, minY, maxX, maxY, width, height, cx: minX + width / 2, cy: minY + height / 2 };
    }
    
    // ========== –ù–∞–≤–∏–≥–∞—Ü–∏—è –ø–æ —à–∞–≥–∞–º ==========
    function goToStep(nextStep) {
        if (nextStep === currentStep) return;
        $(`#step${currentStep}`).classList.remove('active');
        $(`#pStep${currentStep}`).classList.remove('active');
        if (nextStep > currentStep) {
            $(`#pStep${currentStep}`).classList.add('done');
        }
        currentStep = nextStep;
        $(`#step${currentStep}`).classList.add('active');
        $(`#pStep${currentStep}`).classList.add('active');

        if (currentStep === 2) setupStep2UI();
        if (currentStep === 4) setupStep4UI();
        if (currentStep === 5) setupStep5UI();
    }

    // ========== –®–∞–≥ 1: –ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–æ–Ω–æ–≤–æ–≥–æ —Ñ–æ—Ç–æ ==========
    function initStep1() {
        const photoZone = $('#photoZone');
        const photoInput = $('#photoInput');
        photoZone.onclick = () => photoInput.click();
        ['dragover', 'dragleave', 'drop'].forEach(eventName => {
            photoZone.addEventListener(eventName, e => {
                e.preventDefault();
                e.stopPropagation();
                if (eventName === 'dragover') photoZone.classList.add('dragover');
                else photoZone.classList.remove('dragover');
                if (eventName === 'drop') handlePhotoUpload(e.dataTransfer.files);
            });
        });
        photoInput.onchange = e => handlePhotoUpload(e.target.files);
        
        $('#setupAppFiles').onclick = () => {
            const manifestContent = $('#manifest-data').textContent;
            const swContent = $('#sw-data').textContent;
            downloadFile(manifestContent, 'manifest.json', 'application/json');
            downloadFile(swContent, 'sw.js', 'application/javascript');
            showNotification('–°–∫–∞—á–∞–π—Ç–µ —Ñ–∞–π–ª—ã manifest.json –∏ sw.js –∏ –ø–æ–º–µ—Å—Ç–∏—Ç–µ –∏—Ö –≤ –∫–æ—Ä–µ–Ω—å –≤–∞—à–µ–≥–æ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è GitHub Pages. –¢–∞–∫–∂–µ –¥–æ–±–∞–≤—å—Ç–µ –∏–∫–æ–Ω–∫–∏ icon-192.png –∏ icon-512.png.', 10000);
        };
    }

    function handlePhotoUpload(files) {
        if (!files |
| files.length === 0) {
            showNotification('–û—à–∏–±–∫–∞: –§–∞–π–ª –Ω–µ –≤—ã–±—Ä–∞–Ω.');
            return;
        }
        const file = files;

        if (!file.type.startsWith('image/')) {
            showNotification('–û—à–∏–±–∫–∞: –í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è.');
            return;
        }
        const reader = new FileReader();
        reader.onload = e => {
            const img = new Image();
            img.onload = () => {
                bgPhoto.originalWidth = img.width;
                bgPhoto.originalHeight = img.height;

                let scaleFactor = 1;
                if (img.width > MAX_PHOTO_DIMENSION |
| img.height > MAX_PHOTO_DIMENSION) {
                    scaleFactor = Math.min(MAX_PHOTO_DIMENSION / img.width, MAX_PHOTO_DIMENSION / img.height);
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = Math.round(img.width * scaleFactor);
                    tempCanvas.height = Math.round(img.height * scaleFactor);
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);
                    bgPhoto.dataURL = tempCanvas.toDataURL('image/jpeg', 0.9);
                    showNotification(`–§–æ—Ç–æ –±—ã–ª–æ —É–º–µ–Ω—å—à–µ–Ω–æ –¥–æ ${tempCanvas.width}x${tempCanvas.height}px –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏. –û—Ä–∏–≥–∏–Ω–∞–ª –¥–ª—è –ø–µ—á–∞—Ç–∏ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –Ω–∞ —ç—Ç–æ–º —ç—Ç–∞–ø–µ.`, 5000);
                } else {
                    bgPhoto.dataURL = e.target.result;
                }
                bgPhoto.img = new Image();
                bgPhoto.img.onload = () => { 
                    goToStep(2);
                }
                bgPhoto.img.src = bgPhoto.dataURL;
            };
            img.src = e.target.result; 
        };
        reader.readAsDataURL(file);
    }

    // ========== –®–∞–≥ 2: –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–æ—á–µ–∫ –∫–æ–Ω—Ç—É—Ä–∞ ==========
    function setupStep2UI() {
        contourImageContainer = $('#contourImageContainer');
        bgImgElement = $('#bgImg');
        svgOverlayElement = $('#svgOverlay');

        bgImgElement.src = bgPhoto.dataURL;
        
        assignedPoints.forEach(p => p.element?.remove());
        assignedPoints =;
        updatePointCountAndProceedButton();
        drawContourPolygon();

        const tempImg = new Image(); 
        tempImg.onload = () => {
            bgPhoto.displayWidth = bgImgElement.offsetWidth;
            bgPhoto.displayHeight = bgImgElement.offsetHeight;
            
            contourImageContainer.style.width = `${bgPhoto.displayWidth}px`;
            contourImageContainer.style.height = `${bgPhoto.displayHeight}px`;
            svgOverlayElement.setAttribute('viewBox', `0 0 ${bgPhoto.displayWidth} ${bgPhoto.displayHeight}`);
        };
        tempImg.src = bgPhoto.dataURL;
    }

    function initStep2() {
        // contourImageContainer –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —É–∂–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω –≤ setupStep2UI, –Ω–æ –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π:
        if (!contourImageContainer) contourImageContainer = $('#contourImageContainer');
        
        contourImageContainer.addEventListener('click', e => {
            if (e.target.classList.contains('point-marker')) return; 
            if (assignedPoints.length >= MAX_CONTOUR_POINTS) {
                showNotification(`–î–æ—Å—Ç–∏–≥–Ω—É—Ç–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫ (${MAX_CONTOUR_POINTS}).`);
                return;
            }
            const rect = contourImageContainer.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            addContourPoint(x, y);
            saveStateForUndo(); 
        });

        $('#clearPoints').onclick = () => {
            assignedPoints.forEach(p => p.element.remove());
            assignedPoints =;
            updatePointCountAndProceedButton();
            drawContourPolygon();
            saveStateForUndo();
        };
        $('#undoLastPoint').onclick = () => {
            if (assignedPoints.length > 0) {
                const removedPoint = assignedPoints.pop();
                removedPoint.element.remove();
                updatePointCountAndProceedButton();
                drawContourPolygon();
            }
        };
        $('#goToStep3').onclick = () => {
            if (assignedPoints.length < 3) {
                showNotification('–ù—É–∂–Ω–æ –º–∏–Ω–∏–º—É–º 3 —Ç–æ—á–∫–∏ –¥–ª—è –∫–æ–Ω—Ç—É—Ä–∞.');
                return;
            }
            goToStep(3);
        };
    }

    function addContourPoint(x, y, existingElement = null) {
        const pointElement = existingElement |
| document.createElement('div');
        pointElement.className = 'point-marker';
        pointElement.textContent = assignedPoints.length + 1;
        pointElement.style.left = `${x}px`;
        pointElement.style.top = `${y}px`;
        
        if (!existingElement) { 
             contourImageContainer.appendChild(pointElement);
        }

        const point = { x, y, element: pointElement, id: Date.now() + Math.random() };
        assignedPoints.push(point);
        
        updatePointCountAndProceedButton();
        drawContourPolygon();
    }
    
    function updatePointCountAndProceedButton() {
        $('#pointCount').textContent = assignedPoints.length;
        $('#goToStep3').disabled = assignedPoints.length < 3;
    }

    function drawContourPolygon() {
        if (!svgOverlayElement) svgOverlayElement = $('#svgOverlay');
        svgOverlayElement.innerHTML = ''; 
        if (assignedPoints.length < 2) return;

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        let d = `M ${assignedPoints.x} ${assignedPoints.y} `;
        for (let i = 1; i < assignedPoints.length; i++) {
            d += `L ${assignedPoints[i].x} ${assignedPoints[i].y} `;
        }
        if (assignedPoints.length > 2) {
            d += 'Z'; 
        }
        path.setAttribute('d', d);
        path.setAttribute('fill', 'rgba(255, 105, 180, 0.3)');
        path.setAttribute('stroke', '#ff69b4');
        path.setAttribute('stroke-width', '2');
        svgOverlayElement.appendChild(path);
    }

    // ========== –®–∞–≥ 3: –ó–∞–≥—Ä—É–∑–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≥–æ–±–æ ==========
    function initStep3() {
        $('#goboInput').onchange = e => handleGoboUpload(e.target.files);
        $('#goToStep4').onclick = () => {
            if (!goboImage.img) {
                showNotification('–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –≥–æ–±–æ.');
                return;
            }
            goToStep(4);
        };
    }

    function handleGoboUpload(files) {
        if (!files |
| files.length === 0) {
            showNotification('–û—à–∏–±–∫–∞: –§–∞–π–ª –¥–ª—è –≥–æ–±–æ –Ω–µ –≤—ã–±—Ä–∞–Ω.');
            return;
        }
        const file = files;

        if (!file.type.startsWith('image/')) {
            showNotification('–û—à–∏–±–∫–∞: –í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –≥–æ–±–æ.');
            return;
        }
        const reader = new FileReader();
        reader.onload = e => {
            goboImage.dataURL = e.target.result;
            goboImage.img = new Image();
            goboImage.img.onload = () => {
                goboImage.originalWidth = goboImage.img.width;
                goboImage.originalHeight = goboImage.img.height;
                $('#goboPreview').innerHTML = `<img src="${goboImage.dataURL}" alt="–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –≥–æ–±–æ">`;
                $('#goToStep4').disabled = false;
            };
            goboImage.img.src = goboImage.dataURL;
        };
        reader.readAsDataURL(file);
    }

    // ========== –®–∞–≥ 4: –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏—è ==========
    let isGoboVisible = true;
    let activeDeformPointIndex = -1;

    function setupStep4UI() {
        deformationContainer = $('#deformationContainer');
        bgImgDeformElement = $('#bgImgDeform');
        deformationCanvas = $('#deformation-canvas');
        dCtx = deformationCanvas.getContext('2d');

        bgImgDeformElement.src = bgPhoto.dataURL;
        
        const tempImg = new Image();
        tempImg.onload = () => {
            deformationCanvas.width = bgImgDeformElement.offsetWidth;
            deformationCanvas.height = bgImgDeformElement.offsetHeight;
            
            const scaleX = deformationCanvas.width / bgPhoto.displayWidth;
            const scaleY = deformationCanvas.height / bgPhoto.displayHeight;

            deformationDestPoints = assignedPoints.map((p, index) => ({
                x: p.x * scaleX,
                y: p.y * scaleY,
                originalIndex: index 
            }));
            
            const gw = goboImage.originalWidth;
            const gh = goboImage.originalHeight;
            
            if (assignedPoints.length === 4) {
                 initialGoboContourPoints = [
                    { x: 0, y: 0 }, { x: gw, y: 0 }, { x: gw, y: gh }, { x: 0, y: gh }
                ];
            } else { 
                initialGoboContourPoints = deformationDestPoints.map((_, i) => {
                    if (i === 0) return { x: 0, y: 0 };
                    if (i === 1) return { x: gw, y: 0 };
                    if (i === 2) return { x: gw, y: gh };
                    if (i === 3) return { x: 0, y: gh };
                    return { x: (i%2 === 0)? 0 : gw, y: (Math.floor(i/2)%2 === 0)? 0 : gh };
                });
            }
            if (initialGoboContourPoints.length > deformationDestPoints.length) {
                initialGoboContourPoints = initialGoboContourPoints.slice(0, deformationDestPoints.length);
            } else if (deformationDestPoints.length > initialGoboContourPoints.length) {
                 const diff = deformationDestPoints.length - initialGoboContourPoints.length;
                 for(let i=0; i<diff; i++) {
                     initialGoboContourPoints.push(initialGoboContourPoints[initialGoboContourPoints.length-1] |
| {x:0,y:0});
                 }
            }

            initializeTransformState();
            createDeformMarkers();
            drawDeformedGobo();
            saveStateForUndo();
        };
        tempImg.src = bgPhoto.dataURL;
    }

    function initializeTransformState() {
        const bbox = calculateBoundingBox(deformationDestPoints);
        transformState.centerX = bbox.cx;
        transformState.centerY = bbox.cy;
        
        const goboAspectRatio = goboImage.originalWidth / goboImage.originalHeight;
        const contourAspectRatio = bbox.width / bbox.height;
        if (goboAspectRatio > contourAspectRatio) { 
            transformState.baseScale = bbox.width / goboImage.originalWidth;
        } else { 
            transformState.baseScale = bbox.height / goboImage.originalHeight;
        }
        transformState.baseScale *= 1.1; 

        transformState.scale = 1.0; 
        transformState.rotation = 0;
        transformState.opacity = 1;
        transformState.x = 0; 
        transformState.y = 0;

        $('#opacitySlider').value = transformState.opacity * 100;
        $('#opacityValue').textContent = `${Math.round(transformState.opacity * 100)}%`;
        $('#scaleSlider').value = transformState.scale * 100;
        $('#scaleValue').textContent = `${Math.round(transformState.scale * 100)}%`;
        $('#rotationSlider').value = transformState.rotation;
        $('#rotationValue').textContent = `${transformState.rotation}¬∞`;
    }
    
    function createDeformMarkers() {
        $$('#deformationContainer.point-marker').forEach(m => m.remove());

        deformationDestPoints.forEach((point, index) => {
            const marker = document.createElement('div');
            marker.className = 'point-marker';
            marker.textContent = index + 1;
            marker.style.left = `${point.x}px`;
            marker.style.top = `${point.y}px`;
            marker.dataset.index = index;
            deformationContainer.appendChild(marker);

            marker.onpointerdown = e => {
                e.preventDefault();
                e.stopPropagation();
                activeDeformPointIndex = parseInt(e.target.dataset.index);
                marker.setPointerCapture(e.pointerId);
                
                const onMove = (ev) => {
                    if (activeDeformPointIndex === -1) return;
                    const rect = deformationContainer.getBoundingClientRect();
                    const x = ev.clientX - rect.left;
                    const y = ev.clientY - rect.top;

                    deformationDestPoints.x = x;
                    deformationDestPoints.y = y;
                    
                    marker.style.left = `${x}px`;
                    marker.style.top = `${y}px`;
                    
                    requestAnimationFrame(drawDeformedGobo);
                };

                const onUp = () => {
                    deformationContainer.removeEventListener('pointermove', onMove);
                    deformationContainer.removeEventListener('pointerup', onUp);
                    marker.releasePointerCapture(e.pointerId);
                    activeDeformPointIndex = -1;
                    saveStateForUndo(); 
                };
                
                deformationContainer.addEventListener('pointermove', onMove);
                deformationContainer.addEventListener('pointerup', onUp);
            };
        });
    }
    
    function updateDeformMarkersPositions() {
         deformationDestPoints.forEach((point, index) => {
            const marker = $(`#deformationContainer.point-marker[data-index="${index}"]`);
            if (marker) {
                marker.style.left = `${point.x}px`;
                marker.style.top = `${point.y}px`;
            }
        });
    }

    function initStep4Controls() {
        $('#opacitySlider').oninput = e => {
            transformState.opacity = parseFloat(e.target.value) / 100;
            $('#opacityValue').textContent = `${e.target.value}%`;
            drawDeformedGobo();
        };
        $('#opacitySlider').onchange = saveStateForUndo; 

        $('#scaleSlider').oninput = e => {
            transformState.scale = parseFloat(e.target.value) / 100;
            $('#scaleValue').textContent = `${e.target.value}%`;
            drawDeformedGobo();
        };
        $('#scaleSlider').onchange = saveStateForUndo;

        $('#rotationSlider').oninput = e => {
            transformState.rotation = parseInt(e.target.value);
            $('#rotationValue').textContent = `${e.target.value}¬∞`;
            drawDeformedGobo();
        };
        $('#rotationSlider').onchange = saveStateForUndo;

        $('#toggleGoboVisibility').onclick = () => {
            isGoboVisible =!isGoboVisible;
            $('#toggleGoboVisibility').textContent = isGoboVisible? 'üëÅÔ∏è –°–∫—Ä—ã—Ç—å –ì–æ–±–æ' : 'üëÅÔ∏è –ü–æ–∫–∞–∑–∞—Ç—å –ì–æ–±–æ';
            drawDeformedGobo();
        };
        
        $('#undoTransform').onclick = restoreLastState;
        $('#resetTransform').onclick = () => {
            initializeTransformState(); 
            const scaleX = deformationCanvas.width / bgPhoto.displayWidth;
            const scaleY = deformationCanvas.height / bgPhoto.displayHeight;
            deformationDestPoints = assignedPoints.map((p, index) => ({
                x: p.x * scaleX,
                y: p.y * scaleY,
                originalIndex: index
            }));
            updateDeformMarkersPositions();
            drawDeformedGobo();
            saveStateForUndo();
        };

        $('#saveProject').onclick = saveProjectState;
        $('#loadProjectInput').onchange = e => loadProjectState(e.target.files);
        $('#runTour').onclick = () => startTour(); 
        $('#goToStep5').onclick = () => goToStep(5);
    }
    
    function drawDeformedGobo() {
        if (!goboImage.img ||!dCtx) return;
        dCtx.clearRect(0, 0, deformationCanvas.width, deformationCanvas.height);

        if (!isGoboVisible |
| deformationDestPoints.length < 3) return;

        dCtx.save();
        dCtx.globalAlpha = transformState.opacity;

        const bbox = calculateBoundingBox(deformationDestPoints); 
        dCtx.translate(bbox.cx, bbox.cy);
        dCtx.rotate(transformState.rotation * Math.PI / 180);
        
        const currentGlobalScale = transformState.baseScale * transformState.scale;
        dCtx.scale(currentGlobalScale, currentGlobalScale); 
        dCtx.translate(-goboImage.originalWidth / 2, -goboImage.originalHeight / 2); // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º —Å–∞–º–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≥–æ–±–æ –ø–µ—Ä–µ–¥ —Ç—Ä–∏–∞–Ω–≥—É–ª—è—Ü–∏–µ–π

        const srcPointsForTriangulation = initialGoboContourPoints.map(p => [p.x, p.y]);
        
        // –¢–æ—á–∫–∏ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è —Ç—Ä–∏–∞–Ω–≥—É–ª—è—Ü–∏–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Ü–µ–Ω—Ç—Ä–∞ bbox –∏ –Ω–µ–º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω—ã –≥–ª–æ–±–∞–ª—å–Ω—ã–º –º–∞—Å—à—Ç–∞–±–æ–º,
        // —Ç–∞–∫ –∫–∞–∫ –æ–Ω —É–∂–µ –ø—Ä–∏–º–µ–Ω–µ–Ω –∫ dCtx. –û–Ω–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤ —Å–∏—Å—Ç–µ–º–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç "–µ–¥–∏–Ω–∏—á–Ω–æ–≥–æ" –≥–æ–±–æ.
        const destPointsForTriangulation = deformationDestPoints.map(p => {
            // 1. –ü–µ—Ä–µ–≤–æ–¥–∏–º –≤ —Å–∏—Å—Ç–µ–º—É –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç, –≥–¥–µ —Ü–µ–Ω—Ç—Ä bbox = (0,0)
            let x = p.x - bbox.cx;
            let y = p.y - bbox.cy;
            // 2. "–û—Ç–º–µ–Ω—è–µ–º" –≥–ª–æ–±–∞–ª—å–Ω—ã–π –ø–æ–≤–æ—Ä–æ—Ç –∏ –º–∞—Å—à—Ç–∞–±, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å —Ç–æ—á–∫–∏ –≤ —Å–∏—Å—Ç–µ–º–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç, –≥–¥–µ –≥–æ–±–æ –µ—â–µ –Ω–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω –≥–ª–æ–±–∞–ª—å–Ω–æ
            const invRotation = -transformState.rotation * Math.PI / 180;
            const cosR = Math.cos(invRotation);
            const sinR = Math.sin(invRotation);
            let rotX = x * cosR - y * sinR;
            let rotY = x * sinR + y * cosR;

            x = rotX / currentGlobalScale + goboImage.originalWidth / 2;
            y = rotY / currentGlobalScale + goboImage.originalHeight / 2;
            return [x,y];
        });


        try {
            const delaunay = Delaunator.from(destPointsForTriangulation);

            for (let i = 0; i < delaunay.triangles.length; i += 3) {
                const t1_idx_local = delaunay.triangles[i];
                const t2_idx_local = delaunay.triangles[i+1];
                const t3_idx_local = delaunay.triangles[i+2];

                // –ò—Å—Ö–æ–¥–Ω—ã–µ —Ç–æ—á–∫–∏ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞ –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏ –≥–æ–±–æ (–∏–∑ initialGoboContourPoints)
                // –í–∞–∂–Ω–æ: originalIndex –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω–æ –Ω–∞—Å—Ç—Ä–æ–µ–Ω, –µ—Å–ª–∏ initialGoboContourPoints –Ω–µ –ø—Ä–æ—Å—Ç–æ —É–≥–ª—ã.
                // –î–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã, –µ—Å–ª–∏ initialGoboContourPoints - —ç—Ç–æ –ø—Ä–æ—Å—Ç–æ —É–≥–ª—ã, –∞ destPointsForTriangulation - —ç—Ç–æ —Ç–æ—á–∫–∏ –∫–æ–Ω—Ç—É—Ä–∞,
                // —Ç–æ –∏–Ω–¥–µ–∫—Å—ã –¥–æ–ª–∂–Ω—ã —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å.
                const p1_src = initialGoboContourPoints.originalIndex];
                const p2_src = initialGoboContourPoints.originalIndex];
                const p3_src = initialGoboContourPoints.originalIndex];

                // –ö–æ–Ω–µ—á–Ω—ã–µ —Ç–æ—á–∫–∏ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞ (–≤ —Å–∏—Å—Ç–µ–º–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç "–µ–¥–∏–Ω–∏—á–Ω–æ–≥–æ" –≥–æ–±–æ)
                const p1_dest_local = { x: destPointsForTriangulation[t1_idx_local], y: destPointsForTriangulation[t1_idx_local][1] };
                const p2_dest_local = { x: destPointsForTriangulation[t2_idx_local], y: destPointsForTriangulation[t2_idx_local][1] };
                const p3_dest_local = { x: destPointsForTriangulation[t3_idx_local], y: destPointsForTriangulation[t3_idx_local][1] };
                
                if (!p1_src ||!p2_src ||!p3_src) {
                    console.warn("–ü—Ä–æ–ø—É—Å–∫ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞ –∏–∑-–∑–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è –∏—Å—Ö–æ–¥–Ω—ã—Ö —Ç–æ—á–µ–∫");
                    continue;
                }

                const srcTriangle = [p1_src, p2_src, p3_src];
                const destTriangleLocal = [p1_dest_local, p2_dest_local, p3_dest_local];
                
                const transformMatrix = Matrix.fromTriangles(srcTriangle, destTriangleLocal);

                dCtx.save();
                dCtx.beginPath();
                dCtx.moveTo(p1_dest_local.x, p1_dest_local.y);
                dCtx.lineTo(p2_dest_local.x, p2_dest_local.y);
                dCtx.lineTo(p3_dest_local.x, p3_dest_local.y);
                dCtx.closePath();
                dCtx.clip();

                dCtx.transform(transformMatrix.a, transformMatrix.b, transformMatrix.c, transformMatrix.d, transformMatrix.e, transformMatrix.f);
                
                dCtx.drawImage(goboImage.img, 0, 0, goboImage.originalWidth, goboImage.originalHeight);
                dCtx.restore(); 
            }
        } catch (error) {
            console.error("–û—à–∏–±–∫–∞ —Ç—Ä–∏–∞–Ω–≥—É–ª—è—Ü–∏–∏ –∏–ª–∏ –æ—Ç—Ä–∏—Å–æ–≤–∫–∏:", error);
        }
        dCtx.restore(); 
    }


    // ========== –®–∞–≥ 5: –≠–∫—Å–ø–æ—Ä—Ç ==========
    function setupStep5UI() {
        exportPreviewCanvas = $('#exportPreviewCanvas');
        epCtx = exportPreviewCanvas.getContext('2d');
        updatePixelSizeDisplay();
        generateExportPreview(); 
    }

    function initStep5Controls() {
        $('#printPreset').onchange = () => {
            const presetValue = $('#printPreset').value;
            if (presetValue === 'custom') return;
            const [diameter, dpi, pixels] = presetValue.split(',');
            $('#printDiameter').value = diameter;
            $('#printDPI').value = dpi;
            updatePixelSizeDisplay();
            generateExportPreview();
        };
        $('#printDiameter').oninput = () => { $('#printPreset').value = 'custom'; updatePixelSizeDisplay(); generateExportPreview(); };
        $('#printDPI').oninput = () => { $('#printPreset').value = 'custom'; updatePixelSizeDisplay(); generateExportPreview(); };

        $('#exportPNG').onclick = () => exportImage('png');
        $('#exportTIFF').onclick = () => exportImage('tiff');
    }

    function updatePixelSizeDisplay() {
        const diameterMM = parseFloat($('#printDiameter').value);
        const dpi = parseInt($('#printDPI').value);
        if (isNaN(diameterMM) |
| isNaN(dpi) |
| diameterMM <= 0 |
| dpi <= 0) {
            $('#pixelSize').value = 'N/A';
            return;
        }
        const pixels = Math.round((diameterMM / 25.4) * dpi);
        $('#pixelSize').value = `${pixels} x ${pixels} px`;
    }

    function generateExportPreview() {
        const diameterMM = parseFloat($('#printDiameter').value);
        const dpi = parseInt($('#printDPI').value);
        if (isNaN(diameterMM) |
| isNaN(dpi) |
| diameterMM <= 0 |
| dpi <= 0) {
            showNotification("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞.");
            return;
        }
        const targetPixelSize = Math.round((diameterMM / 25.4) * dpi);
        
        const previewSize = Math.min(targetPixelSize, 400); 
        exportPreviewCanvas.width = previewSize;
        exportPreviewCanvas.height = previewSize;

        renderToContext(epCtx, previewSize, previewSize, goboImage.img, initialGoboContourPoints, deformationDestPoints, transformState, deformationCanvas.width, deformationCanvas.height, true);
        
        epCtx.globalCompositeOperation = 'destination-in';
        epCtx.beginPath();
        epCtx.arc(previewSize / 2, previewSize / 2, previewSize / 2, 0, 2 * Math.PI);
        epCtx.fillStyle = 'black'; 
        epCtx.fill();
        epCtx.globalCompositeOperation = 'source-over'; 
    }
    
    function renderToContext(targetCtx, targetWidth, targetHeight, goboForRender, initialSrcPoints, currentDestPointsOnScreen, currentTransformState, screenCanvasWidth, screenCanvasHeight, isPreview = false) {
        targetCtx.clearRect(0, 0, targetWidth, targetHeight);
        if (!goboForRender |
| currentDestPointsOnScreen.length < 3) return;

        targetCtx.save();
        targetCtx.globalAlpha = currentTransformState.opacity;

        const scaleToExportX = targetWidth / screenCanvasWidth; 
        const scaleToExportY = targetHeight / screenCanvasHeight; 

        const destPointsForExportRender = currentDestPointsOnScreen.map(p => {
            return { x: p.x * scaleToExportX, y: p.y * scaleToExportY, originalIndex: p.originalIndex };
        });
        
        const bboxExport = calculateBoundingBox(destPointsForExportRender);

        targetCtx.translate(bboxExport.cx, bboxExport.cy);
        targetCtx.rotate(currentTransformState.rotation * Math.PI / 180);
        
        const effectiveGlobalScale = currentTransformState.baseScale * currentTransformState.scale;
        targetCtx.scale(effectiveGlobalScale, effectiveGlobalScale);
        targetCtx.translate(-goboForRender.width / 2, -goboForRender.height / 2); // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º —Å–∞–º–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≥–æ–±–æ

        // –ò—Å—Ö–æ–¥–Ω—ã–µ —Ç–æ—á–∫–∏ –Ω–∞ –≥–æ–±–æ (–Ω–µ–∏–∑–º–µ–Ω–Ω—ã–µ)
        const srcPointsForTriangulation = initialSrcPoints.map(p => [p.x, p.y]);
        
        // –ö–æ–Ω–µ—á–Ω—ã–µ —Ç–æ—á–∫–∏ –¥–ª—è —Ç—Ä–∏–∞–Ω–≥—É–ª—è—Ü–∏–∏ (–≤ —Å–∏—Å—Ç–µ–º–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç "–µ–¥–∏–Ω–∏—á–Ω–æ–≥–æ" –≥–æ–±–æ, –Ω–æ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∫ –µ–≥–æ —Ä–∞–∑–º–µ—Ä—É)
        const destPointsForTriangulationOnExport = destPointsForExportRender.map(p_screen => {
            let x = p_screen.x - bboxExport.cx;
            let y = p_screen.y - bboxExport.cy;
            
            const invRotation = -currentTransformState.rotation * Math.PI / 180;
            const cosR = Math.cos(invRotation);
            const sinR = Math.sin(invRotation);
            let rotX = x * cosR - y * sinR;
            let rotY = x * sinR + y * cosR;

            x = rotX / effectiveGlobalScale + goboForRender.width / 2;
            y = rotY / effectiveGlobalScale + goboForRender.height / 2;
            return [x,y];
        });
        
        try {
            const delaunay = Delaunator.from(destPointsForTriangulationOnExport);
            for (let i = 0; i < delaunay.triangles.length; i += 3) {
                const t1_idx_local = delaunay.triangles[i];
                const t2_idx_local = delaunay.triangles[i+1];
                const t3_idx_local = delaunay.triangles[i+2];

                const p1_src_exp = initialSrcPoints.originalIndex];
                const p2_src_exp = initialSrcPoints.originalIndex];
                const p3_src_exp = initialSrcPoints.originalIndex];

                const p1_dest_local_exp = { x: destPointsForTriangulationOnExport[t1_idx_local], y: destPointsForTriangulationOnExport[t1_idx_local][1] };
                const p2_dest_local_exp = { x: destPointsForTriangulationOnExport[t2_idx_local], y: destPointsForTriangulationOnExport[t2_idx_local][1] };
                const p3_dest_local_exp = { x: destPointsForTriangulationOnExport[t3_idx_local], y: destPointsForTriangulationOnExport[t3_idx_local][1] };

                if (!p1_src_exp ||!p2_src_exp ||!p3_src_exp) continue;

                const srcTriangleExp = [p1_src_exp, p2_src_exp, p3_src_exp];
                const destTriangleLocalExp = [p1_dest_local_exp, p2_dest_local_exp, p3_dest_local_exp];
                
                const transformMatrixExp = Matrix.fromTriangles(srcTriangleExp, destTriangleLocalExp);

                targetCtx.save();
                targetCtx.beginPath();
                targetCtx.moveTo(p1_dest_local_exp.x, p1_dest_local_exp.y);
                targetCtx.lineTo(p2_dest_local_exp.x, p2_dest_local_exp.y);
                targetCtx.lineTo(p3_dest_local_exp.x, p3_dest_local_exp.y);
                targetCtx.closePath();
                targetCtx.clip();
                targetCtx.transform(transformMatrixExp.a, transformMatrixExp.b, transformMatrixExp.c, transformMatrixExp.d, transformMatrixExp.e, transformMatrixExp.f);
                targetCtx.drawImage(goboForRender, 0, 0, goboForRender.width, goboForRender.height);
                targetCtx.restore();
            }
        } catch (error) {
            console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–µ –Ω–∞ —Ü–µ–ª–µ–≤–æ–π —Ö–æ–ª—Å—Ç:", error);
            if (!isPreview) showNotification("–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞.");
        }
        targetCtx.restore();
    }


    function exportImage(type) {
        const diameterMM = parseFloat($('#printDiameter').value);
        const dpi = parseInt($('#printDPI').value);
        if (isNaN(diameterMM) |
| isNaN(dpi) |
| diameterMM <= 0 |
| dpi <= 0) {
            showNotification('–û—à–∏–±–∫–∞: –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–µ—á–∞—Ç–∏.');
            return;
        }
        const finalPixelSize = Math.round((diameterMM / 25.4) * dpi);
        if (finalPixelSize > 8000) { 
             showNotification('–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ: –ó–∞–ø—Ä–æ—à–µ–Ω–Ω—ã–π —Ä–∞–∑–º–µ—Ä –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å–ª–∏—à–∫–æ–º –≤–µ–ª–∏–∫ (>8000px). –≠–∫—Å–ø–æ—Ä—Ç –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –º–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ –∏–ª–∏ –∑–∞–≤–µ—Ä—à–∏—Ç—å—Å—è –æ—à–∏–±–∫–æ–π.', 5000);
        }

        const exportCanvas = document.createElement('canvas');
        exportCanvas.width = finalPixelSize;
        exportCanvas.height = finalPixelSize;
        const exportCtx = exportCanvas.getContext('2d');

        showNotification('–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞...', 20000); 

        renderToContext(exportCtx, finalPixelSize, finalPixelSize, goboImage.img, initialGoboContourPoints, deformationDestPoints, transformState, deformationCanvas.width, deformationCanvas.height, false);

        if (type === 'png') {
            exportCanvas.toBlob(blob => {
                downloadFile(blob, `gobo-export-${finalPixelSize}px.png`, 'image/png');
                showNotification('PNG —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω.', 3000);
            }, 'image/png');
        } else if (type === 'tiff') {
            try {
                CanvasToTIFF.toBlob(exportCanvas, blob => {
                     downloadFile(blob, `gobo-export-${finalPixelSize}px-${dpi}dpi.tiff`, 'image/tiff');
                     showNotification('TIFF —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω.', 3000);
                }, { dpi: dpi, alpha: true }); 
            } catch (err) {
                console.error("–û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞ –≤ TIFF:", err);
                showNotification("–û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞ –≤ TIFF: " + err.message, 5000);
            }
        }
    }

    // ========== –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ/–ó–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–æ–µ–∫—Ç–∞ ==========
    function saveProjectState() {
        if (!bgPhoto.dataURL ||!goboImage.dataURL) {
            showNotification('–ù–µ—á–µ–≥–æ —Å–æ—Ö—Ä–∞–Ω—è—Ç—å: –∑–∞–≥—Ä—É–∑–∏—Ç–µ —Ñ–æ–Ω–æ–≤–æ–µ —Ñ–æ—Ç–æ –∏ –≥–æ–±–æ.');
            return;
        }
        const projectData = {
            version: "2.1",
            bgPhoto: { dataURL: bgPhoto.dataURL, originalWidth: bgPhoto.originalWidth, originalHeight: bgPhoto.originalHeight, displayWidth: bgPhoto.displayWidth, displayHeight: bgPhoto.displayHeight },
            goboImage: { dataURL: goboImage.dataURL, originalWidth: goboImage.originalWidth, originalHeight: goboImage.originalHeight },
            assignedPoints: assignedPoints.map(p => ({ x: p.x, y: p.y })), 
            deformationDestPoints: deformationDestPoints.map(p => ({ x: p.x, y: p.y, originalIndex: p.originalIndex })),
            initialGoboContourPoints: initialGoboContourPoints,
            transformState: transformState,
            currentStep: currentStep
        };
        downloadFile(JSON.stringify(projectData), 'gobo-project.json', 'application/json');
        showNotification('–ü—Ä–æ–µ–∫—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω.');
    }

    function loadProjectState(files) {
        if (!files |
| files.length === 0) {
            showNotification('–û—à–∏–±–∫–∞: –§–∞–π–ª –ø—Ä–æ–µ–∫—Ç–∞ –Ω–µ –≤—ã–±—Ä–∞–Ω.');
            return;
        }
        const file = files;

        const reader = new FileReader();
        reader.onload = e => {
            try {
                const projectData = JSON.parse(e.target.result);
                if (projectData.version!== "2.1") { 
                    showNotification("–§–∞–π–ª –ø—Ä–æ–µ–∫—Ç–∞ –Ω–µ—Å–æ–≤–º–µ—Å—Ç–∏–º –∏–ª–∏ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω.", 5000);
                    return;
                }

                bgPhoto = projectData.bgPhoto;
                bgPhoto.img = new Image();
                bgPhoto.img.onload = () => {
                    goboImage = projectData.goboImage;
                    goboImage.img = new Image();
                    goboImage.img.onload = () => {
                        $$('#contourImageContainer.point-marker').forEach(el => el.remove());
                        assignedPoints =; 
                        projectData.assignedPoints.forEach(p => addContourPoint(p.x, p.y)); 
                        
                        deformationDestPoints = projectData.deformationDestPoints;
                        initialGoboContourPoints = projectData.initialGoboContourPoints;
                        transformState = projectData.transformState;
                        
                        if (projectData.currentStep >= 2) {
                            setupStep2UI(); 
                            assignedPoints.forEach(p => { 
                                p.element.style.left = p.x + 'px';
                                p.element.style.top = p.y + 'px';
                                if(!p.element.parentNode) contourImageContainer.appendChild(p.element);
                            });
                            drawContourPolygon();
                            updatePointCountAndProceedButton();
                        }
                        if (projectData.currentStep >= 3) {
                             $('#goboPreview').innerHTML = `<img src="${goboImage.dataURL}" alt="–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –≥–æ–±–æ">`;
                             $('#goToStep4').disabled = false;
                        }
                        if (projectData.currentStep >= 4) {
                            setupStep4UI(); 
                        }
                        
                        goToStep(projectData.currentStep |
| 1);
                        showNotification('–ü—Ä–æ–µ–∫—Ç –∑–∞–≥—Ä—É–∂–µ–Ω.');
                        historyStack =; 
                    };
                    goboImage.img.src = goboImage.dataURL;
                };
                bgPhoto.img.src = bgPhoto.dataURL;

            } catch (err) {
                console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–æ–µ–∫—Ç–∞:", err);
                showNotification('–û—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞ –ø—Ä–æ–µ–∫—Ç–∞.');
            }
        };
        reader.readAsText(file);
        $('#loadProjectInput').value = ''; 
    }
    
    function downloadFile(content, fileName, contentType) {
        const a = document.createElement('a');
        const file = new Blob([content], { type: contentType });
        a.href = URL.createObjectURL(file);
        a.download = fileName;
        a.click();
        URL.revokeObjectURL(a.href);
    }

    // ========== –û—Ç–º–µ–Ω–∞ –¥–µ–π—Å—Ç–≤–∏–π (Undo) ==========
    function saveStateForUndo() {
        const stateSnapshot = {
            assignedPoints: assignedPoints.map(p => ({ x: p.x, y: p.y })), 
            deformationDestPoints: deformationDestPoints.map(p => ({ x: p.x, y: p.y, originalIndex: p.originalIndex })),
            transformState: JSON.parse(JSON.stringify(transformState)) 
        };
        historyStack.push(stateSnapshot);
        if (historyStack.length > 10) { 
            historyStack.shift();
        }
    }

    function restoreLastState() {
        if (historyStack.length < 2) { 
            showNotification('–ù–µ—Ç –¥–µ–π—Å—Ç–≤–∏–π –¥–ª—è –æ—Ç–º–µ–Ω—ã.');
            return;
        }
        historyStack.pop(); 
        const prevState = historyStack; 
        if (!prevState) return;

        if (currentStep === 2) {
            assignedPoints.forEach(p => p.element.remove()); 
            assignedPoints =;
            prevState.assignedPoints.forEach(pData => addContourPoint(pData.x, pData.y)); 
        }
        
        if (currentStep === 4) {
            deformationDestPoints = prevState.deformationDestPoints.map(p => ({...p})); 
            transformState = JSON.parse(JSON.stringify(prevState.transformState)); 

            $('#opacitySlider').value = transformState.opacity * 100;
            $('#opacityValue').textContent = `${Math.round(transformState.opacity * 100)}%`;
            $('#scaleSlider').value = transformState.scale * 100; 
            $('#scaleValue').textContent = `${Math.round(transformState.scale * 100)}%`;
            $('#rotationSlider').value = transformState.rotation;
            $('#rotationValue').textContent = `${transformState.rotation}¬∞`;
            
            updateDeformMarkersPositions(); 
            drawDeformedGobo(); 
        }
        showNotification('–ü–æ—Å–ª–µ–¥–Ω–µ–µ –¥–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.');
    }

    // ========== PWA: –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è Service Worker ==========
    function registerServiceWorker() {
        if ('serviceWorker' in navigator) {
            const swJS = $('#sw-data').textContent;
            // –°–æ–∑–¥–∞–µ–º Blob URL –¥–ª—è SW, —á—Ç–æ–±—ã –æ–Ω –±—ã–ª –∏–∑ —Ç–æ–≥–æ –∂–µ origin, —á—Ç–æ –∏ —Å—Ç—Ä–∞–Ω–∏—Ü–∞
            const swUrl = URL.createObjectURL(new Blob(, {type: 'application/javascript'}));
            
            navigator.serviceWorker.register(swUrl) 
              .then(registration => {
                    console.log('Service Worker –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω —É—Å–ø–µ—à–Ω–æ, scope:', registration.scope);
                })
              .catch(error => {
                    console.error('–û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ Service Worker:', error);
                });
        }
    }
    
    // ========== –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è ==========
    window.onload = () => {
        initStep1();
        initStep2(); 
        initStep3();
        initStep4Controls(); 
        initStep5Controls();

        registerServiceWorker(); 
    };

    </script>
</body>
</html>
