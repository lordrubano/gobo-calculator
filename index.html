<!DOCTYPE html><html lang="ru"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Профессиональный редактор-калькулятор для гобо (Финальная версия)</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css">
    <script src="https://d3js.org/d3-delaunay.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
    <style>
        .canvas-container { position: relative; border: 2px solid #374151; border-radius: 8px; overflow: hidden; }
        .canvas-container canvas { display: block; cursor: crosshair; width: 100%; height: auto; }
        .magnifier { position: absolute; width: 120px; height: 120px; border: 2px solid #3B82F6; border-radius: 50%; background: white; box-shadow: 0 4px 12px rgba(0,0,0,0.3); pointer-events: none; z-index: 1000; display: none; overflow: hidden; }
        .magnifier canvas { width: 120px; height: 120px; border-radius: 50%; }
        .point-marker { position: absolute; width: 18px; height: 18px; border: 2px solid white; border-radius: 50%; transform: translate(-50%, -50%); cursor: move; z-index: 100; font-size: 10px; color: white; text-align: center; line-height: 14px; font-weight: bold; text-shadow: 1px 1px 2px rgba(0,0,0,0.8); }
        .point-marker:hover { transform: translate(-50%, -50%) scale(1.2); }
        .panel-header { background: linear-gradient(135deg, #1E40AF, #3B82F6); color: white; padding: 12px; border-radius: 8px 8px 0 0; font-weight: bold; display: flex; align-items: center; gap: 8px; }
        .status-ready { color: #10B981; } .status-working { color: #F59E0B; } .status-error { color: #EF4444; }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen">
    <div class="container mx-auto px-4 py-6">
        <div class="text-center mb-8"><h1 class="text-3xl font-bold text-blue-400 mb-2"><i class="fas fa-image mr-2"></i>Профессиональный редактор-калькулятор для гобо</h1><p class="text-gray-400">Финальная стабильная версия</p></div>
        <div class="flex flex-wrap justify-center gap-4 mb-8">
            <button id="loadTemplate" class="bg-blue-600 hover:bg-blue-700 px-6 py-3 rounded-lg font-semibold transition-colors"><i class="fas fa-image mr-2"></i>Загрузить фото-шаблон</button>
            <button id="loadSource" class="bg-green-600 hover:bg-green-700 px-6 py-3 rounded-lg font-semibold transition-colors"><i class="fas fa-upload mr-2"></i>Загрузить изображение</button>
            <button id="clearPoints" class="bg-red-600 hover:bg-red-700 px-6 py-3 rounded-lg font-semibold transition-colors"><i class="fas fa-trash mr-2"></i>Очистить точки</button>
            <button id="exportBtn" class="bg-purple-600 hover:bg-purple-700 px-6 py-3 rounded-lg font-semibold transition-colors" disabled><i class="fas fa-download mr-2"></i>Экспорт</button>
        </div>
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">
            <div class="bg-gray-800 rounded-lg overflow-hidden"><div class="panel-header"><i class="fas fa-image-portrait"></i><span>Исходное изображение</span></div><div class="p-4"><div class="canvas-container relative"><canvas id="sourceCanvas"></canvas></div><div class="mt-2 text-center"><span class="text-sm">Точек источника: <span id="sourceCount" class="font-bold text-blue-400">0</span></span></div></div></div>
            <div class="bg-gray-800 rounded-lg overflow-hidden"><div class="panel-header"><i class="fas fa-crosshairs"></i><span>Фото-шаблон</span></div><div class="p-4"><div class="canvas-container relative"><canvas id="templateCanvas"></canvas></div><div class="mt-2 text-center"><span class="text-sm">Точек цели: <span id="targetCount" class="font-bold text-green-400">0</span></span></div></div></div>
            <div class="bg-gray-800 rounded-lg overflow-hidden"><div class="panel-header"><i class="fas fa-eye"></i><span>Предпросмотр деформации</span></div><div class="p-4"><div class="canvas-container"><canvas id="previewCanvas"></canvas></div><div class="mt-2 text-center"><span class="text-sm">Статус: <span id="previewStatus" class="font-bold">Загрузите изображения</span></span></div></div></div>
        </div>
        <div class="bg-gray-800 rounded-lg p-6"><h3 class="text-xl font-bold text-yellow-400 mb-4"><i class="fas fa-info-circle mr-2"></i>Инструкция по использованию:</h3><div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm text-gray-300"><div><p class="mb-2">1. Загрузите фото-шаблон</p><p class="mb-2">2. Загрузите исходное изображение</p><p class="mb-2">3. Кликните по ключевым точкам на исходном изображении (минимум 4)</p><p class="mb-2">4. Кликните по соответствующим точкам на фото-шаблоне в том же порядке</p></div><div><p class="mb-2">5. Используйте лупу для точного позиционирования</p><p class="mb-2">6. Перетаскивайте точки для финальной подгонки</p><p class="mb-2">7. Наблюдайте real-time деформацию в окне предпросмотра</p><p class="mb-2">8. Нажмите "Экспорт" для создания готового файла гобо</p></div></div></div>
    </div>
    <div id="magnifier" class="magnifier"></div>
    <input type="file" id="templateInput" accept="image/*" style="display: none;"><input type="file" id="sourceInput" accept="image/*" style="display: none;">
    <div id="exportModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" style="display: none;"><div class="bg-gray-800 p-8 rounded-lg max-w-md w-full mx-4"><h3 class="text-xl font-bold mb-6 text-center">Параметры экспорта</h3><div class="space-y-4"><div><label class="block text-sm font-medium mb-2">Физический диаметр гобо (мм):</label><input type="number" id="diameterInput" value="37.5" min="10" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white"></div><div><label class="block text-sm font-medium mb-2">Требуемое разрешение (DPI):</label><input type="number" id="dpiInput" value="2700" min="300" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white"></div><div class="flex space-x-4 pt-4"><button id="confirmExport" class="flex-1 bg-purple-600 hover:bg-purple-700 py-2 px-4 rounded-md font-semibold transition-colors"><i class="fas fa-download mr-2"></i>Сохранить</button><button id="cancelExport" class="flex-1 bg-gray-600 hover:bg-gray-700 py-2 px-4 rounded-md font-semibold transition-colors">Отмена</button></div></div></div></div>
    
    <script>
        class GoboEditor {
            constructor() {
                this.sourcePoints = []; this.targetPoints = [];
                this.sourceImage = null; this.templateImage = null;
                this.draggingPoint = null; this.sourceRenderInfo = {};
                this.initCanvases(); this.bindEvents();
            }

            initCanvases() {
                ['source', 'template', 'preview'].forEach(type => {
                    this[type + 'Canvas'] = document.getElementById(type + 'Canvas');
                    this[type + 'Ctx'] = this[type + 'Canvas'].getContext('2d');
                });
                this.magnifier = document.getElementById('magnifier');
            }

            bindEvents() {
                const resizeObserver = new ResizeObserver(() => this.onResize());
                resizeObserver.observe(this.sourceCanvas.parentElement);

                document.getElementById('loadTemplate').addEventListener('click', () => document.getElementById('templateInput').click());
                document.getElementById('loadSource').addEventListener('click', () => document.getElementById('sourceInput').click());
                document.getElementById('templateInput').addEventListener('change', e => this.loadImage(e.target.files[0], 'template'));
                document.getElementById('sourceInput').addEventListener('change', e => this.loadImage(e.target.files[0], 'source'));
                document.getElementById('clearPoints').addEventListener('click', () => this.clearAllPoints());
                document.getElementById('exportBtn').addEventListener('click', () => document.getElementById('exportModal').style.display = 'flex');
                document.getElementById('cancelExport').addEventListener('click', () => document.getElementById('exportModal').style.display = 'none');
                document.getElementById('confirmExport').addEventListener('click', () => this.exportGobo());

                this.bindCanvasEvents(this.sourceCanvas, this.sourcePoints);
                this.bindCanvasEvents(this.templateCanvas, this.targetPoints);
            }
            
            onResize() {
                [this.sourceCanvas, this.templateCanvas, this.previewCanvas].forEach(canvas => {
                    const container = canvas.parentElement;
                    canvas.width = container.clientWidth;
                    canvas.height = container.clientHeight;
                });
                this.renderAll();
            }

            loadImage(file, type) {
                if (!file) return;
                const reader = new FileReader();
                reader.onload = e => {
                    const img = new Image();
                    img.crossOrigin = "anonymous";
                    img.onload = () => {
                        if (type === 'source') this.sourceImage = img;
                        else this.templateImage = img;
                        this.renderAll();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            bindCanvasEvents(canvas, points) {
                const getCoords = e => { const rect = canvas.getBoundingClientRect(); return { x: e.clientX - rect.left, y: e.clientY - rect.top }; };
                canvas.addEventListener('mousedown', e => {
                    const coords = getCoords(e);
                    for (let i = 0; i < points.length; i++) {
                        if (Math.sqrt((coords.x - points[i][0])**2 + (coords.y - points[i][1])**2) < 10) {
                            this.draggingPoint = { index: i, points: points }; return;
                        }
                    }
                });
                canvas.addEventListener('mousemove', e => {
                    const coords = getCoords(e);
                    this.updateMagnifier(e, canvas, coords);
                    if (this.draggingPoint && this.draggingPoint.points === points) {
                        points[this.draggingPoint.index] = [coords.x, coords.y];
                        this.renderAll();
                    }
                });
                canvas.addEventListener('mouseup', () => { this.draggingPoint = null; });
                canvas.addEventListener('mouseleave', () => { this.draggingPoint = null; this.magnifier.style.display = 'none'; });
                canvas.addEventListener('mouseenter', () => { this.magnifier.style.display = 'block'; });
                canvas.addEventListener('click', e => {
                    if (this.draggingPoint) return;
                    const coords = getCoords(e);
                    for (let p of points) { if (Math.sqrt((coords.x - p[0])**2 + (coords.y - p[1])**2) < 10) return; }
                    if (canvas === this.sourceCanvas || points.length < this.sourcePoints.length) {
                        points.push([coords.x, coords.y]);
                        this.renderAll();
                    }
                });
            }

            clearAllPoints() { this.sourcePoints = []; this.targetPoints = []; this.renderAll(); }

            renderAll() {
                this.sourceRenderInfo = this.drawCanvasWithAspectRatio(this.sourceCtx, this.sourceCanvas, this.sourceImage, this.sourcePoints);
                this.drawCanvasWithAspectRatio(this.templateCtx, this.templateCanvas, this.templateImage, this.targetPoints);
                this.updatePreview();
                this.updateStatus();
            }

            drawCanvasWithAspectRatio(ctx, canvas, img, points) {
                const renderInfo = { ox: 0, oy: 0, dw: canvas.width, dh: canvas.height };
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if(img){
                    const ar = img.naturalWidth / img.naturalHeight;
                    if(ar > canvas.width / canvas.height) { renderInfo.dh = canvas.width / ar; renderInfo.oy = (canvas.height - renderInfo.dh) / 2; }
                    else { renderInfo.dw = canvas.height * ar; renderInfo.ox = (canvas.width - renderInfo.dw) / 2; }
                    ctx.drawImage(img, renderInfo.ox, renderInfo.oy, renderInfo.dw, renderInfo.dh);
                }
                points.forEach((p, i) => this.drawPoint(ctx, p, i + 1));
                return renderInfo;
            }

            drawPoint(ctx, p, n) {
                ctx.beginPath(); ctx.arc(p[0], p[1], 8, 0, 2 * Math.PI);
                ctx.fillStyle = n === 1 ? '#EF4444' : '#3B82F6'; ctx.fill();
                ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.stroke();
                ctx.fillStyle = 'white'; ctx.font = 'bold 10px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(n, p[0], p[1]);
            }

            updateMagnifier(e, canvas, coords) {
                const img = canvas === this.sourceCanvas ? this.sourceImage : this.templateImage;
                if (!img) { this.magnifier.style.display = 'none'; return; }
                this.magnifier.style.display = 'block';
                this.magnifier.style.left = `${e.clientX + 20}px`; this.magnifier.style.top = `${e.clientY - 60}px`;
                const ctx = this.magnifier.getContext('2d') || this.magnifier.appendChild(document.createElement('canvas')).getContext('2d');
                ctx.clearRect(0,0,120,120);
                const zoom = 4;
                ctx.drawImage(canvas, coords.x - 120 / zoom / 2, coords.y - 120 / zoom / 2, 120/zoom, 120/zoom, 0, 0, 120, 120);
                ctx.strokeStyle = '#EF4444'; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(60, 0); ctx.lineTo(60, 120); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, 60); ctx.lineTo(120, 60); ctx.stroke();
            }

            updateStatus() {
                const sC = this.sourcePoints.length, dC = this.targetPoints.length;
                document.getElementById('sourceCount').textContent = sC; document.getElementById('targetCount').textContent = dC;
                const statusSpan = document.getElementById('previewStatus'); const canWarp = sC >= 4 && sC === dC;
                if(canWarp){statusSpan.textContent='Готово к экспорту'; statusSpan.className='font-bold status-ready'; this.exportBtn.disabled = false;}
                else if(sC !== dC){statusSpan.textContent=`Синхронизация (${sC}/${dC})`; statusSpan.className='font-bold status-working'; this.exportBtn.disabled = true;}
                else{statusSpan.textContent='Расставьте точки'; statusSpan.className='font-bold'; this.exportBtn.disabled = true;}
            }

            updatePreview() {
                this.previewCtx.clearRect(0, 0, this.previewCanvas.width, this.previewCanvas.height);
                if (this.templateImage) this.drawCanvasWithAspectRatio(this.previewCtx, this.previewCanvas, this.templateImage, []);
                if (!this.sourceImage || this.sourcePoints.length < 4 || this.sourcePoints.length !== this.targetPoints.length) return;
                const warpedCanvas = this.getWarpedCanvas(this.sourceImage, this.sourcePoints, this.targetPoints, this.templateCanvas.width, this.templateCanvas.height);
                if (warpedCanvas) this.previewCtx.drawImage(warpedCanvas, 0, 0);
            }
            
            // --- ИСПРАВЛЕНИЕ 1: Использование d3.Delaunay для качественной триангуляции ---
            getDelaunayTriangulation(points) {
                if (points.length < 3) return [];
                const pointArray = points.map(p => [p[0], p[1]]);
                return d3.Delaunay.from(pointArray).triangles;
            }

            getWarpedCanvas(img, srcPts, destPts, w, h) {
                const warpedCanvas = document.createElement('canvas'); warpedCanvas.width = w; warpedCanvas.height = h;
                const warpedCtx = warpedCanvas.getContext('2d');
                const absSrcPts = srcPts.map(p => [(p[0] - this.sourceRenderInfo.ox) / this.sourceRenderInfo.dw * img.naturalWidth, (p[1] - this.sourceRenderInfo.oy) / this.sourceRenderInfo.dh * img.naturalHeight]);
                
                const triangles = this.getDelaunayTriangulation(destPts); // Триангулируем по целевым точкам для лучшего покрытия
                
                for (let i = 0; i < triangles.length; i += 3) {
                    const p_src = [absSrcPts[triangles[i]], absSrcPts[triangles[i+1]], absSrcPts[triangles[i+2]]];
                    const p_dest = [destPts[triangles[i]], destPts[triangles[i+1]], destPts[triangles[i+2]]];
                    
                    // --- ИСПРАВЛЕНИЕ 2: Проверка на вырожденные треугольники для стабильности ---
                    const triArea = (p0, p1, p2) => 0.5 * Math.abs(p0[0]*(p1[1]-p2[1]) + p1[0]*(p2[1]-p0[1]) + p2[0]*(p0[1]-p1[1]));
                    if (triArea(p_src[0], p_src[1], p_src[2]) < 0.1) continue;

                    warpedCtx.save();
                    warpedCtx.beginPath();
                    warpedCtx.moveTo(p_dest[0][0], p_dest[0][1]);
                    warpedCtx.lineTo(p_dest[1][0], p_dest[1][1]);
                    warpedCtx.lineTo(p_dest[2][0], p_dest[2][1]);
                    warpedCtx.closePath();
                    warpedCtx.clip();
                    const transform = this.getAffineTransform(p_src, p_dest);
                    if (transform) { warpedCtx.setTransform(transform.a, transform.b, transform.c, transform.d, transform.e, transform.f); warpedCtx.drawImage(img, 0, 0); }
                    warpedCtx.restore();
                }
                return warpedCanvas;
            }

            getAffineTransform(src, dst) {
                try {
                    const M = math.matrix([[src[0][0],src[0][1],1,0,0,0],[0,0,0,src[0][0],src[0][1],1],[src[1][0],src[1][1],1,0,0,0],[0,0,0,src[1][0],src[1][1],1],[src[2][0],src[2][1],1,0,0,0],[0,0,0,src[2][0],src[2][1],1]]);
                    const b = math.matrix([dst[0][0],dst[0][1],dst[1][0],dst[1][1],dst[2][0],dst[2][1]]);
                    const t = math.lusolve(M,b).valueOf().flat();
                    return {a:t[0],b:t[3],c:t[1],d:t[4],e:t[2],f:t[5]};
                } catch(e) { return null; }
            }

            // --- ИСПРАВЛЕНИЕ 3: Переработанный и надежный экспорт ---
            exportGobo() {
                const diameter = parseFloat(document.getElementById('diameterInput').value);
                const dpi = parseInt(document.getElementById('dpiInput').value);
                if (isNaN(diameter) || isNaN(dpi) || diameter <= 0 || dpi <= 0) { alert('Введите корректные значения.'); return; }
                
                const exportSizePx = Math.round((diameter / 25.4) * dpi);
                const exportCanvas = document.createElement('canvas');
                exportCanvas.width = exportSizePx; exportCanvas.height = exportSizePx;
                const exportCtx = exportCanvas.getContext('2d');
                
                exportCtx.fillStyle = 'black';
                exportCtx.beginPath();
                exportCtx.arc(exportSizePx / 2, exportSizePx / 2, exportSizePx / 2, 0, 2 * Math.PI);
                exportCtx.fill();
                
                let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
                this.targetPoints.forEach(p => { minX=Math.min(minX,p[0]); minY=Math.min(minY,p[1]); maxX=Math.max(maxX,p[0]); maxY=Math.max(maxY,p[1]); });
                const bboxWidth = maxX-minX, bboxHeight = maxY-minY;
                if (bboxWidth === 0 || bboxHeight === 0) return;
                
                const margin = 0.95; // 95% заполнение
                const scale = Math.min(exportSizePx*margin/bboxWidth, exportSizePx*margin/bboxHeight);
                const offsetX = (exportSizePx - (bboxWidth * scale)) / 2;
                const offsetY = (exportSizePx - (bboxHeight * scale)) / 2;

                const finalDestPoints = this.targetPoints.map(p => [(p[0]-minX)*scale + offsetX, (p[1]-minY)*scale + offsetY]);
                
                const warpedCanvas = this.getWarpedCanvas(this.sourceImage, this.sourcePoints, finalDestPoints, exportSizePx, exportSizePx);
                
                if (warpedCanvas) exportCtx.drawImage(warpedCanvas, 0, 0);

                const link = document.createElement('a');
                link.download = `gobo_${diameter}mm_${dpi}dpi.png`;
                link.href = exportCanvas.toDataURL('image/png');
                link.click();
                document.getElementById('exportModal').style.display = 'none';
            }
        }
        new GoboEditor();
    });
    </script>
</body>
</html>
