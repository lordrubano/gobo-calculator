<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Профессиональный редактор-калькулятор для гобо v1.5</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css">
    <style>
        .canvas-container {
            position: relative;
            border: 2px solid #374151;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .canvas-container canvas {
            display: block;
            cursor: crosshair;
        }
        
        .magnifier {
            position: fixed; 
            width: 120px;
            height: 120px;
            border: 2px solid #3B82F6;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5); 
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            pointer-events: none;
            z-index: 1000;
            display: none;
            overflow: hidden; 
        }
        
        .magnifier canvas {
            width: 100%; 
            height: 100%;
            border-radius: 50%; 
        }
        
        .point-marker {
            position: absolute;
            width: 16px;
            height: 16px;
            border: 2px solid white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: move;
            z-index: 100;
            font-size: 10px;
            color: white;
            text-align: center;
            line-height: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .point-marker:hover {
            transform: translate(-50%, -50%) scale(1.2);
        }
        
        .panel-header {
            background: linear-gradient(135deg, #1E40AF, #3B82F6);
            color: white;
            padding: 12px;
            border-radius: 8px 8px 0 0;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .status-ready { color: #10B981; }
        .status-working { color: #F59E0B; }
        .status-error { color: #EF4444; }
    </style></head><body class="bg-gray-900 text-white min-h-screen">
    <div class="container mx-auto px-4 py-6">
        <div class="text-center mb-8">
            <h1 class="text-3xl font-bold text-blue-400 mb-2">
                <i class="fas fa-image mr-2"></i>
                Профессиональный редактор-калькулятор для гобо
            </h1>
            <p class="text-gray-400">Версия 1.5 (финальная) - Кусочно-аффинные преобразования с двухслойным предпросмотром</p>
        </div>
        <div class="flex flex-wrap justify-center gap-4 mb-8">
            <button id="loadTemplate" class="bg-blue-600 hover:bg-blue-700 px-6 py-3 rounded-lg font-semibold transition-colors">
                <i class="fas fa-image mr-2"></i>Загрузить фото-шаблон
            </button>
            <button id="loadSource" class="bg-green-600 hover:bg-green-700 px-6 py-3 rounded-lg font-semibold transition-colors">
                <i class="fas fa-upload mr-2"></i>Загрузить изображение
            </button>
            <button id="clearPoints" class="bg-red-600 hover:bg-red-700 px-6 py-3 rounded-lg font-semibold transition-colors">
                <i class="fas fa-trash mr-2"></i>Очистить точки
            </button>
            <button id="exportBtn" class="bg-purple-600 hover:bg-purple-700 px-6 py-3 rounded-lg font-semibold transition-colors">
                <i class="fas fa-download mr-2"></i>Экспорт
            </button>
        </div>
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">
            <div class="bg-gray-800 rounded-lg overflow-hidden">
                <div class="panel-header">
                    <i class="fas fa-image-portrait"></i>
                    <span>Исходное изображение</span>
                </div>
                <div class="p-4">
                    <p class="text-sm text-gray-400 mb-4">Кликните по ключевым точкам фигуры</p>
                    <div class="canvas-container relative">
                        <canvas id="sourceCanvas" width="300" height="400"></canvas>
                        <div id="sourceMagnifier" class="magnifier">
                            <canvas width="116" height="116"></canvas>
                        </div>
                    </div>
                    <div class="mt-2 text-center">
                        <span class="text-sm">Точек источника: <span id="sourceCount" class="font-bold text-blue-400">0</span></span>
                    </div>
                </div>
            </div>
            <div class="bg-gray-800 rounded-lg overflow-hidden">
                <div class="panel-header">
                    <i class="fas fa-crosshairs"></i>
                    <span>Фото-шаблон</span>
                </div>
                <div class="p-4">
                    <p class="text-sm text-gray-400 mb-4">Кликните по размеченным точкам в том же порядке</p>
                    <div class="canvas-container relative">
                        <canvas id="templateCanvas" width="300" height="400"></canvas>
                        <div id="templateMagnifier" class="magnifier">
                            <canvas width="116" height="116"></canvas>
                        </div>
                    </div>
                    <div class="mt-2 text-center">
                        <span class="text-sm">Точек цели: <span id="targetCount" class="font-bold text-green-400">0</span></span>
                    </div>
                </div>
            </div>
            <div class="bg-gray-800 rounded-lg overflow-hidden">
                <div class="panel-header">
                    <i class="fas fa-eye"></i>
                    <span>Предпросмотр деформации</span>
                </div>
                <div class="p-4">
                    <p class="text-sm text-gray-400 mb-4">Real-time результат деформации</p>
                    <div class="canvas-container">
                        <canvas id="previewCanvas" width="300" height="400"></canvas>
                    </div>
                    <div class="mt-2 text-center">
                        <span class="text-sm">Статус: <span id="previewStatus" class="font-bold status-ready">Готово к экспорту</span></span>
                    </div>
                </div>
            </div>
        </div>
        <div class="bg-gray-800 rounded-lg p-6">
            <h3 class="text-xl font-bold text-yellow-400 mb-4">
                <i class="fas fa-info-circle mr-2"></i>
                Инструкция по использованию:
            </h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm text-gray-300">
                <div>
                    <p class="mb-2">1. Загрузите фото-шаблон с размеченными точками</p>
                    <p class="mb-2">2. Загрузите исходное изображение для деформации</p>
                    <p class="mb-2">3. Кликните по ключевым точкам на исходном изображении (минимум 4 точки)</p>
                    <p class="mb-2">4. Кликните по соответствующим точкам на фото-шаблоне в том же порядке</p>
                </div>
                <div>
                    <p class="mb-2">5. Используйте экранную лупу для точного позиционирования</p>
                    <p class="mb-2">6. Перетаскивайте точки для финальной подгонки</p>
                    <p class="mb-2">7. Наблюдайте real-time деформацию в окне предпросмотра</p>
                    <p class="mb-2">8. Нажмите "Экспорт" для создания готового файла гобо</p>
                </div>
            </div>
        </div>
    </div>
    <input type="file" id="templateInput" accept="image/*" style="display: none;">
    <input type="file" id="sourceInput" accept="image/*" style="display: none;">
    <div id="exportModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" style="display: none;">
        <div class="bg-gray-800 p-8 rounded-lg max-w-md w-full mx-4">
            <h3 class="text-xl font-bold mb-6 text-center">Параметры экспорта</h3>
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium mb-2">Физический диаметр гобо (мм):</label>
                    <input type="number" id="diameterInput" value="50" min="10" max="500" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-2">Требуемое разрешение (DPI):</label>
                    <input type="number" id="dpiInput" value="2700" min="300" max="5000" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white">
                </div>
                <div class="flex space-x-4 pt-4">
                    <button id="confirmExport" class="flex-1 bg-purple-600 hover:bg-purple-700 py-2 px-4 rounded-md font-semibold transition-colors">
                        <i class="fas fa-download mr-2"></i>Сохранить
                    </button>
                    <button id="cancelExport" class="flex-1 bg-gray-600 hover:bg-gray-700 py-2 px-4 rounded-md font-semibold transition-colors">
                        Отмена
                    </button>
                </div>
            </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/delaunator@5.0.0/delaunator.min.js"></script>
    <script>
        class GoboEditor {
            constructor() {
                this.sourcePoints = [];
                this.targetPoints = [];
                this.sourceImage = null;
                this.templateImage = null;
                this.isDragging = false;
                this.dragPoint = null;
                this.dragCanvas = null;
                this.currentDeformationData = null; 
                
                this.initCanvases();
                this.bindEvents();
            }

            initCanvases() {
                this.sourceCanvas = document.getElementById('sourceCanvas');
                this.templateCanvas = document.getElementById('templateCanvas');
                this.previewCanvas = document.getElementById('previewCanvas');
                
                this.sourceCtx = this.sourceCanvas.getContext('2d');
                this.templateCtx = this.templateCanvas.getContext('2d');
                this.previewCtx = this.previewCanvas.getContext('2d');
                
                // Инициализация лупы
                this.sourceMagnifier = document.getElementById('sourceMagnifier');
                this.templateMagnifier = document.getElementById('templateMagnifier');
                this.sourceMagCtx = this.sourceMagnifier.querySelector('canvas').getContext('2d');
                this.templateMagCtx = this.templateMagnifier.querySelector('canvas').getContext('2d');
            }

            bindEvents() {
                // Загрузка файлов
                document.getElementById('loadTemplate').addEventListener('click', () => {
                    document.getElementById('templateInput').click();
                });
                
                document.getElementById('loadSource').addEventListener('click', () => {
                    document.getElementById('sourceInput').click();
                });
                
                document.getElementById('templateInput').addEventListener('change', (e) => {
                    this.loadImage(e.target.files[0], 'template');
                });
                
                document.getElementById('sourceInput').addEventListener('change', (e) => {
                    this.loadImage(e.target.files[0], 'source');
                });

                // Очистка точек
                document.getElementById('clearPoints').addEventListener('click', () => {
                    this.clearAllPoints();
                });

                // Экспорт
                document.getElementById('exportBtn').addEventListener('click', () => {
                    document.getElementById('exportModal').style.display = 'flex';
                });
                
                document.getElementById('confirmExport').addEventListener('click', () => {
                    this.exportGobo();
                });
                
                document.getElementById('cancelExport').addEventListener('click', () => {
                    document.getElementById('exportModal').style.display = 'none';
                });

                // События Canvas
                this.bindCanvasEvents(this.sourceCanvas, 'source');
                this.bindCanvasEvents(this.templateCanvas, 'template');
            }

            bindCanvasEvents(canvas, type) {
                const magnifier = type === 'source' ? this.sourceMagnifier : this.templateMagnifier;
                
                canvas.addEventListener('mousemove', (e) => {
                    // УЛУЧШЕНИЕ ЛУПЫ: Позиционирование
                    magnifier.style.left = (e.clientX + 10) + 'px'; 
                    magnifier.style.top = (e.clientY - 70) + 'px';  
                    magnifier.style.display = 'block';
                    
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Обновляем отрисовку лупы
                    this.updateMagnifier(x, y, canvas, type);
                    
                    // Обработка перетаскивания
                    if (this.isDragging && this.dragCanvas === canvas) {
                        const points = type === 'source' ? this.sourcePoints : this.targetPoints;
                        if (this.dragPoint < points.length) {
                            points[this.dragPoint] = {x, y};
                            if (type === 'source') {
                                this.drawSourceImage();
                            } else {
                                this.drawTemplateImage();
                            }
                            this.updatePreview();
                            this.updateCounts();
                        }
                    }
                });
                
                canvas.addEventListener('mouseenter', () => {
                    magnifier.style.display = 'block';
                });
                
                canvas.addEventListener('mouseleave', () => {
                    magnifier.style.display = 'none';
                });
                
                canvas.addEventListener('mousedown', (e) => {
                    this.handleMouseDown(e, canvas, type);
                });
                
                canvas.addEventListener('mouseup', (e) => {
                    // Исправление: Обновляем предпросмотр после отпускания точки
                    if (this.isDragging) {
                        this.isDragging = false; // Сбрасываем флаг isDragging
                        this.dragPoint = null;
                        this.dragCanvas = null;
                        canvas.style.cursor = 'crosshair';
                        this.updatePreview(); 
                    }
                });
                
                canvas.addEventListener('click', (e) => {
                    // УДАЛЕНО: if (!this.isDragging)
                    // Теперь клик всегда срабатывает, если не было активного перетаскивания (mouseDown, потом перемещение, потом mouseUp)
                    // Если это был просто клик (mouseDown -> mouseUp без перемещения), то this.isDragging будет false, и точка добавится.
                    // Если это было перетаскивание, то this.isDragging будет true, но click не сработает после перетаскивания
                    // (так как click событие не генерируется, если mousemove произошел между mousedown и mouseup).
                    // Это стандартное поведение браузера для событий.
                    this.handleCanvasClick(e, canvas, type);
                });
            }

            loadImage(file, type) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        if (type === 'source') {
                            this.sourceImage = img;
                            this.drawSourceImage();
                        } else {
                            this.templateImage = img;
                            this.drawTemplateImage();
                        }
                        this.updatePreview();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            drawSourceImage() {
                if (!this.sourceImage) return;
                
                this.sourceCtx.clearRect(0, 0, this.sourceCanvas.width, this.sourceCanvas.height);
                
                // Масштабирование с сохранением пропорций
                const scale = Math.min(
                    this.sourceCanvas.width / this.sourceImage.width,
                    this.sourceCanvas.height / this.sourceImage.height
                );
                
                const width = this.sourceImage.width * scale;
                const height = this.sourceImage.height * scale;
                const x = (this.sourceCanvas.width - width) / 2;
                const y = (this.sourceCanvas.height - height) / 2;
                
                this.sourceCtx.drawImage(this.sourceImage, x, y, width, height);
                this.drawPoints('source');
            }

            drawTemplateImage() {
                if (!this.templateImage) return;
                
                this.templateCtx.clearRect(0, 0, this.templateCanvas.width, this.templateCanvas.height);
                
                // Масштабирование с сохранением пропорций
                const scale = Math.min(
                    this.templateCanvas.width / this.templateImage.width,
                    this.templateCanvas.height / this.templateImage.height
                );
                
                const width = this.templateImage.width * scale;
                const height = this.templateImage.height * scale;
                const x = (this.templateCanvas.width - width) / 2;
                const y = (this.templateCanvas.height - height) / 2;
                
                this.templateCtx.drawImage(this.templateImage, x, y, width, height);
                this.drawPoints('template');
            }

            drawPoints(type) {
                const canvas = type === 'source' ? this.sourceCanvas : this.templateCanvas;
                const ctx = type === 'source' ? this.sourceCtx : this.templateCtx;
                const points = type === 'source' ? this.sourcePoints : this.targetPoints;
                
                // Перерисовываем изображение, чтобы убрать старые точки перед рисованием новых
                if (type === 'source') {
                    this.drawSourceImage(); // Перерисовываем исходник
                } else {
                    this.drawTemplateImage(); // Перерисовываем шаблон
                }
                
                points.forEach((point, index) => {
                    // Рисуем точку
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 8, 0, 2 * Math.PI);
                    ctx.fillStyle = index === 0 ? '#EF4444' : '#3B82F6'; // Красная для первой точки
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Рисуем номер
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText((index + 1).toString(), point.x, point.y);
                });
                
                // Соединяем точки линиями
                if (points.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    for (let i = 1; i < points.length; i++) {
                        ctx.lineTo(points[i].x, points[i].y);
                    }
                    if (points.length > 2) {
                        ctx.closePath();
                    }
                    ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            updateMagnifier(x, y, canvas, type) {
                const magnifier = type === 'source' ? this.sourceMagnifier : this.templateMagnifier;
                const magCtx = type === 'source' ? this.sourceMagCtx : this.templateMagCtx;
                const sourceSize = 20; // Размер области источника для увеличения (40x40 пикселей)
                
                magCtx.clearRect(0, 0, 116, 116);
                
                // Копируем увеличенную область с канваса
                magCtx.drawImage(
                    canvas, 
                    x - sourceSize, // sx: Начальная x-координата для обрезки из источника
                    y - sourceSize, // sy: Начальная y-координата для обрезки из источника
                    sourceSize * 2,  // sWidth: Ширина обрезаемой области из источника
                    sourceSize * 2,  // sHeight: Высота обрезаемой области из источника
                    0, 0,           // dx, dy: Начальные x, y-координаты для отрисовки на целевом холсте
                    116, 116        // dWidth, dHeight: Ширина и высота для отрисовки на целевом холсте (масштабирование)
                );
                
                // Рисуем перекрестие
                magCtx.strokeStyle = '#EF4444';
                magCtx.lineWidth = 1;
                magCtx.beginPath();
                magCtx.moveTo(58, 20); // Вертикальная линия
                magCtx.lineTo(58, 96);
                magCtx.moveTo(20, 58); // Горизонтальная линия
                magCtx.lineTo(96, 58);
                magCtx.stroke();
            }

            handleMouseDown(e, canvas, type) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const points = type === 'source' ? this.sourcePoints : this.targetPoints;
                
                // Проверяем, есть ли точка рядом с курсором
                for (let i = 0; i < points.length; i++) {
                    const point = points[i];
                    const distance = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
                    if (distance < 15) {
                        this.isDragging = true;
                        this.dragPoint = i;
                        this.dragCanvas = canvas;
                        canvas.style.cursor = 'grabbing';
                        return;
                    }
                }
                // Важно: если mousedown не начал перетаскивание, то click должен добавить точку
                this.isDragging = false; // Сбрасываем флаг, если это был не drag-начало
            }

            // handleMouseUp уже был в оригинале и я его немного исправил выше
            // handleMouseUp(e, canvas, type) { ... }

            handleCanvasClick(e, canvas, type) {
                // !!! Важное изменение: удалено if (!this.isDragging)
                // Считаем, что событие 'click' не будет генерироваться после 'drag'
                // или что 'isDragging' будет корректно сброшен в 'mouseup'.
                // Это более стандартное поведение.
                
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const points = type === 'source' ? this.sourcePoints : this.targetPoints;
                
                // Проверяем, не кликнули ли по существующей точке (чтобы не добавлять дубликат)
                for (let point of points) {
                    const distance = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
                    if (distance < 15) {
                        return; // Не добавляем новую точку, если кликнули по существующей
                    }
                }
                
                // Добавляем новую точку
                points.push({x, y});
                
                if (type === 'source') {
                    this.drawSourceImage();
                } else {
                    this.drawTemplateImage();
                }
                
                this.updatePreview();
                this.updateCounts();
            }

            clearAllPoints() {
                this.sourcePoints = [];
                this.targetPoints = [];
                this.currentDeformationData = null;
                this.drawSourceImage();
                this.drawTemplateImage();
                this.updatePreview();
                this.updateCounts();
            }

            updateCounts() {
                document.getElementById('sourceCount').textContent = this.sourcePoints.length;
                document.getElementById('targetCount').textContent = this.targetPoints.length;
            }

            updatePreview() {
                if (!this.sourceImage || !this.templateImage || 
                    this.sourcePoints.length < 4 || this.targetPoints.length < 4 ||
                    this.sourcePoints.length !== this.targetPoints.length) {
                    
                    // Показываем только фон
                    this.previewCtx.clearRect(0, 0, this.previewCanvas.width, this.previewCanvas.height);
                    if (this.templateImage) {
                        const scale = Math.min(
                            this.previewCanvas.width / this.templateImage.width,
                            this.previewCanvas.height / this.templateImage.height
                        );
                        const width = this.templateImage.width * scale;
                        const height = this.templateImage.height * scale;
                        const x = (this.previewCanvas.width - width) / 2;
                        const y = (this.previewCanvas.height - height) / 2;
                        this.previewCtx.drawImage(this.templateImage, x, y, width, height);
                    }
                    
                    this.currentDeformationData = null;
                    document.getElementById('previewStatus').textContent = 'Расставьте точки на фото-шаблоне';
                    document.getElementById('previewStatus').className = 'font-bold status-working';
                    return;
                }

                // Применяем деформацию
                this.applyPiecewiseAffineTransform();
                document.getElementById('previewStatus').textContent = 'Готово к экспорту';
                document.getElementById('previewStatus').className = 'font-bold status-ready';
            }

            applyPiecewiseAffineTransform() {
                // Очищаем предпросмотр
                this.previewCtx.clearRect(0, 0, this.previewCanvas.width, this.previewCanvas.height);
                
                // Шаг 1: Рисуем фон (фото-шаблон)
                if (this.templateImage) {
                    const scale = Math.min(
                        this.previewCanvas.width / this.templateImage.width,
                        this.previewCanvas.height / this.templateImage.height
                    );
                    const width = this.templateImage.width * scale;
                    const height = this.templateImage.height * scale;
                    const x = (this.previewCanvas.width - width) / 2;
                    const y = (this.previewCanvas.height - height) / 2;
                    
                    this.previewCtx.globalAlpha = 0.7;
                    this.previewCtx.drawImage(this.templateImage, x, y, width, height);
                    this.previewCtx.globalAlpha = 1.0;
                }

                // Шаг 2: Создаем виртуальный холст для промежуточного рендеринга
                const virtualCanvas = document.createElement('canvas');
                virtualCanvas.width = this.previewCanvas.width;
                virtualCanvas.height = this.previewCanvas.height;
                const virtualCtx = virtualCanvas.getContext('2d');

                // Шаг 3: Применяем кусочно-аффинное преобразование
                // Здесь imageScale, imageOffsetX, imageOffsetY для отрисовки sourceImage на предпросмотре
                const sourceImageDisplayScale = Math.min(
                    this.sourceCanvas.width / this.sourceImage.width,
                    this.sourceCanvas.height / this.sourceImage.height
                );
                const sourceImageDisplayOffsetX = (this.sourceCanvas.width - this.sourceImage.width * sourceImageDisplayScale) / 2;
                const sourceImageDisplayOffsetY = (this.sourceCanvas.height - this.sourceImage.height * sourceImageDisplayScale) / 2;

                this.renderPiecewiseAffine(virtualCtx, this.sourcePoints, this.targetPoints, this.sourceImage, 
                                          sourceImageDisplayScale, sourceImageDisplayOffsetX, sourceImageDisplayOffsetY, 
                                          this.previewCanvas.width, this.previewCanvas.height);

                // Сохраняем данные деформации для экспорта
                this.currentDeformationData = {
                    sourcePoints: [...this.sourcePoints],
                    targetPoints: [...this.targetPoints],
                    sourceImage: this.sourceImage,
                    // Сохраняем параметры отображения sourceImage на sourceCanvas
                    sourceCanvasDisplayScale: sourceImageDisplayScale,
                    sourceCanvasDisplayOffsetX: sourceImageDisplayOffsetX,
                    sourceCanvasDisplayOffsetY: sourceImageDisplayOffsetY,
                    // Сохраняем размеры холста предпросмотра
                    previewCanvasWidth: this.previewCanvas.width,
                    previewCanvasHeight: this.previewCanvas.height
                };

                // Шаг 4: Накладываем результат на предпросмотр
                this.previewCtx.drawImage(virtualCanvas, 0, 0);
            }

            // Добавляем параметры imageScale, imageOffsetX, imageOffsetY, targetCanvasWidth, targetCanvasHeight
            renderPiecewiseAffine(ctx, srcPts, dstPts, sourceImage, imageScale, imageOffsetX, imageOffsetY, targetCanvasWidth, targetCanvasHeight) {
                // Получаем треугольуляцию
                // Важно: для Delaunator нужны координаты, СМЕЩЕННЫЕ к началу изображения
                // (если изображение было центрировано на канвасе)
                const delaunayInputPoints = srcPts.map(p => ({
                    x: (p.x - imageOffsetX) / imageScale,
                    y: (p.y - imageOffsetY) / imageScale
                }));

                const triangles = this.getDelaunayTriangulation(delaunayInputPoints);
                
                // Для каждого треугольника применяем аффинное преобразование
                triangles.forEach(triangleIndices => {
                    const [i, j, k] = triangleIndices;
                    
                    // Исходный треугольник (в координатах исходного ИЗОБРАЖЕНИЯ)
                    const srcTriangleOriginal = [
                        delaunayInputPoints[i],
                        delaunayInputPoints[j],
                        delaunayInputPoints[k]
                    ];
                    
                    // Целевой треугольник (в координатах целевого канваса)
                    const dstTriangleTarget = [
                        dstPts[i],
                        dstPts[j],
                        dstPts[k]
                    ];
                    
                    this.warpTriangle(ctx, srcTriangleOriginal, dstTriangleTarget, sourceImage, imageScale, imageOffsetX, imageOffsetY, targetCanvasWidth, targetCanvasHeight);
                });
            }

            // ИСПРАВЛЕНИЕ: Интеграция Delaunator для плавной триангуляции
            getDelaunayTriangulation(points) {
                if (points.length < 3) return [];

                // Delaunator требует плоский массив координат [x1, y1, x2, y2, ...]
                const flatPoints = points.flatMap(p => [p.x, p.y]);
                try {
                    const delaunay = Delaunator.from(flatPoints);
                    const triangles = [];
                    for (let i = 0; i < delaunay.triangles.length; i += 3) {
                        triangles.push([
                            delaunay.triangles[i],
                            delaunay.triangles[i + 1],
                            delaunay.triangles[i + 2]
                        ]);
                    }
                    return triangles;
                } catch (e) {
                    console.error("Ошибка при триангуляции Делоне:", e);
                    // Возвращаем пустой массив или какую-то простую триангуляцию в случае ошибки
                    // (например, веер от первой точки, если Delaunator не может построить сетку)
                    if (points.length >= 3) {
                        const simpleTriangles = [];
                        for (let i = 1; i < points.length - 1; i++) {
                            simpleTriangles.push([0, i, i + 1]);
                        }
                        return simpleTriangles;
                    }
                    return [];
                }
            }

            // Добавляем параметры imageScale, imageOffsetX, imageOffsetY, targetCanvasWidth, targetCanvasHeight
            warpTriangle(ctx, srcTriangle, dstTriangle, sourceImage, imageScale, imageOffsetX, imageOffsetY, targetCanvasWidth, targetCanvasHeight) {
                // Вычисляем аффинную матрицу преобразования: из srcTriangle (в родных координатах изображения) в dstTriangle (в координатах целевого канваса)
                const matrix = this.getAffineMatrix(srcTriangle, dstTriangle);
                
                if (!matrix) return;

                ctx.save();
                // Применяем матрицу преобразования к контексту
                ctx.setTransform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
                
                // Рисуем исходное изображение
                // Поскольку setTransform уже выполнил деформацию и масштабирование,
                // drawImage просто рисует исходное изображение в его "родных" координатах
                // а затем эта трансформация применяется к нему.
                // ctx.drawImage(sourceImage, 0, 0); // это если srcTriangle был (0,0) (1,0) (0,1) и т.д.
                // В нашем случае, srcTriangle содержит реальные координаты внутри sourceImage.
                // Чтобы правильно наложить текстуру, нужно инвертировать преобразование матрицы
                // или найти другую формулу.

                // На самом деле, если setTransform преобразует srcTriangle в dstTriangle,
                // то для того, чтобы нарисовать *содержимое* srcTriangle на месте dstTriangle,
                // нужно нарисовать *все* sourceImage, а clip() обрезает ненужное.
                // Но sourceImage должно быть нарисовано так, как оно исходно выглядит.
                // setTransform уже "исказило" координатную систему контекста.
                // Поэтому мы должны рисовать sourceImage так, как будто оно было исходным в (0,0)
                // а затем накладывать его на деформированную сетку.
                // Это сложная часть. Правильно будет так:
                
                ctx.beginPath();
                ctx.moveTo(srcTriangle[0].x, srcTriangle[0].y);
                ctx.lineTo(srcTriangle[1].x, srcTriangle[1].y);
                ctx.lineTo(srcTriangle[2].x, srcTriangle[2].y);
                ctx.closePath();
                ctx.clip(); // Обрезаем все последующие рисунки по этой области, но в ТРАНСФОРМИРОВАННЫХ координатах

                if (sourceImage) {
                    // Теперь рисуем исходное изображение. Его нужно рисовать БЕЗ смещения и масштаба,
                    // поскольку эти параметры уже учтены в матрице setTransform.
                    // НО! setTransform работает с текущей системой координат.
                    // А наш sourceImage был нарисован с imageOffsetX, imageOffsetY на canvas.
                    // Нужно сначала "вернуть" координатную систему в состояние, где 0,0 - это (0,0)
                    // оригинального (не масштабированного) sourceImage,
                    // а потом нарисовать image.
                    
                    // Правильный подход: setTransform() делает так, чтобы (srcX, srcY) из исходника
                    // отображались на (dstX, dstY) на целевом канвасе.
                    // Значит, мы просто рисуем sourceImage в его оригинальных размерах,
                    // и текущая трансформация контекста позаботится о его деформации.
                    ctx.drawImage(sourceImage, 0, 0, sourceImage.width, sourceImage.height);
                }
                
                ctx.restore();
            }

            getAffineMatrix(src, dst) {
                try {
                    // Решаем систему уравнений для аффинного преобразования
                    const x1 = src[0].x, y1 = src[0].y;
                    const x2 = src[1].x, y2 = src[1].y;
                    const x3 = src[2].x, y3 = src[2].y;
                    
                    const u1 = dst[0].x, v1 = dst[0].y;
                    const u2 = dst[1].x, v2 = dst[1].y;
                    const u3 = dst[2].x, v3 = dst[2].y;
                    
                    const det = (x1 - x3) * (y2 - y3) - (x2 - x3) * (y1 - y3);
                    
                    if (Math.abs(det) < 1e-10) return null;
                    
                    const a = ((u1 - u3) * (y2 - y3) - (u2 - u3) * (y1 - y3)) / det;
                    const b = ((x1 - x3) * (u2 - u3) - (x2 - x3) * (u1 - u3)) / det;
                    const c = ((v1 - v3) * (y2 - y3) - (v2 - v3) * (y1 - y3)) / det;
                    const d = ((x1 - x3) * (v2 - v3) - (x2 - x3) * (v1 - v3)) / det;
                    const e = u3 - a * x3 - b * y3;
                    const f = v3 - c * x3 - d * y3;
                    
                    return [a, c, b, d, e, f];
                } catch (error) {
                    return null;
                }
            }

            exportGobo() {
                const diameter = parseFloat(document.getElementById('diameterInput').value);
                const dpi = parseFloat(document.getElementById('dpiInput').value);
                
                if (!diameter || !dpi || diameter <= 0 || dpi <= 0) {
                    alert('Пожалуйста, введите корректные значения для диаметра и DPI');
                    return;
                }

                if (!this.currentDeformationData) {
                    alert('Нет данных деформации для экспорта. Расставьте точки и убедитесь, что предпросмотр работает.');
                    return;
                }
                
                // Рассчитываем размер экспортного холста
                const sizeInInches = diameter / 25.4; // мм в дюймы
                const canvasSize = Math.round(sizeInInches * dpi);
                
                // Создаем экспортный холст
                const exportCanvas = document.createElement('canvas');
                exportCanvas.width = canvasSize;
                exportCanvas.height = canvasSize;
                const exportCtx = exportCanvas.getContext('2d');
                
                // Рисуем черную круглую маску
                exportCtx.fillStyle = 'black';
                exportCtx.fillRect(0, 0, canvasSize, canvasSize);
                
                // Получаем сохраненные данные деформации
                const sourcePointsPreview = this.currentDeformationData.sourcePoints;
                const targetPointsPreview = this.currentDeformationData.targetPoints;
                const sourceImageForExport = this.currentDeformationData.sourceImage;
                const previewCanvasWidth = this.currentDeformationData.previewCanvasWidth;
                const previewCanvasHeight = this.currentDeformationData.previewCanvasHeight;
                const sourceCanvasDisplayScale = this.currentDeformationData.sourceCanvasDisplayScale;
                const sourceCanvasDisplayOffsetX = this.currentDeformationData.sourceCanvasDisplayOffsetX;
                const sourceCanvasDisplayOffsetY = this.currentDeformationData.sourceCanvasDisplayOffsetY;

                // Масштабируем точки исходника (sourcePointsPreview) из координат sourceCanvas в "родные" координаты sourceImage
                const unscaledSourcePoints = sourcePointsPreview.map(p => ({
                    x: (p.x - sourceCanvasDisplayOffsetX) / sourceCanvasDisplayScale,
                    y: (p.y - sourceCanvasDisplayOffsetY) / sourceCanvasDisplayScale
                }));

                // Масштабируем точки цели (targetPointsPreview) из координат previewCanvas в координаты exportCanvas
                const targetScaleX = canvasSize / previewCanvasWidth;
                const targetScaleY = canvasSize / previewCanvasHeight;
                const scaledTargetPoints = targetPointsPreview.map(p => ({
                    x: p.x * targetScaleX,
                    y: p.y * targetScaleY
                }));
                
                // Вычисляем масштаб, с которым sourceImage будет отображаться на exportCanvas
                // Для экспорта, sourceImage будет деформировано на exportCanvas.
                // Координаты Delaunay и warpTriangle должны быть в "родных" координатах sourceImage.
                // Поэтому imageScale, imageOffsetX, imageOffsetY для warpTriangle будут 1, 0, 0.
                // Вся магия масштабирования targetPoints и transform'а уже делает нужное.
                const exportImageScale = 1; // sourceImageForExport будет рисоваться в родном размере
                const exportImageOffsetX = 0;
                const exportImageOffsetY = 0;


                // Применяем деформацию, используя unscaledSourcePoints (координаты оригинала)
                // и scaledTargetPoints (координаты экспорта),
                // а также параметры масштабирования для sourceImage на exportCanvas
                this.renderPiecewiseAffine(exportCtx, unscaledSourcePoints, scaledTargetPoints, sourceImageForExport, 
                                          exportImageScale, exportImageOffsetX, exportImageOffsetY, 
                                          canvasSize, canvasSize);
                
                // Обрезаем по кругу
                exportCtx.globalCompositeOperation = 'destination-in';
                exportCtx.beginPath();
                exportCtx.arc(canvasSize / 2, canvasSize / 2, canvasSize / 2, 0, Math.PI * 2);
                exportCtx.fill();
                exportCtx.globalCompositeOperation = 'source-over';
                
                // Скачиваем файл
                exportCanvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `gobo_${diameter}mm_${dpi}dpi.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    document.getElementById('exportModal').style.display = 'none';
                }, 'image/png');
            }
        }

        // Инициализация приложения
        document.addEventListener('DOMContentLoaded', () => {
            new GoboEditor();
        });
    </script></body></html>
