<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Профессиональный редактор-калькулятор для гобо v1.9 (финальная)</title>
    <script src="https://d3js.org/d3-delaunay.v7.min.js"></script>
    <style>
        :root {
            --bg-color: #1e1e2f; --panel-bg: #27293d; --primary-color: #8a78ff;
            --text-color: #f0f0f0; --border-color: #44475a; --success-color: #50fa7b;
            --danger-color: #ff5555; --warning-color: #f1fa8c;
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }
        body { font-family: var(--font-family); background-color: var(--bg-color); color: var(--text-color); margin: 0; padding: 20px; font-size: 14px; }
        .app-container { max-width: 1400px; margin: auto; }
        header { text-align: center; margin-bottom: 20px; }
        header h1 { margin: 0; font-size: 24px; }
        header p { margin: 5px 0; color: #9a9a9a; }
        .control-panel { display: flex; justify-content: center; gap: 15px; margin-bottom: 20px; }
        .control-panel button { background-color: var(--primary-color); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold; transition: background-color 0.2s; }
        .control-panel button.danger { background-color: var(--danger-color); }
        .control-panel button:hover { opacity: 0.9; }
        .control-panel button:disabled { background-color: #666; cursor: not-allowed; opacity: 0.7; }
        .main-content { display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px; margin-bottom: 20px; }
        .canvas-panel { background-color: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 8px; padding: 15px; display: flex; flex-direction: column; align-items: center; }
        .canvas-panel h2 { margin-top: 0; text-align: center; font-size: 16px; }
        .canvas-container { position: relative; width: 100%; padding-top: 75%; background-color: #111; border-radius: 4px; overflow: hidden; }
        .canvas-container canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; cursor: crosshair; }
        .panel-footer { width: 100%; padding-top: 10px; text-align: center; color: #9a9a9a; height: 20px; }
        .panel-footer .status.ready { color: var(--success-color); font-weight: bold; }
        .panel-footer .status.mismatch { color: var(--warning-color); font-weight: bold; }
        .instructions { background-color: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 8px; padding: 20px; }
        .instructions h3 { margin-top: 0; }
        .instructions ol { padding-left: 20px; }
        .loupe { position: absolute; width: 100px; height: 100px; border-radius: 50%; border: 2px solid var(--primary-color); pointer-events: none; display: none; background-repeat: no-repeat; box-shadow: 0 5px 15px rgba(0,0,0,0.5); z-index: 100; }
        .loupe::before, .loupe::after { content: ''; position: absolute; background-color: var(--danger-color); z-index: 101; }
        .loupe::before { top: 50%; left: 0; width: 100%; height: 1px; margin-top: -0.5px; }
        .loupe::after { left: 50%; top: 0; height: 100%; width: 1px; margin-left: -0.5px; }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); display: none; justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background-color: var(--panel-bg); padding: 30px; border-radius: 8px; width: 300px; text-align: center; }
        .modal-content h2 { margin-top: 0; }
        .modal-content .form-group { margin-bottom: 20px; text-align: left; }
        .modal-content label { display: block; margin-bottom: 5px; }
        .modal-content input { width: 100%; padding: 8px; border-radius: 4px; border: 1px solid var(--border-color); background-color: var(--bg-color); color: var(--text-color); box-sizing: border-box; }
        .modal-buttons { display: flex; justify-content: space-between; }
        .file-input { display: none; }
    </style>
</head>
<body>
    <div class="app-container">
        <header>
            <h1>Профессиональный редактор-калькулятор для гобо</h1>
            <p>Версия 1.9 (финальная)</p>
        </header>
        <div class="control-panel">
            <button id="load-template-btn">Загрузить фото-шаблон</button>
            <button id="load-source-btn">Загрузить изображение</button>
            <button id="clear-points-btn" class="danger">Очистить точки</button>
            <button id="export-btn" disabled>Экспорт</button>
        </div>
        <input type="file" id="template-file-input" class="file-input" accept="image/*">
        <input type="file" id="source-file-input" class="file-input" accept="image/*">
        <div class="main-content">
            <div class="canvas-panel" id="source-panel"></div>
            <div class="canvas-panel" id="template-panel"></div>
            <div class="canvas-panel" id="preview-panel"></div>
        </div>
        <div class="instructions"></div>
    </div>
    <div class="loupe" id="loupe"></div>
    <div class="modal-overlay" id="export-modal"></div>
    
    <script>
        // Финальная стабильная версия v1.9
        // Ключевое исправление: работа напрямую с объектом Image, а не с холстом-источником,
        // чтобы обойти ограничения безопасности браузера (Tainted Canvas).
        // Это решает проблему пустой деформации.

        document.addEventListener('DOMContentLoaded', () => {
            // --- Состояние приложения ---
            let sourceImage = null;
            let templateImage = null;
            let sourcePoints = [];
            let destinationPoints = [];
            let draggingPointInfo = null;
            let sourceRenderInfo = {}; // { ox, oy, dw, dh }

            // --- DOM элементы ---
            const sourcePanel = document.getElementById('source-panel');
            const templatePanel = document.getElementById('template-panel');
            const previewPanel = document.getElementById('preview-panel');
            
            // --- Динамическое создание элементов ---
            const createPanel = (parent, id, title) => {
                parent.innerHTML = `
                    <h2>${title}</h2>
                    <div class="canvas-container">
                        <canvas id="${id}-canvas"></canvas>
                    </div>
                    <div class="panel-footer">${id === 'source' || id === 'template' ? `Точек ${id === 'source' ? 'источника' : 'цели'}: ` : 'Статус: '}<span id="${id}-points-count">${id === 'preview' ? 'Ожидание изображений' : '0'}</span></div>
                `;
                return parent.querySelector('canvas');
            };

            const sourceCanvas = createPanel(sourcePanel, 'source', 'Исходное изображение');
            const templateCanvas = createPanel(templatePanel, 'template', 'Фото-шаблон');
            const previewCanvas = createPanel(previewPanel, 'preview', 'Предпросмотр деформации');
            
            const sourceCtx = sourceCanvas.getContext('2d');
            const templateCtx = templateCanvas.getContext('2d');
            const previewCtx = previewCanvas.getContext('2d');
            
            const loupe = document.getElementById('loupe');
            const exportBtn = document.getElementById('export-btn');
            const exportModal = document.getElementById('export-modal');
            const instructionsPanel = document.getElementById('instructions');

            // --- Инициализация ---
            const init = () => {
                instructionsPanel.innerHTML = `
                    <h3>Инструкция по использованию:</h3>
                    <ol>
                        <li>Загрузите фото-шаблон с размеченными точками.</li>
                        <li>Загрузите исходное изображение для деформации.</li>
                        <li>Кликните по ключевым точкам на исходном изображении (минимум 4 точки).</li>
                        <li>Кликните по соответствующим точкам на фото-шаблоне в том же порядке.</li>
                        <li>Используйте экранную лупу для точного позиционирования.</li>
                        <li>Перетаскивайте точки для финальной подгонки.</li>
                        <li>Наблюдайте real-time деформацию в окне предпросмотра.</li>
                        <li>Нажмите "Экспорт" для создания готового файла гобо.</li>
                    </ol>`;
                
                exportModal.innerHTML = `
                    <div class="modal-content">
                        <h2>Параметры экспорта</h2>
                        <div class="form-group">
                            <label for="gobo-diameter">Диаметр гобо (мм)</label>
                            <input type="number" id="gobo-diameter" value="37.5" step="0.1">
                        </div>
                        <div class="form-group">
                            <label for="gobo-dpi">Разрешение (DPI)</label>
                            <input type="number" id="gobo-dpi" value="2700" step="100">
                        </div>
                        <div class="modal-buttons">
                            <button id="cancel-export-btn" class="danger">Отмена</button>
                            <button id="confirm-export-btn">Сохранить файл</button>
                        </div>
                    </div>`;

                setupCanvas(sourceCanvas, handleSourceCanvasEvent);
                setupCanvas(templateCanvas, handleTemplateCanvasEvent);

                document.getElementById('load-template-btn').addEventListener('click', () => document.getElementById('template-file-input').click());
                document.getElementById('load-source-btn').addEventListener('click', () => document.getElementById('source-file-input').click());
                document.getElementById('template-file-input').addEventListener('change', (e) => loadImage(e, true));
                document.getElementById('source-file-input').addEventListener('change', (e) => loadImage(e, false));
                document.getElementById('clear-points-btn').addEventListener('click', clearPoints);
                exportBtn.addEventListener('click', () => exportModal.style.display = 'flex');
                document.getElementById('cancel-export-btn').addEventListener('click', () => exportModal.style.display = 'none');
                document.getElementById('confirm-export-btn').addEventListener('click', handleExport);
            };

            const setupCanvas = (canvas, eventHandler) => {
                const resize = () => {
                    const container = canvas.parentElement;
                    canvas.width = container.clientWidth;
                    canvas.height = container.clientHeight;
                    renderAll();
                };
                window.addEventListener('resize', resize);
                resize();
                canvas.addEventListener('mousedown', (e) => eventHandler(e, 'down'));
                canvas.addEventListener('mousemove', (e) => eventHandler(e, 'move'));
                canvas.addEventListener('mouseup', () => eventHandler(null, 'up'));
                canvas.addEventListener('mouseleave', () => eventHandler(null, 'leave'));
                canvas.addEventListener('mouseenter', (e) => eventHandler(e, 'enter'));
            };

            const loadImage = (e, isTemplate) => {
                const file = e.target.files[0]; if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        if (isTemplate) templateImage = img; else sourceImage = img;
                        renderAll();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
                e.target.value = '';
            };

            // --- Логика точек ---
            const handleSourceCanvasEvent = (e, type) => handleCanvasEvent(e, type, sourceCanvas, sourcePoints, sourceImage);
            const handleTemplateCanvasEvent = (e, type) => handleCanvasEvent(e, type, templateCanvas, destinationPoints, templateImage);

            const handleCanvasEvent = (e, type, canvas, points, image) => {
                const getCoords = (event) => {
                    if (!event) return null;
                    const rect = canvas.getBoundingClientRect();
                    return { x: event.clientX - rect.left, y: event.clientY - rect.top };
                };
                const coords = getCoords(e);
                switch (type) {
                    case 'enter': if(image) loupe.style.display = 'block'; break;
                    case 'leave': loupe.style.display = 'none'; draggingPointInfo = null; break;
                    case 'move':
                        if (coords && image) updateLoupe(e, canvas);
                        if (draggingPointInfo && draggingPointInfo.array === points) {
                            draggingPointInfo.point[0] = coords.x;
                            draggingPointInfo.point[1] = coords.y;
                            renderAll();
                        }
                        break;
                    case 'down':
                        if (!image) return;
                        const pointIndex = getPointAt(coords, points);
                        if (pointIndex !== -1) {
                            draggingPointInfo = { point: points[pointIndex], index: pointIndex, array: points };
                        } else {
                            if (canvas === sourceCanvas) points.push([coords.x, coords.y]);
                            else if (canvas === templateCanvas && points.length < sourcePoints.length) points.push([coords.x, coords.y]);
                            renderAll();
                        }
                        break;
                    case 'up': draggingPointInfo = null; break;
                }
            };
            
            const getPointAt = (coords, points) => {
                for(let i=0; i<points.length; i++){
                    if(Math.sqrt((points[i][0]-coords.x)**2 + (points[i][1]-coords.y)**2) < 10) return i;
                }
                return -1;
            };

            const clearPoints = () => { sourcePoints.length = 0; destinationPoints.length = 0; renderAll(); };
            
            // --- Логика отрисовки ---
            const renderAll = () => {
                sourceRenderInfo = drawCanvasWithAspectRatio(sourceCtx, sourceCanvas, sourceImage, sourcePoints);
                drawCanvasWithAspectRatio(templateCtx, templateCanvas, templateImage, destinationPoints);
                updatePreview();
                updateStatus();
            };

            const drawCanvasWithAspectRatio = (ctx, canvas, img, points) => {
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                const renderInfo = { ox: 0, oy: 0, dw: 0, dh: 0 };
                if (img) {
                    const canvasRatio = canvas.width / canvas.height;
                    const imgRatio = img.naturalWidth / img.naturalHeight;
                    renderInfo.dw = canvas.width; renderInfo.dh = canvas.height;
                    if (imgRatio > canvasRatio) { renderInfo.dh = canvas.width / imgRatio; renderInfo.oy = (canvas.height - renderInfo.dh) / 2; } 
                    else { renderInfo.dw = canvas.height * imgRatio; renderInfo.ox = (canvas.width - renderInfo.dw) / 2; }
                    ctx.drawImage(img, renderInfo.ox, renderInfo.oy, renderInfo.dw, renderInfo.dh);
                }
                points.forEach((p, i) => drawPoint(ctx, p, i + 1));
                return renderInfo;
            };

            const drawPoint = (ctx, p, number) => {
                ctx.beginPath(); ctx.arc(p[0], p[1], 5, 0, 2*Math.PI);
                ctx.fillStyle = 'rgba(138, 120, 255, 0.9)'; ctx.fill();
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.stroke();
                ctx.fillStyle = '#fff'; ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(number, p[0], p[1]);
            };
            
            const updateLoupe = (e, canvas) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX-rect.left, y = e.clientY-rect.top;
                const zoom = 4;
                loupe.style.left = `${e.pageX-50}px`; loupe.style.top = `${e.pageY-50}px`;
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width=canvas.width; tempCanvas.height=canvas.height;
                canvas.getContext('2d').constructor.prototype.drawImage.call(tempCanvas.getContext('2d'),canvas,0,0);
                loupe.style.backgroundImage = `url(${tempCanvas.toDataURL()})`;
                loupe.style.backgroundSize = `${canvas.width*zoom}px ${canvas.height*zoom}px`;
                loupe.style.backgroundPosition = `-${x*zoom-50}px -${y*zoom-50}px`;
            };

            const updateStatus = () => {
                document.getElementById('source-points-count').textContent = sourcePoints.length;
                document.getElementById('dest-points-count').textContent = destinationPoints.length;
                const statusSpan = document.getElementById('preview-points-count');
                const canWarp = sourcePoints.length >= 4 && sourcePoints.length === destinationPoints.length;
                if (canWarp) { statusSpan.textContent = 'Готово к экспорту'; statusSpan.className = 'status ready'; exportBtn.disabled = false; } 
                else if (sourcePoints.length !== destinationPoints.length) { statusSpan.textContent = `Синхронизация (${sourcePoints.length}/${destinationPoints.length})`; statusSpan.className = 'status mismatch'; exportBtn.disabled = true; }
                else { statusSpan.textContent = 'Расставьте точки'; statusSpan.className = 'status'; exportBtn.disabled = true; }
            };
            
            // --- Логика деформации ---
            const updatePreview = () => {
                previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                if (templateImage) previewCtx.drawImage(templateImage, 0, 0, previewCanvas.width, previewCanvas.height);
                if (!sourceImage || sourcePoints.length < 4 || sourcePoints.length !== destinationPoints.length) return;
                
                const warpedCanvas = getWarpedCanvas(sourceImage, sourcePoints, destinationPoints, templateCanvas.width, templateCanvas.height);
                if(warpedCanvas) previewCtx.drawImage(warpedCanvas, 0, 0);
            };

            const getWarpedCanvas = (img, srcPts, destPts, width, height) => {
                const warpedCanvas = document.createElement('canvas');
                warpedCanvas.width = width; warpedCanvas.height = height;
                const warpedCtx = warpedCanvas.getContext('2d');
                
                // Преобразуем точки с холста источника в абс. координаты на изображении
                const absSrcPts = srcPts.map(p => [
                    (p[0] - sourceRenderInfo.ox) / sourceRenderInfo.dw * img.naturalWidth,
                    (p[1] - sourceRenderInfo.oy) / sourceRenderInfo.dh * img.naturalHeight
                ]);

                try {
                    const delaunay = d3.Delaunay.from(absSrcPts);
                    const triangles = delaunay.triangles;

                    for (let i = 0; i < triangles.length; i += 3) {
                        const p_src_abs = [ absSrcPts[triangles[i]], absSrcPts[triangles[i+1]], absSrcPts[triangles[i+2]] ];
                        const p_dest = [ destPts[triangles[i]], destPts[triangles[i+1]], destPts[triangles[i+2]] ];
                        
                        const triArea = (p0, p1, p2) => 0.5 * Math.abs(p0[0]*(p1[1]-p2[1]) + p1[0]*(p2[1]-p0[1]) + p2[0]*(p0[1]-p1[1]));
                        if (triArea(p_src_abs[0], p_src_abs[1], p_src_abs[2]) < 0.1) continue;

                        warpedCtx.save();
                        warpedCtx.beginPath();
                        warpedCtx.moveTo(p_dest[0][0], p_dest[0][1]);
                        warpedCtx.lineTo(p_dest[1][0], p_dest[1][1]);
                        warpedCtx.lineTo(p_dest[2][0], p_dest[2][1]);
                        warpedCtx.closePath();
                        warpedCtx.clip();

                        const transform = getAffineTransform(p_src_abs, p_dest);
                        warpedCtx.setTransform(transform.a, transform.b, transform.c, transform.d, transform.e, transform.f);
                        warpedCtx.drawImage(img, 0, 0); // Рисуем из оригинального Image, а не с холста
                        warpedCtx.restore();
                    }
                    return warpedCanvas;
                } catch(e) { console.error("Warping failed:", e); return null; }
            };

            const getAffineTransform = (src, dst) => {
                const [p1, p2, p3] = src, [q1, q2, q3] = dst;
                const M = [ [p1[0],p1[1],1,0,0,0], [0,0,0,p1[0],p1[1],1], [p2[0],p2[1],1,0,0,0], [0,0,0,p2[0],p2[1],1], [p3[0],p3[1],1,0,0,0], [0,0,0,p3[0],p3[1],1] ];
                const b = [q1[0],q1[1],q2[0],q2[1],q3[0],q3[1]];
                const t = solve(M, b);
                if (!t) return {a:1,b:0,c:0,d:1,e:0,f:0};
                return {a:t[0],c:t[1],e:t[2],b:t[3],d:t[4],f:t[5]};
            };

            // --- Экспорт ---
            const handleExport = () => {
                const diameter = parseFloat(document.getElementById('gobo-diameter').value);
                const dpi = parseInt(document.getElementById('gobo-dpi').value);
                if (isNaN(diameter) || isNaN(dpi) || diameter <= 0 || dpi <= 0) { alert('Введите корректные значения.'); return; }
                
                const exportSizePx = Math.round((diameter / 25.4) * dpi);
                const exportCanvas = document.createElement('canvas');
                exportCanvas.width = exportSizePx; exportCanvas.height = exportSizePx;
                const exportCtx = exportCanvas.getContext('2d');
                
                exportCtx.fillStyle = 'black';
                exportCtx.beginPath();
                exportCtx.arc(exportSizePx / 2, exportSizePx / 2, exportSizePx / 2, 0, 2 * Math.PI);
                exportCtx.fill();

                const warpedCanvas = getWarpedCanvas(sourceImage, sourcePoints, destinationPoints.map(p => [
                    (p[0] / templateCanvas.width) * exportSizePx,
                    (p[1] / templateCanvas.height) * exportSizePx
                ]), exportSizePx, exportSizePx);
                
                if (warpedCanvas) exportCtx.drawImage(warpedCanvas, 0, 0);

                const link = document.createElement('a');
                link.download = `gobo_export_${diameter}mm_${dpi}dpi.png`;
                link.href = exportCanvas.toDataURL('image/png');
                link.click();
                exportModal.style.display = 'none';
            };
            
            function solve(A, b) {
                const n = A.length;
                let M = A.map(row => [...row]);
                let B = [...b];
                for (let i = 0; i < n; i++) {
                    let maxRow = i;
                    for (let k = i + 1; k < n; k++) { if (Math.abs(M[k][i]) > Math.abs(M[maxRow][i])) maxRow = k; }
                    [M[i], M[maxRow]] = [M[maxRow], M[i]];
                    [B[i], B[maxRow]] = [B[maxRow], B[i]];
                    if (Math.abs(M[i][i]) <= 1e-10) return null;
                    for (let k = i + 1; k < n; k++) {
                        const c = -M[k][i] / M[i][i];
                        for (let j = i; j < n; j++) { if (i === j) M[k][j] = 0; else M[k][j] += c * M[i][j]; }
                        B[k] += c * B[i];
                    }
                }
                const x = new Array(n);
                for (let i = n - 1; i > -1; i--) {
                    x[i] = B[i] / M[i][i];
                    for (let k = i - 1; k > -1; k--) { B[k] -= M[k][i] * x[i]; }
                }
                return x;
            }

            init();
        });
    </script>
</body>
</html>
