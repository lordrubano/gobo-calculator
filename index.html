<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Профессиональный редактор-калькулятор для гобо v3.0</title>
    <script src="https://d3js.org/d3-delaunay.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
    <style>
        :root {
            --bg-color: #1e1e2f; --panel-bg: #27293d; --primary-color: #8a78ff;
            --text-color: #f0f0f0; --border-color: #44475a; --success-color: #50fa7b;
            --danger-color: #ff5555; --warning-color: #f1fa8c;
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }
        body { font-family: var(--font-family); background-color: var(--bg-color); color: var(--text-color); margin: 0; padding: 20px; font-size: 14px; }
        .app-container { max-width: 1400px; margin: auto; }
        header { text-align: center; margin-bottom: 20px; }
        header h1 { margin: 0; font-size: 24px; }
        header p { margin: 5px 0; color: #9a9a9a; }
        .control-panel { display: flex; flex-wrap: wrap; justify-content: center; gap: 15px; margin-bottom: 20px; }
        .control-panel button { background-color: var(--primary-color); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold; transition: background-color 0.2s; }
        .control-panel button.danger { background-color: var(--danger-color); }
        .control-panel button:hover { opacity: 0.9; }
        .control-panel button:disabled { background-color: #666; cursor: not-allowed; opacity: 0.7; }
        .main-content { display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px; margin-bottom: 20px; }
        .canvas-panel { background-color: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 8px; padding: 15px; display: flex; flex-direction: column; align-items: center; }
        .canvas-panel h2 { margin-top: 0; text-align: center; font-size: 16px; }
        .canvas-container { position: relative; width: 100%; padding-top: 75%; background-color: #111; border-radius: 4px; overflow: hidden; }
        .canvas-container canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; cursor: crosshair; }
        .panel-footer { width: 100%; padding-top: 10px; text-align: center; color: #9a9a9a; height: 20px; }
        .panel-footer .status.ready { color: var(--success-color); font-weight: bold; }
        .panel-footer .status.mismatch { color: var(--warning-color); font-weight: bold; }
        .instructions { background-color: var(--panel-bg); border-radius: 8px; padding: 20px; }
        .instructions h3 { margin-top: 0; }
        .instructions ol { padding-left: 20px; }
        .loupe { position: absolute; width: 120px; height: 120px; border: 3px solid var(--primary-color); border-radius: 50%; pointer-events: none; display: none; overflow: hidden; box-shadow: 0 5px 15px rgba(0,0,0,0.5); z-index: 100; background: var(--bg-color); }
        .loupe::before, .loupe::after { content: ''; position: absolute; background-color: var(--danger-color); z-index: 101; }
        .loupe::before { top: 50%; left: 10%; width: 80%; height: 1px; margin-top: -0.5px; }
        .loupe::after { left: 50%; top: 10%; height: 80%; width: 1px; margin-left: -0.5px; }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); display: none; justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background-color: var(--panel-bg); padding: 30px; border-radius: 8px; width: 300px; text-align: center; }
        .file-input { display: none; }
    </style>
</head>
<body>
    <div class="app-container">
        <header>
            <h1>Профессиональный редактор-калькулятор для гобо</h1>
            <p>Версия 3.0 (Стабильная производственная)</p>
        </header>
        <div class="control-panel">
            <button id="load-template-btn">Загрузить фото-шаблон</button>
            <button id="load-source-btn">Загрузить изображение</button>
            <button id="clear-points-btn" class="danger">Очистить точки</button>
            <button id="export-btn" disabled>Экспорт</button>
        </div>
        <input type="file" id="template-file-input" class="file-input" accept="image/*">
        <input type="file" id="source-file-input" class="file-input" accept="image/*">
        <div class="main-content">
            <div class="canvas-panel"><h2>Исходное изображение</h2><div class="canvas-container"><canvas id="source-canvas"></canvas></div><div class="panel-footer">Точек источника: <span id="source-points-count">0</span></div></div>
            <div class="canvas-panel"><h2>Фото-шаблон</h2><div class="canvas-container"><canvas id="template-canvas"></canvas></div><div class="panel-footer">Точек цели: <span id="dest-points-count">0</span></div></div>
            <div class="canvas-panel"><h2>Предпросмотр деформации</h2><div class="canvas-container"><canvas id="preview-canvas"></canvas></div><div class="panel-footer">Статус: <span id="status-text">Ожидание изображений</span></div></div>
        </div>
        <div class="instructions"></div>
        <div class="loupe" id="loupe"></div>
        <div class="modal-overlay" id="export-modal"></div>
    </div>
    
    <script>
        class GoboEditor {
            constructor() {
                this.sourceImage = null; this.templateImage = null;
                this.sourcePoints = []; this.destinationPoints = [];
                this.draggingPointInfo = null; this.sourceRenderInfo = {};
                this.initDOM(); this.initCanvases(); this.bindEvents(); this.renderAll();
            }

            initDOM() {
                this.sourceCanvas=document.getElementById('source-canvas'); this.templateCanvas=document.getElementById('template-canvas'); this.previewCanvas=document.getElementById('preview-canvas');
                this.loupe=document.getElementById('loupe'); this.exportBtn=document.getElementById('export-btn'); this.exportModal=document.getElementById('export-modal');
                document.querySelector('.instructions').innerHTML = `<h3>Инструкция:</h3><ol><li>Загрузите фото-шаблон.</li><li>Загрузите исходное изображение.</li><li>Кликните по ключевым точкам на исходном изображении (минимум 4).</li><li>Кликните по соответствующим точкам на фото-шаблоне в том же порядке.</li><li>Используйте лупу для точного позиционирования.</li><li>Перетаскивайте точки для финальной подгонки.</li><li>Наблюдайте real-time деформацию в окне предпросмотра.</li><li>Нажмите "Экспорт" для создания готового файла.</li></ol>`;
                this.exportModal.innerHTML = `<div class="modal-content"><h2>Параметры экспорта</h2><div class="form-group" style="margin-bottom: 1rem; text-align: left;"><label for="gobo-diameter" style="display: block; margin-bottom: 0.5rem;">Диаметр гобо (мм)</label><input type="number" id="gobo-diameter" value="37.5" step="0.1" style="width: 100%; padding: 0.5rem; border-radius: 4px; border: 1px solid #44475a; background-color: #1e1e2f; color: #f0f0f0;"></div><div class="form-group" style="margin-bottom: 1rem; text-align: left;"><label for="gobo-dpi" style="display: block; margin-bottom: 0.5rem;">Разрешение (DPI)</label><input type="number" id="gobo-dpi" value="2700" step="100" style="width: 100%; padding: 0.5rem; border-radius: 4px; border: 1px solid #44475a; background-color: #1e1e2f; color: #f0f0f0;"></div><div style="display: flex; justify-content: space-between; gap: 1rem;"><button id="cancel-export-btn" class="danger" style="flex: 1; padding: 0.5rem; border: none; border-radius: 5px; cursor: pointer;">Отмена</button><button id="confirm-export-btn" style="flex: 1; padding: 0.5rem; border: none; border-radius: 5px; cursor: pointer; background-color: var(--primary-color); color: white;">Сохранить</button></div></div>`;
            }

            initCanvases() {
                this.sourceCtx=this.sourceCanvas.getContext('2d'); this.templateCtx=this.templateCanvas.getContext('2d'); this.previewCtx=this.previewCanvas.getContext('2d');
            }

            bindEvents() {
                const resizeObserver = new ResizeObserver(()=>this.onResize());
                resizeObserver.observe(this.sourceCanvas.parentElement);
                document.getElementById('load-template-btn').addEventListener('click',()=>document.getElementById('template-file-input').click());
                document.getElementById('load-source-btn').addEventListener('click',()=>document.getElementById('source-file-input').click());
                document.getElementById('template-file-input').addEventListener('change',(e)=>this.loadImage(e.target.files[0],true));
                document.getElementById('source-file-input').addEventListener('change',(e)=>this.loadImage(e.target.files[0],false));
                document.getElementById('clear-points-btn').addEventListener('click',()=>this.clearPoints());
                this.exportBtn.addEventListener('click',()=>this.exportModal.style.display='flex');
                document.getElementById('cancel-export-btn').addEventListener('click',()=>this.exportModal.style.display='none');
                document.getElementById('confirm-export-btn').addEventListener('click',()=>this.handleExport());
                this.setupCanvasInteraction(this.sourceCanvas,this.sourcePoints);
                this.setupCanvasInteraction(this.templateCanvas,this.destinationPoints);
            }
                
            onResize(){[this.sourceCanvas,this.templateCanvas,this.previewCanvas].forEach(c=>{const p=c.parentElement;c.width=p.clientWidth;c.height=p.clientHeight;});this.renderAll();}
            loadImage(f,t){if(!f)return;const r=new FileReader();r.onload=e=>{const i=new Image();i.crossOrigin="anonymous";i.onload=()=>{if(t)this.templateImage=i;else this.sourceImage=i;this.renderAll();};i.src=e.target.result;};r.readAsDataURL(f);}

            setupCanvasInteraction(canvas, points) {
                const getCoords=(e)=>{const r=canvas.getBoundingClientRect();return{x:e.clientX-r.left,y:e.clientY-r.top};};
                canvas.addEventListener('mousedown',e=>{const c=getCoords(e);const i=this.getPointAt(c,points);if(i!==-1)this.draggingPointInfo={p:points[i],a:points};});
                canvas.addEventListener('mousemove',e=>{const c=getCoords(e);this.updateLoupe(e,canvas,c);if(this.draggingPointInfo&&this.draggingPointInfo.a===points){this.draggingPointInfo.p[0]=c.x;this.draggingPointInfo.p[1]=c.y;this.renderAll();}});
                canvas.addEventListener('mouseup',()=>{this.draggingPointInfo=null;});
                canvas.addEventListener('mouseleave',()=>{this.loupe.style.display='none';this.draggingPointInfo=null;});
                canvas.addEventListener('mouseenter',()=>{this.loupe.style.display='block';});
                canvas.addEventListener('click',e=>{if(this.draggingPointInfo)return;const c=getCoords(e);if(this.getPointAt(c,points)===-1){if(canvas===this.sourceCanvas)points.push([c.x,c.y]);else if(canvas===this.templateCanvas&&points.length<this.sourcePoints.length)points.push([c.x,c.y]);this.renderAll();}});
            }
                
            getPointAt(c,p){for(let i=0;i<p.length;i++){if(Math.sqrt((p[i][0]-c.x)**2+(p[i][1]-c.y)**2)<10)return i;}return-1;}
            clearPoints(){this.sourcePoints.length=0;this.destinationPoints.length=0;this.renderAll();}
                
            renderAll() {
                this.sourceRenderInfo=this.drawCanvasWithAspectRatio(this.sourceCtx,this.sourceCanvas,this.sourceImage,this.sourcePoints);
                this.drawCanvasWithAspectRatio(this.templateCtx,this.templateCanvas,this.templateImage,this.destinationPoints);
                this.updatePreview(); this.updateStatus();
            }

            drawCanvasWithAspectRatio(ctx,canvas,img,points){
                ctx.fillStyle='#111827';ctx.fillRect(0,0,canvas.width,canvas.height);
                const r={ox:0,oy:0,dw:0,dh:0,img:img};
                if(img){const cr=canvas.width/canvas.height,ir=img.naturalWidth/img.naturalHeight;r.dw=canvas.width;r.dh=canvas.height;if(ir>cr){r.dh=canvas.width/ir;r.oy=(canvas.height-r.dh)/2;}else{r.dw=canvas.height*ir;r.ox=(canvas.width-r.dw)/2;}ctx.drawImage(img,r.ox,r.oy,r.dw,r.dh);}
                points.forEach((p,i)=>this.drawPoint(ctx,p,i+1));return r;
            }

            drawPoint(ctx,p,n){ctx.beginPath();ctx.arc(p[0],p[1],5,0,2*Math.PI);ctx.fillStyle='rgba(59,130,246,0.9)';ctx.fill();ctx.strokeStyle='#fff';ctx.lineWidth=1.5;ctx.stroke();ctx.fillStyle='#fff';ctx.font='bold 10px sans-serif';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillText(n,p[0],p[1]);}
                
            updateLoupe(e,c,o){const i=c===this.sourceCanvas?this.sourceImage:this.templateImage;if(!i)return;const z=4;this.loupe.style.left=`${e.pageX+15}px`;this.loupe.style.top=`${e.pageY+15}px`;const rI=c===this.sourceCanvas?this.sourceRenderInfo:this.drawCanvasWithAspectRatio(document.createElement('canvas').getContext('2d'),c,i,[]);const iX=(o.x-rI.ox)/rI.dw*i.naturalWidth,iY=(o.y-rI.oy)/rI.dh*i.naturalHeight;const lC=this.loupe.querySelector('canvas')||document.createElement('canvas');if(!this.loupe.querySelector('canvas')){this.loupe.appendChild(lC);lC.width=120;lC.height=120;}const lX=lC.getContext('2d');lX.fillStyle='#111';lX.fillRect(0,0,120,120);lX.setTransform(z,0,0,z,-iX*z+60,-iY*z+60);lX.drawImage(i,0,0);}

            updateStatus(){const sC=this.sourcePoints.length,dC=this.destinationPoints.length;document.getElementById('source-points-count').textContent=sC;document.getElementById('dest-points-count').textContent=dC;const sS=document.getElementById('status-text');const cW=sC>=4&&sC===dC;if(cW){sS.textContent='Готово к экспорту';sS.className='status ready';this.exportBtn.disabled=false;}else if(sC!==dC){sS.textContent=`Синхронизация (${sC}/${dC})`;sS.className='status mismatch';this.exportBtn.disabled=true;}else{sS.textContent='Расставьте точки';sS.className='status';this.exportBtn.disabled=true;}}
                
            updatePreview() {
                this.previewCtx.clearRect(0,0,this.previewCanvas.width,this.previewCanvas.height);
                if(this.templateImage)this.drawCanvasWithAspectRatio(this.previewCtx,this.previewCanvas,this.templateImage,[]);
                if(!this.sourceImage||this.sourcePoints.length<4||this.sourcePoints.length!==this.destinationPoints.length)return;
                const warpedCanvas=this.getWarpedCanvas(this.sourceImage,this.sourcePoints,this.destinationPoints,this.templateCanvas.width,this.templateCanvas.height);
                if(warpedCanvas)this.previewCtx.drawImage(warpedCanvas,0,0);
            }

            getWarpedCanvas(img,srcPts,destPts,w,h) {
                const warpedCanvas=document.createElement('canvas');warpedCanvas.width=w;warpedCanvas.height=h;
                const warpedCtx=warpedCanvas.getContext('2d');
                const absSrcPts=srcPts.map(p=>[(p[0]-this.sourceRenderInfo.ox)/this.sourceRenderInfo.dw*img.naturalWidth,(p[1]-this.sourceRenderInfo.oy)/this.sourceRenderInfo.dh*img.naturalHeight]);
                try{
                    const delaunay=d3.Delaunay.from(absSrcPts);
                    const triangles=delaunay.triangles;
                    for(let i=0;i<triangles.length;i+=3){
                        const p_src_abs=[absSrcPts[triangles[i]],absSrcPts[triangles[i+1]],absSrcPts[triangles[i+2]]];
                        const p_dest=[destPts[triangles[i]],destPts[triangles[i+1]],destPts[triangles[i+2]]];
                        const triArea=(p0,p1,p2)=>0.5*Math.abs(p0[0]*(p1[1]-p2[1])+p1[0]*(p2[1]-p0[1])+p2[0]*(p0[1]-p1[1]));
                        if(triArea(p_src_abs[0],p_src_abs[1],p_src_abs[2])<0.1)continue;
                        warpedCtx.save();
                        warpedCtx.beginPath();
                        warpedCtx.moveTo(p_dest[0][0],p_dest[0][1]);
                        warpedCtx.lineTo(p_dest[1][0],p_dest[1][1]);
                        warpedCtx.lineTo(p_dest[2][0],p_dest[2][1]);
                        warpedCtx.closePath();
                        warpedCtx.clip();
                        const transform=this.getAffineTransform(p_src_abs,p_dest);
                        if(transform){warpedCtx.setTransform(transform.a,transform.b,transform.c,transform.d,transform.e,transform.f);warpedCtx.drawImage(img,0,0);}
                        warpedCtx.restore();
                    }
                    return warpedCanvas;
                }catch(e){console.error("Warping failed:",e);return null;}
            }

            getAffineTransform(src, dst) {
                try {
                    const M=math.matrix([[src[0][0],src[0][1],1,0,0,0],[0,0,0,src[0][0],src[0][1],1],[src[1][0],src[1][1],1,0,0,0],[0,0,0,src[1][0],src[1][1],1],[src[2][0],src[2][1],1,0,0,0],[0,0,0,src[2][0],src[2][1],1]]);
                    const b=math.matrix([dst[0][0],dst[0][1],dst[1][0],dst[1][1],dst[2][0],dst[2][1]]);
                    const t=math.lusolve(M,b).valueOf().flat();
                    return{a:t[0],b:t[3],c:t[1],d:t[4],e:t[2],f:t[5]};
                }catch(e){console.error("Matrix solving failed:",e);return null;}
            }

            handleExport() {
                const diameter=parseFloat(document.getElementById('gobo-diameter').value);
                const dpi=parseInt(document.getElementById('gobo-dpi').value);
                if(isNaN(diameter)||isNaN(dpi)||diameter<=0||dpi<=0){alert('Введите корректные значения.');return;}
                const exportSizePx=Math.round((diameter/25.4)*dpi);
                const exportCanvas=document.createElement('canvas');exportCanvas.width=exportSizePx;exportCanvas.height=exportSizePx;
                const exportCtx=exportCanvas.getContext('2d');
                exportCtx.fillStyle='black';
                exportCtx.beginPath();
                exportCtx.arc(exportSizePx/2,exportSizePx/2,exportSizePx/2,0,2*Math.PI);
                exportCtx.fill();
                
                let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
                this.destinationPoints.forEach(p=>{minX=Math.min(minX,p[0]);minY=Math.min(minY,p[1]);maxX=Math.max(maxX,p[0]);maxY=Math.max(maxY,p[1]);});
                const bboxWidth=maxX-minX,bboxHeight=maxY-minY;
                const margin=0.95;
                const scale=Math.min(exportSizePx*margin/bboxWidth,exportSizePx*margin/bboxHeight);
                const scaledBboxWidth=bboxWidth*scale,scaledBboxHeight=bboxHeight*scale;
                const offsetX=(exportSizePx-scaledBboxWidth)/2,offsetY=(exportSizePx-scaledBboxHeight)/2;

                const finalDestPoints=this.destinationPoints.map(p=>[(p[0]-minX)*scale+offsetX,(p[1]-minY)*scale+offsetY]);

                const warpedCanvas=this.getWarpedCanvas(this.sourceImage,this.sourcePoints,finalDestPoints,exportSizePx,exportSizePx);
                if(warpedCanvas)exportCtx.drawImage(warpedCanvas,0,0);

                const link=document.createElement('a');
                link.download=`gobo_export_${diameter}mm_${dpi}dpi.png`;
                link.href=exportCanvas.toDataURL('image/png');
                link.click();
                this.exportModal.style.display='none';
            }
        }
        new GoboEditor();
    });
    </script>
</body>
</html>
