<!DOCTYPE html>
<html lang="ru" style="scroll-behavior: smooth;">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GOBO –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä-–õ–µ–Ω–¥–∏–Ω–≥</title>
    
    <script src="https://cdn.jsdelivr.net/npm/delaunator@5.0.0/delaunator.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-to-tiff@1.1.1/dist/canvas-to-tiff.min.js"></script>
    
    <style>
        /* –û–ë–©–ò–ï –°–¢–ò–õ–ò */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background: #f4f7f6; color: #333; }
        
        /* –®–ê–ü–ö–ê –ò –ù–ê–í–ò–ì–ê–¶–ò–Ø */
        .header { background: white; padding: 15px 30px; text-align: center; box-shadow: 0 2px 10px rgba(0,0,0,0.05); position: sticky; top: 0; z-index: 1000; }
        .header h1 { color: #4a4a4a; margin-bottom: 5px; font-size: 24px; }
        .progress-bar { display: flex; justify-content: center; gap: 20px; }
        .progress-step { padding: 5px 10px; border-radius: 12px; font-weight: 500; color: #aaa; transition: all 0.3s ease; cursor: pointer; text-decoration: none; }
        .progress-step.active { color: #5a67d8; font-weight: 700; background: rgba(90, 103, 216, 0.1); }
        .progress-step.completed { color: #38a169; }

        /* –û–°–ù–û–í–ù–û–ô –ö–û–ù–¢–ï–ô–ù–ï–† */
        .container { max-width: 900px; margin: 30px auto; padding: 0 20px; }
        
        /* –°–¢–ò–õ–ò –®–ê–ì–û–í (–°–ï–ö–¶–ò–ô) */
        .step-section { background: #fff; padding: 40px; border-radius: 16px; box-shadow: 0 8px 40px rgba(0,0,0,0.08); margin-bottom: 40px; border-left: 5px solid #e2e8f0; transition: all 0.5s ease; }
        .step-section.active { border-left-color: #5a67d8; }
        .step-section.completed { border-left-color: #48bb78; }
        .step-section h2 { color: #5a67d8; margin-bottom: 10px; font-size: 28px; display: flex; align-items: center; }
        .step-section h2 .step-number { background: #5a67d8; color: white; border-radius: 50%; width: 32px; height: 32px; display: inline-flex; align-items: center; justify-content: center; font-size: 16px; margin-right: 15px; flex-shrink: 0; }
        .step-section > p { color: #666; margin-bottom: 25px; }
        
        /* –°–∫—Ä—ã—Ç–∏–µ –∏ –ø–æ–∫–∞–∑ —Å–µ–∫—Ü–∏–π */
        .step-section.is-locked { opacity: 0; max-height: 0; padding: 0 40px; margin: 0; border-width: 0; overflow: hidden; }

        /* –≠–ª–µ–º–µ–Ω—Ç—ã —Ñ–æ—Ä–º */
        .form-group { margin-bottom: 20px; }
        .form-group label { display: block; margin-bottom: 8px; font-weight: 600; color: #4a5568; }
        .form-group input, .form-group select { width: 100%; padding: 12px; border: 1px solid #e2e8f0; border-radius: 8px; font-size: 16px; transition: all 0.2s ease; background: #f7fafc; }
        .form-group input:focus { outline: none; border-color: #5a67d8; background: #fff; box-shadow: 0 0 0 3px rgba(90, 103, 216, 0.2); }
        .form-row { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; }
        
        /* –ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–æ—Ç–æ */
        .photo-upload-area { border: 3px dashed #cbd5e0; border-radius: 10px; padding: 40px; text-align: center; background: #f7fafc; transition: all 0.3s ease; cursor: pointer; }
        .photo-upload-area:hover { border-color: #5a67d8; background: #edf2f7; }
        #photo-container { position: relative; display: inline-block; margin-top: 20px; user-select: none; }
        #step2-photo { max-width: 100%; height: auto; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); display: block;}
        .assigned-point { position: absolute; width: 14px; height: 14px; background: #e53e3e; color: white; border-radius: 50%; text-align: center; line-height: 14px; font-size: 9px; font-weight: bold; cursor: pointer; z-index: 10; border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3); transition: transform 0.2s ease; user-select: none; transform: translate(-50%, -50%); }
        #lines-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
        .image-upload-input { display: block; margin-bottom: 20px; }
        #step3-image-preview { min-height: 150px; border: 2px dashed #cbd5e0; padding: 10px; text-align: center; background: #f9f9f9; border-radius: 10px;}
        
        /* –†–µ–¥–∞–∫—Ç–æ—Ä */
        .deformation-stage-wrapper { text-align: center; }
        .deformation-stage { position: relative; margin: 20px auto; border: 2px solid #e2e8f0; border-radius: 10px; overflow: hidden; display: inline-block; background-color: #eee; }
        #deformation-canvas { display: block; max-width: 100%; height: auto; }
        .control-point { position: absolute; width: 16px; height: 16px; border: 2px solid white; border-radius: 50%; background: #e53e3e; cursor: grab; z-index: 20; box-shadow: 0 2px 5px rgba(0,0,0,0.3); touch-action: none; transform: translate(-50%, -50%); }
        .controls-panel { background: #f7fafc; padding: 20px; border-radius: 10px; margin-top: 20px; display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; align-items: center; border: 1px solid #e2e8f0; }
        .control-group { display: flex; flex-direction: column; }
        .control-group label { margin-bottom: 8px; font-weight: 600; color: #4a5568; }
        .pan-controls button { width: 40px; height: 40px; font-size: 20px; line-height: 40px; text-align: center; border: 1px solid #ccc; border-radius: 6px; background: #fff; cursor: pointer;}
        
        /* –ö–Ω–æ–ø–∫–∏ */
        .action-button { display: inline-block; padding: 12px 30px; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.3s ease; background: #5a67d8; color: white; text-align: right; margin-top: 20px; }
        .action-button:disabled { background: #cbd5e0; color: #a0aec0; cursor: not-allowed; }
        
        /* –§–∏–Ω–∞–ª—å–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç */
        #finalResult { text-align: center; padding: 10px; background: #f7fafc; border-radius: 10px; border: 1px solid #e2e8f0; min-height: 200px; display: flex; align-items: center; justify-content: center; }
        #result-canvas { max-width: 100%; border-radius: 8px; box-shadow: 0 8px 25px rgba(0,0,0,0.1); background: black; }
    </style>
</head>
<body>

    <div class="header">
        <h1>GOBO –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä-—Ä–µ–¥–∞–∫—Ç–æ—Ä</h1>
        <div class="progress-bar" id="progressBar">
            <a class="progress-step active" href="#step1">–®–∞–≥ 1: –§–æ—Ç–æ</a>
            <a class="progress-step" href="#step2">–®–∞–≥ 2: –¢–æ—á–∫–∏</a>
            <a class="progress-step" href="#step3">–®–∞–≥ 3: –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</a>
            <a class="progress-step" href="#step4">–®–∞–≥ 4: –†–µ–¥–∞–∫—Ç–æ—Ä</a>
            <a class="progress-step" href="#step5">–®–∞–≥ 5: –≠–∫—Å–ø–æ—Ä—Ç</a>
        </div>
    </div>

    <div class="container">
        <section class="step-section active" id="step1">
            <h2><span class="step-number">1</span>–≠—Ç–∞–ª–æ–Ω–Ω–∞—è —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—è</h2>
            <p>–ó–∞–≥—Ä—É–∑–∏—Ç–µ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—é, —Å–¥–µ–ª–∞–Ω–Ω—É—é —Å –ø–æ–º–æ—â—å—é ¬´–£–º–Ω–æ–π –ù–∞—Å–∞–¥–∫–∏¬ª –∏–∑ —Ç–æ—á–Ω–æ–≥–æ –ø–æ–ª–æ–∂–µ–Ω–∏—è –æ–±—ä–µ–∫—Ç–∏–≤–∞ –ø—Ä–æ–µ–∫—Ç–æ—Ä–∞.</p>
            <div class="photo-upload-area" id="photoUploadArea">
                <h3>üì∏ –ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ —Ñ–æ—Ç–æ —Å—é–¥–∞ –∏–ª–∏ –∫–ª–∏–∫–Ω–∏—Ç–µ –¥–ª—è –≤—ã–±–æ—Ä–∞</h3>
            </div>
            <input type="file" id="photoInput" accept="image/*" style="display: none;">
        </section>

        <section class="step-section is-locked" id="step2">
            <h2><span class="step-number">2</span>–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ —Ç–æ—á–µ–∫ –∫–æ–Ω—Ç—É—Ä–∞</h2>
            <p>–ö–ª–∏–∫–Ω–∏—Ç–µ –ø–æ —É–≥–ª–∞–º –∫–æ–Ω—Ç—É—Ä–∞ –Ω–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏, —á—Ç–æ–±—ã –æ—Ç–º–µ—Ç–∏—Ç—å –µ–≥–æ. –ù—É–∂–Ω–æ –º–∏–Ω–∏–º—É–º 3 —Ç–æ—á–∫–∏.</p>
            <div id="photo-container">
                <img id="step2-photo" alt="–§–æ—Ç–æ –∫–æ–Ω—Ç—É—Ä–∞"><svg id="lines-svg"></svg>
            </div>
            <button class="action-button" onclick="clearAllPoints()">–û—á–∏—Å—Ç–∏—Ç—å —Ç–æ—á–∫–∏</button>
            <button class="action-button" id="step2-next" disabled>–î–∞–ª–µ–µ: –ó–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</button>
        </section>

        <section class="step-section is-locked" id="step3">
            <h2><span class="step-number">3</span>–ó–∞–≥—Ä—É–∑–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –≥–æ–±–æ</h2>
            <p>–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ (–ª–æ–≥–æ—Ç–∏–ø, –∑–Ω–∞–∫), –∫–æ—Ç–æ—Ä–æ–µ –±—É–¥–µ—Ç –ø—Ä–æ–µ—Ü–∏—Ä–æ–≤–∞—Ç—å—Å—è.</p>
            <input type="file" id="step3-image-input" class="image-upload-input" accept="image/*">
            <div id="step3-image-preview"><p>–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –ø–æ—è–≤–∏—Ç—Å—è –∑–¥–µ—Å—å...</p></div>
        </section>

        <section class="step-section is-locked" id="step4">
            <h2><span class="step-number">4</span>–ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏—è</h2>
            <p>–°–Ω–∞—á–∞–ª–∞ —Å–ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–π—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å –ø–æ–º–æ—â—å—é –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–æ–π –ø–∞–Ω–µ–ª–∏, –∞ –∑–∞—Ç–µ–º –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–π—Ç–µ –∫—Ä–∞—Å–Ω—ã–µ –º–∞—Ä–∫–µ—Ä—ã –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ —Å–æ–≤–º–µ—â–µ–Ω–∏—è.</p>
            <div class="deformation-stage-wrapper">
                <div class="deformation-stage" id="deformationStage">
                    <canvas id="deformation-canvas"></canvas>
                </div>
            </div>
            <div class="controls-panel">
                <div class="control-group">
                    <label>–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å: <span id="opacityValue">100</span>%</label>
                    <input type="range" id="opacitySlider" min="0" max="100" value="100">
                </div>
                <div class="control-group">
                    <label>–ú–∞—Å—à—Ç–∞–±: <span id="scaleValue">100</span>%</label>
                    <input type="range" id="scaleSlider" min="50" max="150" value="100">
                </div>
                <div class="control-group">
                    <label>–í—Ä–∞—â–µ–Ω–∏–µ: <span id="rotationValue">0</span>¬∞</label>
                    <input type="range" id="rotationSlider" min="-180" max="180" value="0">
                </div>
                <div class="control-group pan-controls">
                    <label>–ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ</label>
                    <div>
                        <button onclick="panImage(0, -5)">‚Üë</button>
                        <button onclick="panImage(0, 5)">‚Üì</button>
                        <button onclick="panImage(-5, 0)">‚Üê</button>
                        <button onclick="panImage(5, 0)">‚Üí</button>
                    </div>
                </div>
            </div>
            <button class="action-button" id="step4-next">–î–∞–ª–µ–µ: –≠–∫—Å–ø–æ—Ä—Ç</button>
        </section>

        <section class="step-section is-locked" id="step5">
            <h2><span class="step-number">5</span>–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –∏ —ç–∫—Å–ø–æ—Ä—Ç</h2>
            <p>–§–∏–Ω–∞–ª—å–Ω—ã–π –º–∞–∫–µ—Ç –≥–æ–±–æ-—Å–ª–∞–π–¥–∞, –≥–æ—Ç–æ–≤—ã–π –∫ –ø–µ—á–∞—Ç–∏. –£–∫–∞–∂–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏ —Å–∫–∞—á–∞–π—Ç–µ —Ñ–∞–π–ª –≤ —Ñ–æ—Ä–º–∞—Ç–µ .TIFF.</p>
            <div class="form-row">
                <div class="form-group"><label for="printDPI">–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ (DPI):</label><input type="number" id="printDPI" value="2700"></div>
                <div class="form-group"><label for="slideDiameter">–î–∏–∞–º–µ—Ç—Ä —Å–ª–∞–π–¥–∞ (–º–º):</label><input type="number" id="slideDiameter" value="37.5"></div>
                <div class="form-group"><label for="printDiameter">–î–∏–∞–º–µ—Ç—Ä –ø–µ—á–∞—Ç–∏ (–º–º):</label><input type="number" id="printDiameter" value="32"></div>
                <div class="form-group"><label for="alignMark">–ú–µ—Ç–∫–∞ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è:</label><input type="text" id="alignMark" value="PLT"></div>
            </div>
            <div id="finalResult">
                 <canvas id="result-canvas"></canvas>
            </div>
            <button class="action-button" onclick="exportFinalGobo()">–°–∫–∞—á–∞—Ç—å .TIFF</button>
        </section>
    </div>

<script>
// ===================================================================
// –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï
// ===================================================================
let currentStep = 1;
let photoData = null;
let userImageElement = null;
let assignedPoints = [];
let controlPointElements = [];
let transformState = { x: 0, y: 0, scale: 1, rotation: 0, opacity: 1, initialScale: 1 };
let deformationDestPoints = []; 
let activeControlPoint = null;

// ===================================================================
// –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø
// ===================================================================
document.addEventListener('DOMContentLoaded', initCalculator);

function initCalculator() {
    setupEventListeners();
    loadState();
}

// ===================================================================
// –£–ü–†–ê–í–õ–ï–ù–ò–ï –ò–ù–¢–ï–†–§–ï–ô–°–û–ú (–õ–µ–Ω–¥–∏–Ω–≥-—Å—Ç–∏–ª—å)
// ===================================================================
function unlockStep(stepNumber) {
    if (stepNumber > 5) return;

    const section = document.getElementById(`step${stepNumber}`);
    if (section && section.classList.contains('is-locked')) {
        section.classList.remove('is-locked');
    }
    
    setTimeout(() => {
        section.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }, 100);

    updateProgressUI(stepNumber);
    currentStep = stepNumber;
    saveState();
}

function updateProgressUI(activeStep) {
    document.querySelectorAll('#progressBar .progress-step').forEach((el, i) => {
        el.classList.remove('active', 'completed');
        const stepNum = i + 1;
        if (stepNum < activeStep) el.classList.add('completed');
        else if (stepNum === activeStep) el.classList.add('active');
    });
    document.querySelectorAll('.step-section').forEach((el, i) => {
        el.classList.remove('active', 'completed');
        const stepNum = i + 1;
        if (stepNum < activeStep) el.classList.add('completed');
        else if (stepNum === activeStep) el.classList.add('active');
    });
}


// ===================================================================
// –°–û–•–†–ê–ù–ï–ù–ò–ï –ò –ó–ê–ì–†–£–ó–ö–ê –°–û–°–¢–û–Ø–ù–ò–Ø (localStorage)
// ===================================================================
function saveState() {
    const state = {
        currentStep: currentStep,
        photoData: photoData,
        assignedPointsCoords: assignedPoints.map(p => ({ x: p.x, y: p.y })),
        userImageSrc: userImageElement ? userImageElement.src : null
    };
    localStorage.setItem('goboProjectState', JSON.stringify(state));
}

function loadState() {
    const savedStateJSON = localStorage.getItem('goboProjectState');
    if (!savedStateJSON) { updateProgressUI(1); return; }

    const savedState = JSON.parse(savedStateJSON);
    
    if (savedState.userImageSrc) {
        userImageElement = new Image();
        userImageElement.src = savedState.userImageSrc;
        userImageElement.onload = () => initUIFromState(savedState);
    } else {
        initUIFromState(savedState);
    }
}

function initUIFromState(savedState) {
    photoData = savedState.photoData;
    
    if (photoData) {
        document.getElementById('photoUploadArea').innerHTML = `<img src="${photoData}" style="max-width:100%">`;
        document.getElementById('step2-photo').src = photoData;
    }
    if (savedState.assignedPointsCoords && savedState.assignedPointsCoords.length > 0) {
        assignedPoints = savedState.assignedPointsCoords.map(p => ({...p, element: null}));
        // –õ–æ–≥–∏–∫–∞ –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∫–∏ —Ç–æ—á–µ–∫ –Ω–∞ —Ö–æ–ª—Å—Ç–µ, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
        document.getElementById('step2-next').disabled = assignedPoints.length < 3;
    }
    if (userImageElement && userImageElement.complete) {
        document.getElementById('step3-image-preview').innerHTML = `<img src="${userImageElement.src}" style="max-width:100%">`;
    }

    for (let i = 1; i <= savedState.currentStep; i++) {
        const section = document.getElementById(`step${i}`);
        if(section) section.classList.remove('is-locked');
    }
    updateProgressUI(savedState.currentStep);

    if (savedState.currentStep >= 4) {
        initEditor();
    }
    if (savedState.currentStep === 5) {
        initEditor(); // –Ω—É–∂–Ω–æ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è transformState
        generateFinalResultPreview();
    }

    setTimeout(() => {
        const targetEl = document.getElementById(`step${savedState.currentStep}`);
        if(targetEl) targetEl.scrollIntoView({ behavior: 'auto', block: 'start' });
    }, 300);
}


// ===================================================================
// –õ–û–ì–ò–ö–ê –®–ê–ì–û–í –ò –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –°–û–ë–´–¢–ò–ô
// ===================================================================
function setupEventListeners() {
    const photoUploadArea = document.getElementById('photoUploadArea');
    const photoInput = document.getElementById('photoInput');
    photoUploadArea.addEventListener('click', () => photoInput.click());
    photoInput.addEventListener('change', handlePhotoUpload);
    document.getElementById('step2-photo').addEventListener('click', handlePointAssignment);
    document.getElementById('step2-next').addEventListener('click', () => unlockStep(3));
    document.getElementById('step3-image-input').addEventListener('change', handleGoboImageUpload);
    document.getElementById('step4-next').addEventListener('click', () => {
        generateFinalResultPreview();
        unlockStep(5);
    });
    setupEditorControls();
}

function handlePhotoUpload(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
        photoData = ev.target.result;
        document.getElementById('photoUploadArea').innerHTML = `<img src="${photoData}" style="max-width:100%">`;
        const step2Photo = document.getElementById('step2-photo');
        step2Photo.src = photoData;
        step2Photo.onload = () => {
            unlockStep(2);
        };
    };
    reader.readAsDataURL(file);
}

function handlePointAssignment(event) {
    const photoElement = event.target;
    const rect = photoElement.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    const pointEl = document.createElement('div');
    pointEl.className = 'assigned-point';
    pointEl.style.left = `${x}px`;
    pointEl.style.top = `${y}px`;
    photoElement.parentElement.appendChild(pointEl);
    assignedPoints.push({ x, y, element: pointEl });
    document.getElementById('step2-next').disabled = assignedPoints.length < 3;
    saveState();
}

function clearAllPoints() {
    assignedPoints.forEach(p => p.element?.remove());
    assignedPoints = [];
    document.getElementById('step2-next').disabled = true;
    saveState();
}

function handleGoboImageUpload(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        userImageElement = new Image();
        userImageElement.src = e.target.result;
        userImageElement.onload = () => {
            document.getElementById('step3-image-preview').innerHTML = `<img src="${userImageElement.src}" style="max-width:100%">`;
            initEditor();
            unlockStep(4);
        };
    };
    reader.readAsDataURL(file);
}


// ===================================================================
// –õ–û–ì–ò–ö–ê –†–ï–î–ê–ö–¢–û–†–ê (–®–ê–ì 4)
// ===================================================================
function initEditor() {
    if (!userImageElement || !document.getElementById('step2-photo').complete) return;
    const canvas = document.getElementById('deformation-canvas');
    const stage = document.getElementById('deformationStage');
    const bgPhoto = document.getElementById('step2-photo');
    canvas.width = bgPhoto.offsetWidth;
    canvas.height = bgPhoto.offsetHeight;
    calculateInitialTransform();
    setupControlPoints(stage);
    drawTransformedImage();
}

function calculateInitialTransform() {
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    if(assignedPoints.length === 0) return;
    assignedPoints.forEach(p => {
        minX = Math.min(minX, p.x); minY = Math.min(minY, p.y);
        maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y);
    });
    const contourWidth = maxX - minX;
    const contourHeight = maxY - minY;
    const contourCenterX = minX + contourWidth / 2;
    const contourCenterY = minY + contourHeight / 2;
    const targetSize = Math.max(contourWidth, contourHeight) * 1.2;
    const imgMaxDim = Math.max(userImageElement.naturalWidth, userImageElement.naturalHeight);
    transformState.initialScale = targetSize / imgMaxDim;
    transformState.scale = transformState.initialScale;
    transformState.x = contourCenterX;
    transformState.y = contourCenterY;
    transformState.rotation = 0;
    transformState.opacity = 1;
}
    
function setupControlPoints(stage) {
    controlPointElements.forEach(p => p.remove());
    controlPointElements = [];
    deformationDestPoints = [];
    assignedPoints.forEach((p, i) => {
        const point = { x: p.x, y: p.y };
        deformationDestPoints.push(point);
        const pointElement = document.createElement('div');
        pointElement.className = 'control-point';
        pointElement.dataset.index = i;
        pointElement.style.left = `${point.x}px`;
        pointElement.style.top = `${point.y}px`;
        stage.appendChild(pointElement);
        controlPointElements.push(pointElement);
        pointElement.addEventListener('mousedown', (e) => { e.preventDefault(); activeControlPoint = { index: i, element: pointElement }; });
    });
    document.removeEventListener('mousemove', handleDrag);
    document.removeEventListener('mouseup', stopDrag);
    document.addEventListener('mousemove', handleDrag);
    document.addEventListener('mouseup', stopDrag);
}
    
function setupEditorControls() {
    const sliders = { opacity: 100, scale: 100, rotation: 0 };
    for (const type in sliders) {
        const slider = document.getElementById(`${type}Slider`);
        const valueEl = document.getElementById(`${type}Value`);
        if(type === 'scale') slider.value = 100;
        else if (type === 'rotation') slider.value = 0;
        else slider.value = 100;
        valueEl.textContent = slider.value;
        slider.oninput = () => {
            valueEl.textContent = slider.value;
            if (type === 'opacity') transformState.opacity = slider.value / 100;
            if (type === 'rotation') transformState.rotation = parseInt(slider.value);
            if (type === 'scale') transformState.scale = transformState.initialScale * (slider.value / 100);
            drawTransformedImage();
        };
    }
}

window.panImage = (dx, dy) => { transformState.x += dx; transformState.y += dy; drawTransformedImage(); };
function handleDrag(e) {
    if (!activeControlPoint) return;
    const stageRect = document.getElementById('deformationStage').getBoundingClientRect();
    const x = e.clientX - stageRect.left;
    const y = e.clientY - stageRect.top;
    activeControlPoint.element.style.left = `${x}px`;
    activeControlPoint.element.style.top = `${y}px`;
    deformationDestPoints[activeControlPoint.index] = { x, y };
    drawTransformedImage();
}
function stopDrag() { activeControlPoint = null; }

function drawTransformedImage() {
    if (!userImageElement || !userImageElement.complete) return;
    const canvas = document.getElementById('deformation-canvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const bgPhotoImg = document.getElementById('step2-photo');
    if(bgPhotoImg && bgPhotoImg.complete) ctx.drawImage(bgPhotoImg, 0, 0, canvas.width, canvas.height);
    
    ctx.save();
    ctx.globalAlpha = transformState.opacity;
    ctx.translate(transformState.x, transformState.y);
    ctx.rotate(transformState.rotation * Math.PI / 180);
    ctx.scale(transformState.scale, transformState.scale);
    const imgW = userImageElement.naturalWidth;
    const imgH = userImageElement.naturalHeight;
    ctx.translate(-imgW / 2, -imgH / 2);
    let sourcePoints = [];
    const numPoints = deformationDestPoints.length;
    for(let i=0; i<numPoints; i++) {
        const angle = (i / numPoints) * 2 * Math.PI - (Math.PI / 2);
        sourcePoints.push({ x: imgW / 2 + (imgW / 2) * Math.cos(angle), y: imgH / 2 + (imgH / 2) * Math.sin(angle) });
    }
    let localDestPoints = deformationDestPoints.map(p => {
        const dx = p.x - transformState.x;
        const dy = p.y - transformState.y;
        const angle = -transformState.rotation * Math.PI / 180;
        const s = transformState.scale;
        return { x: (dx * Math.cos(angle) - dy * Math.sin(angle)) / s + imgW/2, y: (dx * Math.sin(angle) + dy * Math.cos(angle)) / s + imgH/2 };
    });
    const delaunay = Delaunator.from(localDestPoints.map(p => [p.x, p.y]));
    for (let i = 0; i < delaunay.triangles.length; i += 3) {
        const t = [delaunay.triangles[i], delaunay.triangles[i+1], delaunay.triangles[i+2]];
        const src = t.map(p => sourcePoints[p]);
        const dst = t.map(p => localDestPoints[p]);
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(dst[0].x, dst[0].y); ctx.lineTo(dst[1].x, dst[1].y); ctx.lineTo(dst[2].x, dst[2].y);
        ctx.closePath();
        ctx.clip();
        const det = src[0].x * (src[1].y - src[2].y) + src[1].x * (src[2].y - src[0].y) + src[2].x * (src[0].y - src[1].y);
        if (Math.abs(det) < 1e-9) { ctx.restore(); continue; }
        const a = (dst[0].x * (src[1].y - src[2].y) + dst[1].x * (src[2].y - src[0].y) + dst[2].x * (src[0].y - src[1].y)) / det;
        const b = (dst[0].y * (src[1].y - src[2].y) + dst[1].y * (src[2].y - src[0].y) + dst[2].y * (src[0].y - src[1].y)) / det;
        const c = (dst[0].x * (src[2].x - src[1].x) + dst[1].x * (src[0].x - src[2].x) + dst[2].x * (src[1].x - src[0].x)) / det;
        const d = (dst[0].y * (src[2].x - src[1].x) + dst[1].y * (src[0].x - src[2].x) + dst[2].y * (src[1].x - src[0].x)) / det;
        const e = dst[0].x - a * src[0].x - c * src[0].y;
        const f = dst[0].y - b * src[0].x - d * src[0].y;
        ctx.transform(a, b, c, d, e, f);
        ctx.drawImage(userImageElement, 0, 0);
        ctx.restore();
    }
    ctx.restore();
}

// ===================================================================
// –õ–û–ì–ò–ö–ê –≠–ö–°–ü–û–†–¢–ê (–®–ê–ì 5)
// ===================================================================
function generateFinalResultPreview() {
    const previewCanvas = document.getElementById('result-canvas');
    const pCtx = previewCanvas.getContext('2d');
    const previewSize = Math.min(previewCanvas.parentElement.clientWidth, 400);
    previewCanvas.width = previewSize;
    previewCanvas.height = previewSize;
    const slideDiameter = parseFloat(document.getElementById('slideDiameter').value) || 37.5;
    const printDiameter = parseFloat(document.getElementById('printDiameter').value) || 32;
    const printRadiusRatio = printDiameter / slideDiameter;
    pCtx.fillStyle = 'black';
    pCtx.beginPath();
    pCtx.arc(previewSize / 2, previewSize / 2, previewSize / 2, 0, 2 * Math.PI);
    pCtx.fill();
    pCtx.fillStyle = '#1a1a1a';
    pCtx.beginPath();
    pCtx.arc(previewSize / 2, previewSize / 2, (previewSize / 2) * printRadiusRatio, 0, 2 * Math.PI);
    pCtx.fill();
    const cleanImage = getCleanDistortedImage();
    if (!cleanImage) return;
    const fitSize = previewSize * printRadiusRatio;
    const scale = fitSize / Math.max(cleanImage.width, cleanImage.height);
    const w = cleanImage.width * scale;
    const h = cleanImage.height * scale;
    pCtx.drawImage(cleanImage, (previewSize - w) / 2, (previewSize - h) / 2, w, h);
}

function exportFinalGobo() {
    const DPI = parseInt(document.getElementById('printDPI').value);
    const slideMM = parseFloat(document.getElementById('slideDiameter').value);
    const printMM = parseFloat(document.getElementById('printDiameter').value);
    const markText = document.getElementById('alignMark').value;
    if (!DPI || !slideMM || !printMM) { alert("–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–µ—á–∞—Ç–∏."); return; }
    const slidePX = (slideMM / 25.4) * DPI;
    const printPX = (printMM / 25.4) * DPI;
    const finalCanvas = document.createElement('canvas');
    finalCanvas.width = Math.round(slidePX);
    finalCanvas.height = Math.round(slidePX);
    const ctx = finalCanvas.getContext('2d');
    const centerX = finalCanvas.width / 2;
    const centerY = finalCanvas.height / 2;
    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.arc(centerX, centerY, printPX / 2, 0, 2 * Math.PI);
    ctx.fill();
    const cleanDistortedImage = getCleanDistortedImage();
    if (!cleanDistortedImage) { alert("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞."); return; }
    const scaleToFit = printPX / Math.max(cleanDistortedImage.width, cleanDistortedImage.height);
    const w = cleanDistortedImage.width * scaleToFit;
    const h = cleanDistortedImage.height * scaleToFit;
    ctx.drawImage(cleanDistortedImage, centerX - w / 2, centerY - h / 2, w, h);
    if (markText) {
        ctx.fillStyle = 'white';
        ctx.font = `bold ${Math.round(printPX * 0.04)}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const markRadius = (printPX / 2) + ((slidePX - printPX) / 4);
        ctx.fillText(markText, centerX, centerY + markRadius);
    }
    CanvasToTIFF.toTiff(finalCanvas, { dpi: DPI, compression: 'lzw' });
}

function getCleanDistortedImage() {
    if (!userImageElement || !userImageElement.complete) return null;
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const deformationCanvas = document.getElementById('deformation-canvas');
    canvas.width = deformationCanvas.width;
    canvas.height = deformationCanvas.height;
    ctx.save();
    ctx.translate(transformState.x, transformState.y);
    ctx.rotate(transformState.rotation * Math.PI / 180);
    ctx.scale(transformState.scale, transformState.scale);
    const imgW = userImageElement.naturalWidth;
    const imgH = userImageElement.naturalHeight;
    ctx.translate(-imgW / 2, -imgH / 2);
    let sourcePoints = [];
    const numPoints = deformationDestPoints.length;
    for(let i=0; i<numPoints; i++) {
        const angle = (i / numPoints) * 2 * Math.PI - (Math.PI / 2);
        sourcePoints.push({ x: imgW / 2 + (imgW / 2) * Math.cos(angle), y: imgH / 2 + (imgH / 2) * Math.sin(angle) });
    }
    let localDestPoints = deformationDestPoints.map(p => {
        const dx = p.x - transformState.x;
        const dy = p.y - transformState.y;
        const angle = -transformState.rotation * Math.PI / 180;
        const s = transformState.scale;
        return { x: (dx * Math.cos(angle) - dy * Math.sin(angle)) / s + imgW/2, y: (dx * Math.sin(angle) + dy * Math.cos(angle)) / s + imgH/2 };
    });
    const delaunay = Delaunator.from(localDestPoints.map(p => [p.x, p.y]));
    for (let i = 0; i < delaunay.triangles.length; i += 3) {
        const t = [delaunay.triangles[i], delaunay.triangles[i+1], delaunay.triangles[i+2]];
        const src = t.map(p => sourcePoints[p]);
        const dst = t.map(p => localDestPoints[p]);
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(dst[0].x, dst[0].y); ctx.lineTo(dst[1].x, dst[1].y); ctx.lineTo(dst[2].x, dst[2].y);
        ctx.closePath();
        ctx.clip();
        const det = src[0].x * (src[1].y - src[2].y) + src[1].x * (src[2].y - src[0].y) + src[2].x * (src[0].y - src[1].y);
        if (Math.abs(det) < 1e-9) { ctx.restore(); continue; }
        const a = (dst[0].x * (src[1].y - src[2].y) + dst[1].x * (src[2].y - src[0].y) + dst[2].x * (src[0].y - src[1].y)) / det;
        const b = (dst[0].y * (src[1].y - src[2].y) + dst[1].y * (src[2].y - src[0].y) + dst[2].y * (src[0].y - src[1].y)) / det;
        const c = (dst[0].x * (src[2].x - src[1].x) + dst[1].x * (src[0].x - src[2].x) + dst[2].x * (src[1].x - src[0].x)) / det;
        const d = (dst[0].y * (src[2].x - src[1].x) + dst[1].y * (src[0].x - src[2].x) + dst[2].y * (src[1].x - src[0].x)) / det;
        const e = dst[0].x - a * src[0].x - c * src[0].y;
        const f = dst[0].y - b * src[0].x - d * src[0].y;
        ctx.transform(a, b, c, d, e, f);
        ctx.drawImage(userImageElement, 0, 0);
        ctx.restore();
    }
    ctx.restore();
    return canvas;
}
</script>
</body>
</html>
