<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Профессиональный редактор-калькулятор для гобо v1.5</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/delaunator@5.0.0/delaunator.min.js"></script>
    <style>
        .canvas-container {
            position: relative;
            border: 2px solid #374151;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .canvas-container canvas {
            display: block;
            cursor: crosshair;
        }
        
        .magnifier {
            position: fixed; /* Изменено на fixed для лучшего позиционирования */
            width: 120px;
            height: 120px;
            border: 2px solid #3B82F6;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5); /* Полупрозрачный фон */
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            pointer-events: none;
            z-index: 1000;
            display: none;
            overflow: hidden; /* Обрезаем содержимое по кругу */
        }
        
        .magnifier canvas {
            width: 100%; /* Убрал фиксированные размеры, чтобы заполнял родителя */
            height: 100%;
            border-radius: 50%;
        }
        
        .point-marker {
            position: absolute;
            width: 16px;
            height: 16px;
            border: 2px solid white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: move;
            z-index: 100;
            font-size: 10px;
            color: white;
            text-align: center;
            line-height: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .point-marker:hover {
            transform: translate(-50%, -50%) scale(1.2);
        }
        
        .panel-header {
            background: linear-gradient(135deg, #1E40AF, #3B82F6);
            color: white;
            padding: 12px;
            border-radius: 8px 8px 0 0;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .status-ready { color: #10B981; }
        .status-working { color: #F59E0B; }
        .status-error { color: #EF4444; }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen">
    <div class="container mx-auto px-4 py-6">
        <div class="text-center mb-8">
            <h1 class="text-3xl font-bold text-blue-400 mb-2">
                <i class="fas fa-image mr-2"></i>
                Профессиональный редактор-калькулятор для гобо
            </h1>
            <p class="text-gray-400">Версия 1.5 (финальная) - Кусочно-аффинные преобразования с двухслойным предпросмотром</p>
        </div>
        <div class="flex flex-wrap justify-center gap-4 mb-8">
            <button id="loadTemplate" class="bg-blue-600 hover:bg-blue-700 px-6 py-3 rounded-lg font-semibold transition-colors">
                <i class="fas fa-image mr-2"></i>Загрузить фото-шаблон
            </button>
            <button id="loadSource" class="bg-green-600 hover:bg-green-700 px-6 py-3 rounded-lg font-semibold transition-colors">
                <i class="fas fa-upload mr-2"></i>Загрузить изображение
            </button>
            <button id="clearPoints" class="bg-red-600 hover:bg-red-700 px-6 py-3 rounded-lg font-semibold transition-colors">
                <i class="fas fa-trash mr-2"></i>Очистить точки
            </button>
            <button id="exportBtn" class="bg-purple-600 hover:bg-purple-700 px-6 py-3 rounded-lg font-semibold transition-colors">
                <i class="fas fa-download mr-2"></i>Экспорт
            </button>
        </div>
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">
            <div class="bg-gray-800 rounded-lg overflow-hidden">
                <div class="panel-header">
                    <i class="fas fa-image-portrait"></i>
                    <span>Исходное изображение</span>
                </div>
                <div class="p-4">
                    <p class="text-sm text-gray-400 mb-4">Кликните по ключевым точкам фигуры</p>
                    <div class="canvas-container relative">
                        <canvas id="sourceCanvas" width="300" height="400"></canvas>
                        <div id="sourceMagnifier" class="magnifier">
                            <canvas width="116" height="116"></canvas>
                        </div>
                    </div>
                    <div class="mt-2 text-center">
                        <span class="text-sm">Точек источника: <span id="sourceCount" class="font-bold text-blue-400">0</span></span>
                    </div>
                </div>
            </div>
            <div class="bg-gray-800 rounded-lg overflow-hidden">
                <div class="panel-header">
                    <i class="fas fa-crosshairs"></i>
                    <span>Фото-шаблон</span>
                </div>
                <div class="p-4">
                    <p class="text-sm text-gray-400 mb-4">Кликните по размеченным точкам в том же порядке</p>
                    <div class="canvas-container relative">
                        <canvas id="templateCanvas" width="300" height="400"></canvas>
                        <div id="templateMagnifier" class="magnifier">
                            <canvas width="116" height="116"></canvas>
                        </div>
                    </div>
                    <div class="mt-2 text-center">
                        <span class="text-sm">Точек цели: <span id="targetCount" class="font-bold text-green-400">0</span></span>
                    </div>
                </div>
            </div>
            <div class="bg-gray-800 rounded-lg overflow-hidden">
                <div class="panel-header">
                    <i class="fas fa-eye"></i>
                    <span>Предпросмотр деформации</span>
                </div>
                <div class="p-4">
                    <p class="text-sm text-gray-400 mb-4">Real-time результат деформации</p>
                    <div class="canvas-container">
                        <canvas id="previewCanvas" width="300" height="400"></canvas>
                    </div>
                    <div class="mt-2 text-center">
                        <span class="text-sm">Статус: <span id="previewStatus" class="font-bold status-ready">Готово к экспорту</span></span>
                    </div>
                </div>
            </div>
        </div>
        <div class="bg-gray-800 rounded-lg p-6">
            <h3 class="text-xl font-bold text-yellow-400 mb-4">
                <i class="fas fa-info-circle mr-2"></i>
                Инструкция по использованию:
            </h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm text-gray-300">
                <div>
                    <p class="mb-2">1. Загрузите **фото-шаблон** с размеченными точками</p>
                    <p class="mb-2">2. Загрузите **исходное изображение** для деформации</p>
                    <p class="mb-2">3. Кликните по **ключевым точкам** на исходном изображении (минимум 4 точки)</p>
                    <p class="mb-2">4. Кликните по **соответствующим точкам** на фото-шаблоне в том же порядке</p>
                </div>
                <div>
                    <p class="mb-2">5. Используйте **экранную лупу** для точного позиционирования</p>
                    <p class="mb-2">6. **Перетаскивайте** точки для финальной подгонки</p>
                    <p class="mb-2">7. Наблюдайте **real-time деформацию** в окне предпросмотра</p>
                    <p class="mb-2">8. Нажмите "**Экспорт**" для создания готового файла гобо</p>
                </div>
            </div>
        </div>
    </div>
    <input type="file" id="templateInput" accept="image/*" style="display: none;">
    <input type="file" id="sourceInput" accept="image/*" style="display: none;">
    <div id="exportModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" style="display: none;">
        <div class="bg-gray-800 p-8 rounded-lg max-w-md w-full mx-4">
            <h3 class="text-xl font-bold mb-6 text-center">Параметры экспорта</h3>
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium mb-2">Физический диаметр гобо (мм):</label>
                    <input type="number" id="diameterInput" value="50" min="10" max="500" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-2">Требуемое разрешение (DPI):</label>
                    <input type="number" id="dpiInput" value="2700" min="300" max="5000" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white">
                </div>
                <div class="flex space-x-4 pt-4">
                    <button id="confirmExport" class="flex-1 bg-purple-600 hover:bg-purple-700 py-2 px-4 rounded-md font-semibold transition-colors">
                        <i class="fas fa-download mr-2"></i>Сохранить
                    </button>
                    <button id="cancelExport" class="flex-1 bg-gray-600 hover:bg-gray-700 py-2 px-4 rounded-md font-semibold transition-colors">
                        Отмена
                    </button>
                </div>
            </div>
        </div>
    </div>
    <script>
        class GoboEditor {
            constructor() {
                this.sourcePoints = [];
                this.targetPoints = [];
                this.sourceImage = null;
                this.templateImage = null;
                this.isDragging = false;
                this.dragPoint = null;
                this.dragCanvas = null;
                this.currentDeformationData = null; 
                
                this.initCanvases();
                this.bindEvents();
            }

            initCanvases() {
                this.sourceCanvas = document.getElementById('sourceCanvas');
                this.templateCanvas = document.getElementById('templateCanvas');
                this.previewCanvas = document.getElementById('previewCanvas');
                
                this.sourceCtx = this.sourceCanvas.getContext('2d');
                this.templateCtx = this.templateCanvas.getContext('2d');
                this.previewCtx = this.previewCanvas.getContext('2d');
                
                this.sourceMagnifier = document.getElementById('sourceMagnifier');
                this.templateMagnifier = document.getElementById('templateMagnifier');
                this.sourceMagCtx = this.sourceMagnifier.querySelector('canvas').getContext('2d');
                this.templateMagCtx = this.templateMagnifier.querySelector('canvas').getContext('2d');
            }

            bindEvents() {
                document.getElementById('loadTemplate').addEventListener('click', () => {
                    document.getElementById('templateInput').click();
                });
                
                document.getElementById('loadSource').addEventListener('click', () => {
                    document.getElementById('sourceInput').click();
                });
                
                document.getElementById('templateInput').addEventListener('change', (e) => {
                    this.loadImage(e.target.files[0], 'template');
                });
                
                document.getElementById('sourceInput').addEventListener('change', (e) => {
                    this.loadImage(e.target.files[0], 'source');
                });

                document.getElementById('clearPoints').addEventListener('click', () => {
                    this.clearAllPoints();
                });

                document.getElementById('exportBtn').addEventListener('click', () => {
                    document.getElementById('exportModal').style.display = 'flex';
                });
                
                document.getElementById('confirmExport').addEventListener('click', () => {
                    this.exportGobo();
                });
                
                document.getElementById('cancelExport').addEventListener('click', () => {
                    document.getElementById('exportModal').style.display = 'none';
                });

                this.bindCanvasEvents(this.sourceCanvas, 'source');
                this.bindCanvasEvents(this.templateCanvas, 'template');
            }

            bindCanvasEvents(canvas, type) {
                const magnifier = type === 'source' ? this.sourceMagnifier : this.templateMagnifier;
                
                canvas.addEventListener('mousemove', (e) => {
                    magnifier.style.left = (e.clientX + 20) + 'px'; 
                    magnifier.style.top = (e.clientY - 60) + 'px'; 
                    magnifier.style.display = 'block';

                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    this.updateMagnifier(x, y, canvas, type);

                    if (this.isDragging && this.dragCanvas === canvas) {
                        const points = type === 'source' ? this.sourcePoints : this.targetPoints;
                        if (this.dragPoint !== null && this.dragPoint < points.length) {
                            points[this.dragPoint] = {x, y};
                            if (type === 'source') {
                                this.drawSourceImage();
                            } else {
                                this.drawTemplateImage();
                            }
                            this.updatePreview(); 
                            this.updateCounts();
                        }
                    }
                });
                
                canvas.addEventListener('mouseenter', () => {
                    magnifier.style.display = 'block';
                });
                
                canvas.addEventListener('mouseleave', () => {
                    magnifier.style.display = 'none';
                });
                
                canvas.addEventListener('mousedown', (e) => {
                    this.handleMouseDown(e, canvas, type);
                });
                
                canvas.addEventListener('mouseup', (e) => {
                    if (this.isDragging) {
                        this.isDragging = false;
                        this.dragPoint = null;
                        this.dragCanvas = null;
                        canvas.style.cursor = 'crosshair';
                        this.updatePreview(); 
                    }
                });
                
                canvas.addEventListener('click', (e) => {
                    if (!this.isDragging) { 
                        this.handleCanvasClick(e, canvas, type);
                    }
                });
            }

            loadImage(file, type) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        if (type === 'source') {
                            this.sourceImage = img;
                            this.drawSourceImage();
                        } else {
                            this.templateImage = img;
                            this.drawTemplateImage();
                        }
                        this.updatePreview();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            drawImageScaled(ctx, img, canvasWidth, canvasHeight) {
                if (!img) return;
                
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                
                const scale = Math.min(canvasWidth / img.width, canvasHeight / img.height);
                const width = img.width * scale;
                const height = img.height * scale;
                const x = (canvasWidth - width) / 2;
                const y = (canvasHeight - height) / 2;
                
                ctx.drawImage(img, x, y, width, height);
            }

            drawSourceImage() {
                this.drawImageScaled(this.sourceCtx, this.sourceImage, this.sourceCanvas.width, this.sourceCanvas.height);
                this.drawPoints('source');
            }

            drawTemplateImage() {
                this.drawImageScaled(this.templateCtx, this.templateImage, this.templateCanvas.width, this.templateCanvas.height);
                this.drawPoints('template');
            }

            drawPoints(type) {
                const canvas = type === 'source' ? this.sourceCanvas : this.templateCanvas;
                const ctx = type === 'source' ? this.sourceCtx : this.templateCtx;
                const points = type === 'source' ? this.sourcePoints : this.targetPoints;
                
                // Перерисовываем изображение, чтобы убрать старые точки
                if (type === 'source') {
                    this.drawImageScaled(ctx, this.sourceImage, canvas.width, canvas.height);
                } else {
                    this.drawImageScaled(ctx, this.templateImage, canvas.width, canvas.height);
                }

                points.forEach((point, index) => {
                    // Рисуем точку
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 8, 0, 2 * Math.PI);
                    ctx.fillStyle = index === 0 ? '#EF4444' : '#3B82F6'; 
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Рисуем номер
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText((index + 1).toString(), point.x, point.y);
                });
                
                // Соединяем точки линиями
                if (points.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    for (let i = 1; i < points.length; i++) {
                        ctx.lineTo(points[i].x, points[i].y);
                    }
                    if (points.length > 2) {
                        ctx.closePath();
                    }
                    ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            updateMagnifier(x, y, canvas, type) {
                const magnifier = type === 'source' ? this.sourceMagnifier : this.templateMagnifier;
                const magCtx = type === 'source' ? this.sourceMagCtx : this.templateMagCtx;
                const zoom = 3; 
                const magSize = 116; 
                const halfMagSize = magSize / 2;
                const sourceSize = 20; 
                
                magCtx.clearRect(0, 0, magSize, magSize);
                
                const sx = x - sourceSize;
                const sy = y - sourceSize;
                
                const imageToMagnify = (type === 'source' && this.sourceImage) ? this.sourceCanvas : canvas; // Используем canvas для лупы

                magCtx.drawImage(
                    imageToMagnify, 
                    sx, sy, 
                    sourceSize * 2, sourceSize * 2, 
                    0, 0, 
                    magSize, magSize 
                );
                
                magCtx.strokeStyle = '#EF4444';
                magCtx.lineWidth = 1;
                magCtx.beginPath();
                magCtx.moveTo(halfMagSize, 0);
                magCtx.lineTo(halfMagSize, magSize);
                magCtx.moveTo(0, halfMagSize);
                magCtx.lineTo(magSize, halfMagSize);
                magCtx.stroke();
            }

            handleMouseDown(e, canvas, type) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const points = type === 'source' ? this.sourcePoints : this.targetPoints;
                
                for (let i = 0; i < points.length; i++) {
                    const point = points[i];
                    const distance = Math.sqrt(Math.pow(x - point.x, 2) + Math.pow(y - point.y, 2));
                    if (distance < 15) { 
                        this.isDragging = true;
                        this.dragPoint = i;
                        this.dragCanvas = canvas;
                        canvas.style.cursor = 'grabbing';
                        return;
                    }
                }
            }
            
            handleCanvasClick(e, canvas, type) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const points = type === 'source' ? this.sourcePoints : this.targetPoints;
                
                for (let point of points) {
                    const distance = Math.sqrt(Math.pow(x - point.x, 2) + Math.pow(y - point.y, 2));
                    if (distance < 15) {
                        return; 
                    }
                }
                
                points.push({x, y});
                
                if (type === 'source') {
                    this.drawSourceImage();
                } else {
                    this.drawTemplateImage();
                }
                
                this.updatePreview();
                this.updateCounts();
            }

            clearAllPoints() {
                this.sourcePoints = [];
                this.targetPoints = [];
                this.currentDeformationData = null;
                this.drawSourceImage();
                this.drawTemplateImage();
                this.updatePreview();
                this.updateCounts();
            }

            updateCounts() {
                document.getElementById('sourceCount').textContent = this.sourcePoints.length;
                document.getElementById('targetCount').textContent = this.targetPoints.length;
            }

            updatePreview() {
                this.previewCtx.clearRect(0, 0, this.previewCanvas.width, this.previewCanvas.height);
                
                if (this.templateImage) {
                    this.previewCtx.globalAlpha = 0.7; 
                    this.drawImageScaled(this.previewCtx, this.templateImage, this.previewCanvas.width, this.previewCanvas.height);
                    this.previewCtx.globalAlpha = 1.0;
                }

                if (!this.sourceImage || !this.templateImage || 
                    this.sourcePoints.length < 4 || this.targetPoints.length < 4 ||
                    this.sourcePoints.length !== this.targetPoints.length) {
                    
                    this.currentDeformationData = null;
                    document.getElementById('previewStatus').textContent = 'Добавьте минимум 4 парные точки';
                    document.getElementById('previewStatus').className = 'font-bold status-working';
                    return;
                }

                const virtualCanvas = document.createElement('canvas');
                virtualCanvas.width = this.previewCanvas.width;
                virtualCanvas.height = this.previewCanvas.height;
                const virtualCtx = virtualCanvas.getContext('2d');

                // Передаем this.sourceImage для деформации
                this.renderPiecewiseAffine(virtualCtx, this.sourcePoints, this.targetPoints, this.sourceImage, this.previewCanvas.width, this.previewCanvas.height, 'preview');

                this.currentDeformationData = {
                    sourcePoints: [...this.sourcePoints],
                    targetPoints: [...this.targetPoints],
                    sourceImage: this.sourceImage,
                    // Важно: сохраняем размеры канвасов, на которых были расставлены точки!
                    sourceCanvasWidth: this.sourceCanvas.width,
                    sourceCanvasHeight: this.sourceCanvas.height,
                    previewCanvasWidth: this.previewCanvas.width,
                    previewCanvasHeight: this.previewCanvas.height
                };

                this.previewCtx.drawImage(virtualCanvas, 0, 0);

                document.getElementById('previewStatus').textContent = 'Готово к экспорту';
                document.getElementById('previewStatus').className = 'font-bold status-ready';
            }

            renderPiecewiseAffine(ctx, srcPts, dstPts, sourceImage, targetCanvasWidth, targetCanvasHeight, mode) {
                if (srcPts.length < 3) return;

                // Масштабируем точки, если режим не "preview" (для экспорта)
                let actualSrcPts = srcPts;
                let actualDstPts = dstPts;
                let imageScale = 1;
                let imageOffsetX = 0;
                let imageOffsetY = 0;

                // Если это режим "preview", нам нужно определить, как исходное изображение было масштабировано на sourceCanvas
                // и применить это масштабирование к исходным точкам для Delaunay
                if (mode === 'preview') {
                    const scale = Math.min(
                        this.sourceCanvas.width / sourceImage.width,
                        this.sourceCanvas.height / sourceImage.height
                    );
                    const width = sourceImage.width * scale;
                    const height = sourceImage.height * scale;
                    const xOffset = (this.sourceCanvas.width - width) / 2;
                    const yOffset = (this.sourceCanvas.height - height) / 2;
                    
                    imageScale = scale;
                    imageOffsetX = xOffset;
                    imageOffsetY = yOffset;

                    // Создаем точки в координатах исходного изображения (без смещения канваса)
                    // Это важно для Delaunator, чтобы он строил триангуляцию на реальных пропорциях изображения
                    actualSrcPts = srcPts.map(p => ({
                        x: (p.x - xOffset) / scale,
                        y: (p.y - yOffset) / scale
                    }));
                } else { // Режим "export"
                    // Для экспорта, нам нужно взять исходное изображение как есть,
                    // а точки уже должны быть масштабированы для экспортного канваса
                    // (это происходит в exportGobo перед вызовом)
                    // Здесь imageScale = 1, т.к. sourceImage уже будет "вписано" в exportSourceRenderCanvas
                    // и мы берем его как есть.
                }

                const flatPoints = actualSrcPts.flatMap(p => [p.x, p.y]);
                const delaunay = Delaunator.from(flatPoints);

                const triangles = [];
                for (let i = 0; i < delaunay.triangles.length; i += 3) {
                    triangles.push([
                        delaunay.triangles[i],
                        delaunay.triangles[i + 1],
                        delaunay.triangles[i + 2]
                    ]);
                }
                
                triangles.forEach(triangleIndices => {
                    const [i, j, k] = triangleIndices;
                    
                    // Исходный треугольник (в координатах исходного изображения)
                    const srcTriangleOriginal = [
                        actualSrcPts[i],
                        actualSrcPts[j],
                        actualSrcPts[k]
                    ];
                    
                    // Деформированный треугольник (в координатах целевого канваса)
                    const dstTriangleTarget = [
                        dstPts[i],
                        dstPts[j],
                        dstPts[k]
                    ];
                    
                    this.warpTriangle(ctx, srcTriangleOriginal, dstTriangleTarget, sourceImage, imageScale, imageOffsetX, imageOffsetY);
                });
            }

            warpTriangle(ctx, srcTriangleOriginal, dstTriangleTarget, sourceImage, imageScale, imageOffsetX, imageOffsetY) {
                // Получаем аффинную матрицу, которая преобразует srcTriangleOriginal в dstTriangleTarget
                const matrix = this.getAffineMatrix(srcTriangleOriginal, dstTriangleTarget);
                if (!matrix) return;

                ctx.save();
                ctx.setTransform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
                
                // Обрезаем контекст по целевому треугольнику (в его деформированных координатах)
                ctx.beginPath();
                ctx.moveTo(dstTriangleTarget[0].x, dstTriangleTarget[0].y);
                ctx.lineTo(dstTriangleTarget[1].x, dstTriangleTarget[1].y);
                ctx.lineTo(dstTriangleTarget[2].x, dstTriangleTarget[2].y);
                ctx.closePath();
                ctx.clip(); // Обрезает все последующие рисунки по этой области

                // Рисуем исходное изображение
                // Изображение рисуется с учетом масштаба и смещения, которые были применены при отображении на sourceCanvas
                // Мы хотим, чтобы image.drawImage брал пиксели из исходника,
                // но transform уже делает "растягивание"
                // Поэтому, мы рисуем исходное изображение как есть, а матрица уже делает всю магию.
                ctx.drawImage(sourceImage, imageOffsetX, imageOffsetY, sourceImage.width * imageScale, sourceImage.height * imageScale);
                
                ctx.restore();
            }

            getAffineMatrix(src, dst) {
                const x1 = src[0].x, y1 = src[0].y;
                const x2 = src[1].x, y2 = src[1].y;
                const x3 = src[2].x, y3 = src[2].y;
                
                const u1 = dst[0].x, v1 = dst[0].y;
                const u2 = dst[1].x, v2 = dst[1].y;
                const u3 = dst[2].x, v3 = dst[2].y;
                
                const det = (x1 - x3) * (y2 - y3) - (x2 - x3) * (y1 - y3);
                
                if (Math.abs(det) < 1e-6) {
                    console.warn("Детерминант близок к нулю. Треугольник вырожденный.");
                    return null;
                }
                
                const a = ((u1 - u3) * (y2 - y3) - (u2 - u3) * (y1 - y3)) / det;
                const b = ((x1 - x3) * (u2 - u3) - (x2 - x3) * (u1 - u3)) / det;
                const c = ((v1 - v3) * (y2 - y3) - (v2 - v3) * (y1 - y3)) / det;
                const d = ((x1 - x3) * (v2 - v3) - (x2 - x3) * (v1 - v3)) / det;
                const e = u3 - a * x3 - b * y3;
                const f = v3 - c * x3 - d * y3;
                
                return [a, c, b, d, e, f];
            }

            exportGobo() {
                const diameter = parseFloat(document.getElementById('diameterInput').value);
                const dpi = parseFloat(document.getElementById('dpiInput').value);
                
                if (!diameter || !dpi || diameter <= 0 || dpi <= 0) {
                    alert('Пожалуйста, введите корректные значения для диаметра и DPI');
                    return;
                }

                if (!this.currentDeformationData || !this.currentDeformationData.sourceImage) {
                    alert('Нет данных деформации для экспорта. Убедитесь, что изображения загружены и точки расставлены.');
                    return;
                }
                
                const sizeInInches = diameter / 25.4; 
                const canvasSize = Math.round(sizeInInches * dpi);
                
                const exportCanvas = document.createElement('canvas');
                exportCanvas.width = canvasSize;
                exportCanvas.height = canvasSize;
                const exportCtx = exportCanvas.getContext('2d');
                
                exportCtx.fillStyle = 'black';
                exportCtx.fillRect(0, 0, canvasSize, canvasSize);

                const sourcePointsPreview = this.currentDeformationData.sourcePoints;
                const targetPointsPreview = this.currentDeformationData.targetPoints;
                const sourceImageForExport = this.currentDeformationData.sourceImage;
                const previewCanvasWidth = this.currentDeformationData.previewCanvasWidth;
                const previewCanvasHeight = this.currentDeformationData.previewCanvasHeight;
                const sourceCanvasWidth = this.currentDeformationData.sourceCanvasWidth;
                const sourceCanvasHeight = this.currentDeformationData.sourceCanvasHeight;


                // --- РАСЧЕТ МАСШТАБОВ ДЛЯ ЭКСПОРТА ---
                // 1. Масштаб, с которым исходное изображение было нарисовано на sourceCanvas
                const sourceDisplayScale = Math.min(
                    sourceCanvasWidth / sourceImageForExport.width,
                    sourceCanvasHeight / sourceImageForExport.height
                );
                const sourceDisplayOffsetX = (sourceCanvasWidth - sourceImageForExport.width * sourceDisplayScale) / 2;
                const sourceDisplayOffsetY = (sourceCanvasHeight - sourceImageForExport.height * sourceDisplayScale) / 2;

                // 2. Масштаб, который переводит координаты из previewCanvas в exportCanvas
                const previewToExportScaleX = canvasSize / previewCanvasWidth;
                const previewToExportScaleY = canvasSize / previewCanvasHeight;

                // Масштабируем srcPoints (которые были в координатах sourceCanvas)
                // в "оригинальные" координаты изображения, затем в координаты экспорта
                const scaledSourcePointsForExport = sourcePointsPreview.map(p => ({
                    // Переводим точки из координат sourceCanvas в координаты исходного изображения
                    x: (p.x - sourceDisplayOffsetX) / sourceDisplayScale,
                    y: (p.y - sourceDisplayOffsetY) / sourceDisplayScale
                }));
                
                // Масштабируем targetPoints (которые были в координатах previewCanvas)
                // в координаты exportCanvas
                const scaledTargetPointsForExport = targetPointsPreview.map(p => ({
                    x: p.x * previewToExportScaleX,
                    y: p.y * previewToExportScaleY
                }));

                // Рендерим деформацию для экспорта
                // imageScale, imageOffsetX, imageOffsetY для warpTriangle будут 1, 0, 0
                // потому что Delaunator работает с "оригинальными" координатами изображения,
                // а transform уже будет масштабировать в targetCanvas
                this.renderPiecewiseAffine(exportCtx, scaledSourcePointsForExport, scaledTargetPointsForExport, 
                                            sourceImageForExport, canvasSize, canvasSize, 'export');

                // Обрезаем по кругу
                exportCtx.globalCompositeOperation = 'destination-in';
                exportCtx.beginPath();
                exportCtx.arc(canvasSize / 2, canvasSize / 2, canvasSize / 2, 0, Math.PI * 2);
                exportCtx.fill();
                exportCtx.globalCompositeOperation = 'source-over'; 

                exportCanvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `gobo_${diameter}mm_${dpi}dpi.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    document.getElementById('exportModal').style.display = 'none';
                }, 'image/png');
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new GoboEditor();
        });
    </script>
</body>
</html>
