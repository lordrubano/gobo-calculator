<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>GOBO –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä-–†–µ–¥–∞–∫—Ç–æ—Ä (–ü—Ä–æ–≤–µ—Ä–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#2d3748">
    <style>
        html, body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background: #f0f2f5; color: #1a202c; }
        #app { max-width: 960px; margin: 20px auto; padding: 16px; }
        h1 { text-align: center; margin: 10px 0 20px; color: #2d3748; }
        .step { display: none; background: #fff; padding: 24px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,.08); margin-top: 20px; }
        .step.active { display: block; }
        .progress { display: flex; justify-content: space-between; margin-bottom: 24px; padding: 0; }
        .progress div { flex: 1; text-align: center; font-weight: 600; color: #a0aec0; position: relative; padding-top: 40px; }
        .progress div::before { content: attr(data-n); position: absolute; top: 0; left: 50%; transform: translateX(-50%); width: 32px; height: 32px; margin: 0 auto 8px; border-radius: 50%; line-height: 32px; border: 2px solid #cbd5e0; background: #fff; color: #cbd5e0; font-weight: 700; transition: all 0.3s ease; }
        .progress .active { color: #4a5568; }
        .progress .active::before { border-color: #5a67d8; color: #5a67d8; }
        .progress .done::before { background: #5a67d8; color: #fff; border-color: #5a67d8; }
        #photoZone { border: 3px dashed #cbd5e0; padding: 50px; text-align: center; border-radius: 10px; cursor: pointer; transition: all 0.2s ease; background-color: #f7fafc; }
        #photoZone.dragover { background: #e2e8f0; border-color: #5a67d8; }
        .point { position: absolute; width: 14px; height: 14px; background: #e53e3e; border: 2px solid #fff; border-radius: 50%; transform: translate(-50%, -50%); font-size: 9px; line-height: 10px; text-align: center; color: #fff; font-weight: 700; user-select: none; cursor: grab; box-shadow: 0 0 5px rgba(0,0,0,0.5); }
        .point:active { cursor: grabbing; }
        .layer-container { position: relative; display: inline-block; border: 1px solid #e2e8f0; border-radius: 10px; line-height: 0; overflow: hidden; background: #eee; }
        .layer-container.points-limit-reached { cursor: not-allowed; }
        #bgImg, #bgImg2 { max-width: 100%; display: block; border-radius: 10px; }
        #deformation-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #points-svg { position: absolute; inset: 0; pointer-events: none; }
        .controls { display: flex; flex-wrap: wrap; gap: 12px; margin-top: 16px; align-items: center; }
        .controls label { font-size: 13px; display: flex; align-items: center; gap: 6px; }
        button, input[type="file"], select { padding: 8px 14px; font-size: 14px; border-radius: 6px; border: 1px solid #cbd5e0; background-color: #fff; cursor: pointer; transition: all 0.2s; }
        button:hover, select:hover { border-color: #a0aec0; background-color: #f7fafc; }
        button:disabled { cursor: not-allowed; opacity: 0.6; }
        .hidden { display: none; }
        #goboPreview { height: 200px; border: 2px dashed #cbd5e0; margin: 12px 0; display: flex; align-items: center; justify-content: center; border-radius: 10px; }
    </style>
</head>
<body>
<div id="app">
    <h1>GOBO –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä-–†–µ–¥–∞–∫—Ç–æ—Ä</h1>
    <div class="progress">
        <div id="p1" data-n="1" class="active">–§–æ—Ç–æ</div>
        <div id="p2" data-n="2">–ö–æ–Ω—Ç—É—Ä</div>
        <div id="p3" data-n="3">–ì–æ–±–æ</div>
        <div id="p4" data-n="4">–î–µ—Ñ–æ—Ä–º–∞—Ü–∏—è</div>
        <div id="p5" data-n="5">–≠–∫—Å–ø–æ—Ä—Ç</div>
    </div>

    <section id="s1" class="step active">
        <h2>–®–∞–≥ 1: –ó–∞–≥—Ä—É–∑–∫–∞ —ç—Ç–∞–ª–æ–Ω–Ω–æ–≥–æ —Ñ–æ—Ç–æ</h2>
        <p>–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—é –æ–±—ä–µ–∫—Ç–∞, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–º —Ä–∞–∑–º–µ—á–µ–Ω –∫–æ–Ω—Ç—É—Ä.</p>
        <div id="photoZone">üì∑ –ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ —Ñ–æ—Ç–æ –∏–ª–∏ –∫–ª–∏–∫–Ω–∏—Ç–µ –¥–ª—è –≤—ã–±–æ—Ä–∞</div>
        <input id="photoInput" type="file" accept="image/*" class="hidden">
    </section>

    <section id="s2" class="step">
        <h2>–®–∞–≥ 2: –ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ —Ç–æ—á–µ–∫ –∫–æ–Ω—Ç—É—Ä–∞</h2>
        <p>–ö–ª–∏–∫–Ω–∏—Ç–µ –ø–æ —É–≥–ª–∞–º —Ä–∞–∑–º–µ—á–µ–Ω–Ω–æ–≥–æ –∫–æ–Ω—Ç—É—Ä–∞ (–º–∏–Ω–∏–º—É–º 3, –º–∞–∫—Å–∏–º—É–º 12 —Ç–æ—á–µ–∫).</p>
        <div id="contour-layer" class="layer-container">
            <img id="bgImg">
            <svg id="points-svg"></svg>
        </div>
        <div class="controls">
            <span>–¢–æ—á–µ–∫: <b id="ptCount">0</b>/12</span>
            <button id="undoBtn">‚ü≤ –û—Ç–º–µ–Ω–∏—Ç—å —Ç–æ—á–∫—É</button>
            <button id="clearBtn">–û—á–∏—Å—Ç–∏—Ç—å –≤—Å—ë</button>
            <button id="toStep3" disabled>–î–∞–ª–µ–µ ‚Üí</button>
        </div>
    </section>

    <section id="s3" class="step">
        <h2>–®–∞–≥ 3: –ó–∞–≥—Ä—É–∑–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø—Ä–æ–µ–∫—Ü–∏–∏</h2>
        <p>–ó–∞–≥—Ä—É–∑–∏—Ç–µ –ª–æ–≥–æ—Ç–∏–ø –∏–ª–∏ —Ä–∏—Å—É–Ω–æ–∫ –¥–ª—è –ø—Ä–æ–µ–∫—Ü–∏–∏ (—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è PNG —Å –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–º —Ñ–æ–Ω–æ–º).</p>
        <input id="goboInput" type="file" accept="image/png, image/jpeg">
        <div id="goboPreview"><span>–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä...</span></div>
        <button id="toStep4" disabled>–î–∞–ª–µ–µ ‚Üí</button>
    </section>

    <section id="s4" class="step">
        <h2>–®–∞–≥ 4: –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏—è</h2>
        <p>–ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–π—Ç–µ –∫—Ä–∞—Å–Ω—ã–µ –º–∞—Ä–∫–µ—Ä—ã, —á—Ç–æ–±—ã —Ç–æ—á–Ω–æ –ø–æ–¥–æ–≥–Ω–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ –∫–æ–Ω—Ç—É—Ä—É.</p>
        <div id="edit-layer" class="layer-container">
            <img id="bgImg2">
            <canvas id="deformation-canvas"></canvas>
        </div>
        <div class="controls">
            <label>–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å <input type="range" id="opacity" min="0" max="1" step="0.01" value="0.7"></label>
            <button id="toggleVis">üëÅ –°–∫—Ä—ã—Ç—å</button>
            <button id="saveBtn">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
            <button id="loadBtn">üìÇ –û—Ç–∫—Ä—ã—Ç—å</button>
            <button id="helpBtn">‚ùî –ü–æ–º–æ—â—å</button>
            <button id="toStep5">–î–∞–ª–µ–µ ‚Üí</button>
        </div>
    </section>

    <section id="s5" class="step">
        <h2>–®–∞–≥ 5: –ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –∏ —ç–∫—Å–ø–æ—Ä—Ç</h2>
        <label>–ü—Ä–µ—Å–µ—Ç –¥–ª—è –ø–µ—á–∞—Ç–∏:
            <select id="preset">
                <option value="32,2700,3401">–°—Ç–µ–∫–ª–æ 32 –º–º / 2700 DPI</option>
                <option value="42,1500,2480">–°–ª–∞–π–¥ 42 –º–º / 1500 DPI</option>
                <option value="50,600,1181">–°–ª–∞–π–¥ 50 –º–º / 600 DPI</option>
            </select>
        </label>
        <p>–ò—Ç–æ–≥–æ–≤—ã–π —Ä–∞–∑–º–µ—Ä: <b id="export-size">3401 x 3401 px</b></p>
        <div class="controls">
            <button id="exportPng">üì§ –≠–∫—Å–ø–æ—Ä—Ç –≤ PNG</button>
            <button id="exportTif">üì§ –≠–∫—Å–ø–æ—Ä—Ç –≤ TIFF (–¥–ª—è —Ç–∏–ø–æ–≥—Ä–∞—Ñ–∏–π)</button>
        </div>
        <canvas id="preview-canvas" style="margin-top:12px; border:1px solid #e2e8f0; max-width: 300px;"></canvas>
    </section>
</div>

<script src="https://unpkg.com/delaunator@5.0.0/delaunator.min.js"></script>
<script src="https://unpkg.com/canvastotiff@1.0.0/canvas-to-tiff.min.js"></script>
<script>
function startTour() {
    const steps = [
        {el: '#photoZone', msg: '–®–∞–≥ 1: –ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ —Å—é–¥–∞ —Ñ–æ—Ç–æ –æ–±—ä–µ–∫—Ç–∞ —Å —Ä–∞–∑–º–µ—á–µ–Ω–Ω—ã–º –∫–æ–Ω—Ç—É—Ä–æ–º.'},
        {el: '#contour-layer', msg: '–®–∞–≥ 2: –ö–ª–∏–∫–Ω–∏—Ç–µ –ø–æ —É–≥–ª–∞–º –∫–æ–Ω—Ç—É—Ä–∞, —á—Ç–æ–±—ã —Ä–∞—Å—Å—Ç–∞–≤–∏—Ç—å —Ç–æ—á–∫–∏ (–¥–æ 12).'},
        {el: '#goboInput', msg: '–®–∞–≥ 3: –ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –ø—Ä–æ–µ–∫—Ü–∏–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ª–æ–≥–æ—Ç–∏–ø).'},
        {el: '#edit-layer', msg: '–®–∞–≥ 4: –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–π—Ç–µ –º–∞—Ä–∫–µ—Ä—ã, —á—Ç–æ–±—ã —Ç–æ—á–Ω–æ –ø–æ–¥–æ–≥–Ω–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ –∫–æ–Ω—Ç—É—Ä—É.'},
        {el: '#preset', msg: '–®–∞–≥ 5: –í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–¥—Ö–æ–¥—è—â–∏–π –ø—Ä–µ—Å–µ—Ç –¥–ª—è –ø–µ—á–∞—Ç–∏.'},
        {el: '#exportPng', msg: '–ù–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã —Å–∫–∞—á–∞—Ç—å –≥–æ—Ç–æ–≤—ã–π —Ñ–∞–π–ª –≤ –≤—ã—Å–æ–∫–æ–º –∫–∞—á–µ—Å—Ç–≤–µ.'}
    ];
    let i = 0;
    const ovl = document.createElement('div');
    ovl.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,.7);z-index:9999;color:#fff;padding:20px;font:16px sans-serif;display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;';
    const box = document.createElement('div');
    box.style.cssText = 'position:absolute;border:3px solid #fff;border-radius:8px;box-shadow:0 0 20px #fff;transition:all 0.4s ease-in-out;pointer-events:none;';
    
    function show() {
        if (i >= steps.length) { ovl.remove(); return; }
        const s = steps[i];
        const targetEl = document.querySelector(s.el);
        if (!targetEl) { i++; show(); return; }
        
        targetEl.scrollIntoView({behavior: 'smooth', block: 'center'});
        
        setTimeout(() => {
            const r = targetEl.getBoundingClientRect();
            box.style.left = `${r.left - 5}px`;
            box.style.top = `${r.top - 5}px`;
            box.style.width = `${r.width + 10}px`;
            box.style.height = `${r.height + 10}px`;
            
            ovl.innerHTML = `<p style="max-width:350px;margin-bottom:20px;">${s.msg}</p><button>–î–∞–ª—å—à–µ</button>`;
            ovl.querySelector('button').onclick = () => { i++; show(); };
        }, 400);
    }
    
    document.body.append(ovl);
    ovl.append(box);
    show();
}
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const $ = q => document.querySelector(q);
    const $$ = q => document.querySelectorAll(q);

    // ----- –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ -----
    let currentStep = 1;
    let bgPhotoData = null;
    let projectionImage = new Image();
    let contourPoints = []; // {x, y, element}
    let controlPoints = []; // {x, y, element} - –¥–ª—è —à–∞–≥–∞ 4
    let opacity = 0.7;
    let historyStack = [];

    const MAX_POINTS = 12;

    const canvas = $('#deformation-canvas');
    const ctx = canvas.getContext('2d');

    // ----- –ù–∞–≤–∏–≥–∞—Ü–∏—è –ø–æ —à–∞–≥–∞–º -----
    function goToStep(n) {
        $(`#s${currentStep}`).classList.remove('active');
        $(`#p${currentStep}`).classList.remove('active');
        if (n > currentStep) {
            $(`#p${currentStep}`).classList.add('done');
        }
        currentStep = n;
        $(`#s${currentStep}`).classList.add('active');
        $(`#p${currentStep}`).classList.add('active');
    }

    // ----- –®–∞–≥ 1: –ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–æ—Ç–æ -----
    const photoZone = $('#photoZone');
    const photoInput = $('#photoInput');
    photoZone.onclick = () => photoInput.click();
    ['dragover', 'dragleave', 'drop'].forEach(eventName => {
        photoZone.addEventListener(eventName, e => {
            e.preventDefault();
            e.stopPropagation();
            if (eventName === 'dragover') photoZone.classList.add('dragover');
            if (eventName === 'dragleave' || eventName === 'drop') photoZone.classList.remove('dragover');
            if (eventName === 'drop') loadPhoto(e.dataTransfer.files[0]);
        });
    });
    photoInput.onchange = e => loadPhoto(e.target.files[0]);

    function loadPhoto(file) {
        if (!file || !file.type.startsWith('image/')) {
            alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è.');
            return;
        }
        const reader = new FileReader();
        reader.onload = e => {
            const img = new Image();
            img.onload = () => {
                const MAX_DIM = 2000;
                if (img.width > MAX_DIM || img.height > MAX_DIM) {
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    const ratio = Math.max(img.width, img.height) / MAX_DIM;
                    tempCanvas.width = img.width / ratio;
                    tempCanvas.height = img.height / ratio;
                    tempCtx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);
                    bgPhotoData = tempCanvas.toDataURL('image/jpeg', 0.9);
                    alert(`–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –±—ã–ª–æ —É–º–µ–Ω—å—à–µ–Ω–æ –¥–æ ${tempCanvas.width}x${tempCanvas.height}px –¥–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è —Ä–∞–±–æ—Ç—ã.`);
                } else {
                    bgPhotoData = e.target.result;
                }
                $('#bgImg').src = bgPhotoData;
                $('#bgImg2').src = bgPhotoData;
                goToStep(2);
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }

    // ----- –®–∞–≥ 2: –ö–æ–Ω—Ç—É—Ä -----
    const contourLayer = $('#contour-layer');
    const pointsSvg = $('#points-svg');

    contourLayer.addEventListener('click', e => {
        if (contourPoints.length >= MAX_POINTS) {
            alert(`–î–æ—Å—Ç–∏–≥–Ω—É—Ç –ª–∏–º–∏—Ç –≤ ${MAX_POINTS} —Ç–æ—á–µ–∫.`);
            return;
        }
        saveToHistory();
        const rect = contourLayer.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const pointEl = document.createElement('div');
        pointEl.className = 'point';
        pointEl.textContent = contourPoints.length + 1;
        pointEl.style.left = `${x}px`;
        pointEl.style.top = `${y}px`;
        contourLayer.appendChild(pointEl);
        
        contourPoints.push({ x, y, element: pointEl });
        updateContourUI();
    });

    function updateContourUI() {
        $('#ptCount').textContent = contourPoints.length;
        $('#toStep3').disabled = contourPoints.length < 3;
        if (contourPoints.length >= MAX_POINTS) {
            contourLayer.classList.add('points-limit-reached');
        } else {
            contourLayer.classList.remove('points-limit-reached');
        }
        drawPolyline();
    }
    
    function drawPolyline() {
        pointsSvg.innerHTML = '';
        if (contourPoints.length < 2) return;
        const d = contourPoints.map((p, i) => `${i === 0 ? 'M' : 'L'}${p.x} ${p.y}`).join(' ') + (contourPoints.length > 2 ? ' Z' : '');
        pointsSvg.innerHTML = `<path d="${d}" stroke="#e53e3e" stroke-width="2" fill="rgba(229, 62, 62, 0.2)" />`;
    }

    $('#clearBtn').onclick = () => {
        saveToHistory();
        contourPoints.forEach(p => p.element.remove());
        contourPoints = [];
        updateContourUI();
    };
    $('#undoBtn').onclick = restoreFromHistory;
    $('#toStep3').onclick = () => goToStep(3);

    // ----- –®–∞–≥ 3: –ü—Ä–æ–µ–∫—Ü–∏—è -----
    $('#goboInput').onchange = e => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = e => {
            projectionImage = new Image();
            projectionImage.onload = () => {
                $('#goboPreview').innerHTML = `<img src="${e.target.result}" style="max-height:180px; max-width:100%;">`;
                $('#toStep4').disabled = false;
            };
            projectionImage.src = e.target.result;
        };
        reader.readAsDataURL(file);
    };
    $('#toStep4').onclick = () => {
        setupDeformationStep();
        goToStep(4);
    };

    // ----- –®–∞–≥ 4: –î–µ—Ñ–æ—Ä–º–∞—Ü–∏—è -----
    function setupDeformationStep() {
        const bgImg = $('#bgImg2');
        canvas.width = bgImg.naturalWidth;
        canvas.height = bgImg.naturalHeight; // –ò–°–ü–†–ê–í–õ–ï–ù–ê –û–®–ò–ë–ö–ê –ó–î–ï–°–¨

        // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ —Ç–æ—á–∫–∏ –∏–∑ DOM
        $$('#edit-layer .point').forEach(p => p.remove());
        controlPoints = [];

        // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–µ —É–ø—Ä–∞–≤–ª—è—é—â–∏–µ —Ç–æ—á–∫–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–æ–Ω—Ç—É—Ä–Ω—ã—Ö
        contourPoints.forEach((p, i) => {
            const controlPointEl = document.createElement('div');
            controlPointEl.className = 'point';
            controlPointEl.textContent = i + 1;
            controlPointEl.style.left = `${p.x}px`;
            controlPointEl.style.top = `${p.y}px`;
            $('#edit-layer').appendChild(controlPointEl);
            
            const cp = { x: p.x, y: p.y, element: controlPointEl };
            controlPoints.push(cp);

            // –î–æ–±–∞–≤–ª—è–µ–º –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ
            let isDragging = false;
            controlPointEl.addEventListener('pointerdown', e => {
                isDragging = true;
                e.target.setPointerCapture(e.pointerId);
                e.target.style.cursor = 'grabbing';
            });
            controlPointEl.addEventListener('pointerup', e => {
                isDragging = false;
                e.target.releasePointerCapture(e.pointerId);
                e.target.style.cursor = 'grab';
            });
            controlPointEl.addEventListener('pointermove', e => {
                if (!isDragging) return;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;

                const newX = (e.clientX - rect.left) * scaleX;
                const newY = (e.clientY - rect.top) * scaleY;

                cp.x = newX;
                cp.y = newY;

                controlPointEl.style.left = `${newX / scaleX}px`;
                controlPointEl.style.top = `${newY / scaleY}px`;

                drawDeformedImage(canvas, ctx, projectionImage, controlPoints);
            });
        });
        
        $('#opacity').value = opacity;
        drawDeformedImage(canvas, ctx, projectionImage, controlPoints);
    }
    
    // --- –û—Å–Ω–æ–≤–Ω–∞—è –ª–æ–≥–∏–∫–∞: –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Å —Ç—Ä–∏–∞–Ω–≥—É–ª—è—Ü–∏–µ–π ---
    function drawDeformedImage(targetCanvas, targetCtx, img, destPoints, highQuality = false) {
        targetCtx.clearRect(0, 0, targetCanvas.width, targetCanvas.height);
        if (destPoints.length < 3 || !img.width) return;

        // –ò—Å—Ö–æ–¥–Ω—ã–µ —Ç–æ—á–∫–∏ - —É–≥–ª—ã –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø—Ä–æ–µ–∫—Ü–∏–∏
        const srcPoints = [
            { x: 0, y: 0 },
            { x: img.width, y: 0 },
            { x: img.width, y: img.height },
            { x: 0, y: img.height }
        ];
        
        // –î–ª—è —á–µ—Ç—ã—Ä–µ—Ö—É–≥–æ–ª—å–Ω–∏–∫–∞ –¥–æ–±–∞–≤–ª—è–µ–º —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω—É—é —Ç–æ—á–∫—É –¥–ª—è –±–æ–ª–µ–µ –ø–ª–∞–≤–Ω–æ–π –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏–∏
        if (destPoints.length === 4) {
             srcPoints.push({ x: img.width / 2, y: img.height / 2 });
             const destBbox = getBoundingBox(destPoints);
             destPoints.push({x: destBbox.cx, y: destBbox.cy });
        }

        const delaunay = Delaunator.from(destPoints.map(p => [p.x, p.y]));
        const triangles = delaunay.triangles;

        targetCtx.save();
        targetCtx.globalAlpha = highQuality ? 1.0 : opacity;

        for (let i = 0; i < triangles.length; i += 3) {
            const p0_idx = triangles[i];
            const p1_idx = triangles[i+1];
            const p2_idx = triangles[i+2];

            const p0 = destPoints[p0_idx];
            const p1 = destPoints[p1_idx];
            const p2 = destPoints[p2_idx];

            const s0 = srcPoints[p0_idx];
            const s1 = srcPoints[p1_idx];
            const s2 = srcPoints[p2_idx];

            if (!p0 || !p1 || !p2 || !s0 || !s1 || !s2) continue;
            
            // –ê—Ñ—Ñ–∏–Ω–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞
            targetCtx.save();
            targetCtx.beginPath();
            targetCtx.moveTo(p0.x, p0.y);
            targetCtx.lineTo(p1.x, p1.y);
            targetCtx.lineTo(p2.x, p2.y);
            targetCtx.closePath();
            targetCtx.clip();

            const delta = s1.x * s2.y + s0.x * s1.y + s2.x * s0.y - s1.x * s0.y - s2.x * s1.y - s0.x * s2.y;
            if (Math.abs(delta) < 1e-9) {targetCtx.restore(); continue;}

            const A = (p1.x * s2.y + p0.x * s1.y + p2.x * s0.y - p1.x * s0.y - p2.x * s1.y - p0.x * s2.y) / delta;
            const B = (p1.y * s2.y + p0.y * s1.y + p2.y * s0.y - p1.y * s0.y - p2.y * s1.y - p0.y * s2.y) / delta;
            const C = (p1.x * s0.x + p0.x * s2.x + p2.x * s1.x - p1.x * s2.x - p2.x * s0.x - p0.x * s1.x) / delta;
            const D = (p1.y * s0.x + p0.y * s2.x + p2.y * s1.x - p1.y * s2.x - p2.y * s0.x - p0.y * s1.x) / delta;
            const E = (p1.x * (s2.x * s0.y - s0.x * s2.y) + p0.x * (s1.x * s2.y - s2.x * s1.y) + p2.x * (s0.x * s1.y - s1.x * s0.y)) / delta;
            const F = (p1.y * (s2.x * s0.y - s0.x * s2.y) + p0.y * (s1.x * s2.y - s2.x * s1.y) + p2.y * (s0.x * s1.y - s1.x * s0.y)) / delta;

            targetCtx.transform(A, B, C, D, E, F);
            targetCtx.drawImage(img, 0, 0);
            targetCtx.restore();
        }
        targetCtx.restore();
         if (destPoints.length === 5) destPoints.pop(); // —É–±–∏—Ä–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—É—é —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω—É—é —Ç–æ—á–∫—É
    }

    function getBoundingBox(points) {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        points.forEach(p => {
            minX = Math.min(minX, p.x); minY = Math.min(minY, p.y);
            maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y);
        });
        const w = maxX - minX;
        const h = maxY - minY;
        return { cx: minX + w / 2, cy: minY + h / 2, w, h };
    }

    $('#opacity').oninput = e => { opacity = +e.target.value; drawDeformedImage(canvas, ctx, projectionImage, controlPoints); };
    $('#toggleVis').onclick = () => {
        const isVisible = canvas.style.visibility !== 'hidden';
        canvas.style.visibility = isVisible ? 'hidden' : 'visible';
        $('#toggleVis').textContent = isVisible ? 'üëÅ –ü–æ–∫–∞–∑–∞—Ç—å' : 'üëÅ –°–∫—Ä—ã—Ç—å';
    };
    $('#toStep5').onclick = () => {
        generatePreview();
        goToStep(5);
    };
    $('#saveBtn').onclick = saveProject;
    $('#loadBtn').onclick = loadProject;
    $('#helpBtn').onclick = startTour;

    // ----- –ò—Å—Ç–æ—Ä–∏—è –¥–µ–π—Å—Ç–≤–∏–π (Undo) -----
    function saveToHistory() {
        historyStack.push(JSON.stringify(contourPoints.map(p => ({ x: p.x, y: p.y }))));
    }
    function restoreFromHistory() {
        if (historyStack.length === 0) return;
        const lastState = JSON.parse(historyStack.pop());
        contourPoints.forEach(p => p.element.remove());
        contourPoints = [];
        lastState.forEach((p, i) => {
            const pointEl = document.createElement('div');
            pointEl.className = 'point';
            pointEl.textContent = i + 1;
            pointEl.style.left = `${p.x}px`;
            pointEl.style.top = `${p.y}px`;
            contourLayer.appendChild(pointEl);
            contourPoints.push({ x: p.x, y: p.y, element: pointEl });
        });
        updateContourUI();
    }

    // ----- –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ / –ó–∞–≥—Ä—É–∑–∫–∞ -----
    function saveProject() {
        const projectData = {
            bgPhoto: bgPhotoData,
            projectionSrc: projectionImage.src,
            contour: contourPoints.map(p => ({ x: p.x, y: p.y })),
        };
        const blob = new Blob([JSON.stringify(projectData)], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'gobo-project.json';
        a.click();
        URL.revokeObjectURL(a.href);
    }
    function loadProject() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json,application/json';
        input.onchange = e => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = ev => {
                const data = JSON.parse(ev.target.result);
                bgPhotoData = data.bgPhoto;
                projectionImage.src = data.projectionSrc;
                contourPoints = data.contour.map(p => ({...p}));
                
                projectionImage.onload = () => {
                    $('#bgImg').src = bgPhotoData;
                    $('#bgImg2').src = bgPhotoData;
                    $('#goboPreview').innerHTML = `<img src="${projectionImage.src}" style="max-height:180px; max-width:100%;">`;
                    $('#toStep4').disabled = false;
                    setupDeformationStep();
                    goToStep(4);
                };
            };
            reader.readAsText(file);
        };
        input.click();
    }
    
    // ----- –®–∞–≥ 5: –≠–∫—Å–ø–æ—Ä—Ç -----
    const presetSelect = $('#preset');
    presetSelect.onchange = generatePreview;

    function generatePreview() {
        const [, , size] = presetSelect.value.split(',').map(Number);
        $('#export-size').textContent = `${size} x ${size} px`;
        const previewCanvas = $('#preview-canvas');
        const pctx = previewCanvas.getContext('2d');
        const previewSize = Math.min(300, size);
        previewCanvas.width = previewSize;
        previewCanvas.height = previewSize;
        
        pctx.fillStyle = '#000';
        pctx.fillRect(0, 0, previewSize, previewSize);
        pctx.drawImage(canvas, 0, 0, previewSize, previewSize);
        pctx.globalCompositeOperation = 'destination-in';
        pctx.beginPath();
        pctx.arc(previewSize / 2, previewSize / 2, previewSize / 2, 0, 2 * Math.PI);
        pctx.fill();
        pctx.globalCompositeOperation = 'source-over';
    }

    $('#exportPng').onclick = () => exportFinalImage('png');
    $('#exportTif').onclick = () => exportFinalImage('tiff');

    function exportFinalImage(format) {
        const [dmm, dpi, px] = presetSelect.value.split(',').map(Number);
        
        const exportCanvas = document.createElement('canvas');
        exportCanvas.width = px;
        exportCanvas.height = px;
        const exportCtx = exportCanvas.getContext('2d');

        const bgImgEl = $('#bgImg2');
        const scaleFactor = px / bgImgEl.naturalWidth;
        const scaledControlPoints = controlPoints.map(p => ({ x: p.x * scaleFactor, y: p.y * scaleFactor }));

        drawDeformedImage(exportCanvas, exportCtx, projectionImage, scaledControlPoints, true);

        exportCtx.globalCompositeOperation = 'destination-in';
        exportCtx.fillStyle = '#000';
        exportCtx.beginPath();
        exportCtx.arc(px / 2, px / 2, px / 2, 0, 2 * Math.PI);
        exportCtx.fill();
        exportCtx.globalCompositeOperation = 'source-over';
        
        const filename = `projection_${dmm}mm_${dpi}dpi`;
        if (format === 'png') {
            exportCanvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${filename}.png`;
                a.click();
                URL.revokeObjectURL(url);
            }, 'image/png');
        } else if (format === 'tiff') {
            const tiffBlob = CanvasToTIFF.toBlob(exportCanvas, { dpi });
            const url = URL.createObjectURL(tiffBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${filename}.tiff`;
            a.click();
            URL.revokeObjectURL(url);
        }
    }
    
    // ----- PWA –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è -----
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('./sw.js').catch(err => {
                console.error('Service Worker registration failed: ', err);
            });
        });
    }
});
</script>

</body>
</html>
