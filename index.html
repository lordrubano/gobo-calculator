<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Профессиональный редактор-калькулятор для гобо v2.2</title>
    <script src="https://d3js.org/d3-delaunay.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
    <style>
        :root {
            --bg-color: #111827; --panel-bg: #1F2937; --primary-color: #3B82F6;
            --text-color: #F3F4F6; --border-color: #4B5563; --success-color: #10B981;
            --danger-color: #EF4444; --warning-color: #F59E0B;
            --font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif;
        }
        body { font-family: var(--font-family); background-color: var(--bg-color); color: var(--text-color); margin: 0; padding: 1rem; font-size: 14px; }
        .app-container { max-width: 1500px; margin: auto; }
        header { text-align: center; margin-bottom: 2rem; }
        header h1 { margin: 0; font-size: 1.875rem; font-weight: bold; color: var(--primary-color); }
        header p { margin: 0.25rem 0; color: #9CA3AF; }
        .control-panel { display: flex; flex-wrap: wrap; justify-content: center; gap: 1rem; margin-bottom: 2rem; }
        .control-panel button { background-color: var(--primary-color); color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 0.5rem; cursor: pointer; font-size: 1rem; font-weight: 600; transition: all 0.2s; display: flex; align-items: center; gap: 0.5rem; box-shadow: 0 4px 6px rgba(0,0,0,0.2); }
        .control-panel button:hover { transform: translateY(-2px); box-shadow: 0 6px 12px rgba(0,0,0,0.3); }
        .control-panel button.danger { background-color: var(--danger-color); }
        .control-panel button:disabled { background-color: #4B5563; cursor: not-allowed; transform: none; box-shadow: none; }
        .main-content { display: grid; grid-template-columns: repeat(auto-fit, minmax(380px, 1fr)); gap: 1.5rem; margin-bottom: 2rem; }
        .canvas-panel { background-color: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 0.75rem; display: flex; flex-direction: column; }
        .canvas-panel-header { font-weight: bold; padding: 0.75rem 1rem; border-bottom: 1px solid var(--border-color); }
        .canvas-container { position: relative; width: 100%; padding-top: 75%; background-color: #111; overflow: hidden; }
        .canvas-container canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; cursor: crosshair; }
        .panel-footer { padding: 0.5rem 1rem; text-align: center; color: #9CA3AF; background-color: rgba(0,0,0,0.2); border-top: 1px solid var(--border-color); }
        .panel-footer .status.ready { color: var(--success-color); font-weight: bold; }
        .panel-footer .status.mismatch { color: var(--warning-color); font-weight: bold; }
        .instructions { background-color: var(--panel-bg); border-radius: 0.75rem; padding: 1.5rem; }
        .instructions h3 { margin-top: 0; font-size: 1.25rem; font-weight: bold; }
        .instructions ol { padding-left: 1.25rem; }
        .loupe { position: absolute; width: 120px; height: 120px; border: 3px solid var(--primary-color); border-radius: 50%; pointer-events: none; display: none; overflow: hidden; box-shadow: 0 5px 15px rgba(0,0,0,0.5); z-index: 100; background: #111; }
        .loupe::before, .loupe::after { content: ''; position: absolute; background-color: var(--danger-color); z-index: 101; }
        .loupe::before { top: 50%; left: 10%; width: 80%; height: 1px; margin-top: -0.5px; }
        .loupe::after { left: 50%; top: 10%; height: 80%; width: 1px; margin-left: -0.5px; }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(17, 24, 39, 0.8); backdrop-filter: blur(4px); display: none; justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background-color: var(--panel-bg); padding: 2rem; border-radius: 0.75rem; width: 90%; max-width: 400px; text-align: center; border: 1px solid var(--border-color); }
        .modal-content h2 { margin-top: 0; font-size: 1.5rem; font-weight: bold; }
        .modal-content .form-group { margin-bottom: 1.5rem; text-align: left; }
        .modal-content label { display: block; margin-bottom: 0.5rem; font-weight: 500; }
        .modal-content input { width: 100%; padding: 0.5rem 0.75rem; border-radius: 0.375rem; border: 1px solid var(--border-color); background-color: #374151; color: var(--text-color); box-sizing: border-box; }
        .modal-buttons { display: flex; justify-content: space-between; gap: 1rem; }
        .file-input { display: none; }
    </style>
</head>
<body>
    <div class="app-container">
        <header>
            <h1>Профессиональный редактор-калькулятор для гобо</h1>
            <p>Версия 2.2 (Стабильная производственная)</p>
        </header>

        <div class="control-panel">
            <button id="load-template-btn">Загрузить фото-шаблон</button>
            <button id="load-source-btn">Загрузить изображение</button>
            <button id="clear-points-btn" class="danger">Очистить точки</button>
            <button id="export-btn" disabled>Экспорт</button>
        </div>
        <input type="file" id="template-file-input" class="file-input" accept="image/*">
        <input type="file" id="source-file-input" class="file-input" accept="image/*">
        <div class="main-content">
            <div class="canvas-panel"><div class="canvas-panel-header">Исходное изображение</div><div class="canvas-container"><canvas id="source-canvas"></canvas></div><div class="panel-footer">Точек источника: <span id="source-points-count">0</span></div></div>
            <div class="canvas-panel"><div class="canvas-panel-header">Фото-шаблон</div><div class="canvas-container"><canvas id="template-canvas"></canvas></div><div class="panel-footer">Точек цели: <span id="dest-points-count">0</span></div></div>
            <div class="canvas-panel"><div class="canvas-panel-header">Предпросмотр деформации</div><div class="canvas-container"><canvas id="preview-canvas"></canvas></div><div class="panel-footer">Статус: <span id="status-text">Ожидание изображений</span></div></div>
        </div>
        <div class="instructions"></div>
        <div class="loupe" id="loupe"></div>
        <div class="modal-overlay" id="export-modal"></div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            class GoboEditor {
                constructor() {
                    this.sourceImage = null; this.templateImage = null;
                    this.sourcePoints = []; this.destinationPoints = [];
                    this.draggingPointInfo = null; this.sourceRenderInfo = {};
                    this.initDOM(); this.initCanvases(); this.bindEvents(); this.renderAll();
                }

                initDOM() {
                    this.sourceCanvas=document.getElementById('source-canvas'); this.templateCanvas=document.getElementById('template-canvas'); this.previewCanvas=document.getElementById('preview-canvas');
                    this.loupe=document.getElementById('loupe'); this.exportBtn=document.getElementById('export-btn'); this.exportModal=document.getElementById('export-modal');
                    document.querySelector('.instructions').innerHTML = `<h3>Инструкция:</h3><ol class="list-decimal list-inside"><li>Загрузите фото-шаблон.</li><li>Загрузите исходное изображение.</li><li>Кликните по ключевым точкам на исходном изображении (минимум 4).</li><li>Кликните по соответствующим точкам на фото-шаблоне в том же порядке.</li><li>Используйте лупу для точного позиционирования.</li><li>Перетаскивайте точки для финальной подгонки.</li><li>Наблюдайте real-time деформацию в окне предпросмотра.</li><li>Нажмите "Экспорт" для создания готового файла.</li></ol>`;
                    this.exportModal.innerHTML = `<div class="modal-content"><h2>Параметры экспорта</h2><div class="form-group"><label for="gobo-diameter">Диаметр гобо (мм)</label><input type="number" id="gobo-diameter" value="37.5" step="0.1"></div><div class="form-group"><label for="gobo-dpi">Разрешение (DPI)</label><input type="number" id="gobo-dpi" value="2700" step="100"></div><div class="modal-buttons"><button id="cancel-export-btn" class="bg-gray-600 hover:bg-gray-700 py-2 px-4 rounded-md font-semibold transition-colors">Отмена</button><button id="confirm-export-btn" class="bg-purple-600 hover:bg-purple-700 py-2 px-4 rounded-md font-semibold transition-colors">Сохранить</button></div></div>`;
                }

                initCanvases() {
                    this.sourceCtx=this.sourceCanvas.getContext('2d'); this.templateCtx=this.templateCanvas.getContext('2d'); this.previewCtx=this.previewCanvas.getContext('2d');
                }

                bindEvents() {
                    const resizeObserver=new ResizeObserver(()=>this.onResize());
                    resizeObserver.observe(this.sourceCanvas.parentElement);
                    document.getElementById('load-template-btn').addEventListener('click',()=>document.getElementById('template-file-input').click());
                    document.getElementById('load-source-btn').addEventListener('click',()=>document.getElementById('source-file-input').click());
                    document.getElementById('template-file-input').addEventListener('change',(e)=>this.loadImage(e.target.files[0],true));
                    document.getElementById('source-file-input').addEventListener('change',(e)=>this.loadImage(e.target.files[0],false));
                    document.getElementById('clear-points-btn').addEventListener('click',()=>this.clearPoints());
                    this.exportBtn.addEventListener('click',()=>this.exportModal.style.display='flex');
                    document.getElementById('cancel-export-btn').addEventListener('click',()=>this.exportModal.style.display='none');
                    document.getElementById('confirm-export-btn').addEventListener('click',()=>this.handleExport());
                    this.setupCanvasInteraction(this.sourceCanvas,this.sourcePoints);
                    this.setupCanvasInteraction(this.templateCanvas,this.destinationPoints);
                }
                
                onResize(){[this.sourceCanvas,this.templateCanvas,this.previewCanvas].forEach(c=>{const p=c.parentElement;c.width=p.clientWidth;c.height=p.clientHeight;});this.renderAll();}
                loadImage(f,t){if(!f)return;const r=new FileReader();r.onload=e=>{const i=new Image();i.onload=()=>{if(t)this.templateImage=i;else this.sourceImage=i;this.renderAll();};i.src=e.target.result;};r.readAsDataURL(f);}

                setupCanvasInteraction(canvas, points) {
                    const getCoords=(e)=>{const r=canvas.getBoundingClientRect();return{x:e.clientX-r.left,y:e.clientY-r.top};};
                    canvas.addEventListener('mousedown',e=>{const c=getCoords(e);const i=this.getPointAt(c,points);if(i!==-1)this.draggingPointInfo={p:points[i],a:points};});
                    canvas.addEventListener('mousemove',e=>{const c=getCoords(e);this.updateLoupe(e,canvas,c);if(this.draggingPointInfo&&this.draggingPointInfo.a===points){this.draggingPointInfo.p[0]=c.x;this.draggingPointInfo.p[1]=c.y;this.renderAll();}});
                    canvas.addEventListener('mouseup',()=>{this.draggingPointInfo=null;});
                    canvas.addEventListener('mouseleave',()=>{this.loupe.style.display='none';this.draggingPointInfo=null;});
                    canvas.addEventListener('mouseenter',()=>{this.loupe.style.display='block';});
                    canvas.addEventListener('click',e=>{if(this.draggingPointInfo)return;const c=getCoords(e);if(this.getPointAt(c,points)===-1){if(canvas===this.sourceCanvas)points.push([c.x,c.y]);else if(canvas===this.templateCanvas&&points.length<this.sourcePoints.length)points.push([c.x,c.y]);this.renderAll();}});
                }
                
                getPointAt(c,p){for(let i=0;i<p.length;i++){if(Math.sqrt((p[i][0]-c.x)**2+(p[i][1]-c.y)**2)<10)return i;}return-1;}
                clearPoints(){this.sourcePoints.length=0;this.destinationPoints.length=0;this.renderAll();}
                
                renderAll() {
                    this.sourceRenderInfo=this.drawCanvasWithAspectRatio(this.sourceCtx,this.sourceCanvas,this.sourceImage,this.sourcePoints);
                    this.drawCanvasWithAspectRatio(this.templateCtx,this.templateCanvas,this.templateImage,this.destinationPoints);
                    this.updatePreview(); this.updateStatus();
                }

                drawCanvasWithAspectRatio(ctx,canvas,img,points){
                    ctx.fillStyle='#111827';ctx.fillRect(0,0,canvas.width,canvas.height);
                    const r={ox:0,oy:0,dw:0,dh:0};
                    if(img){const cr=canvas.width/canvas.height,ir=img.naturalWidth/img.naturalHeight;r.dw=canvas.width;r.dh=canvas.height;if(ir>cr){r.dh=canvas.width/ir;r.oy=(canvas.height-r.dh)/2;}else{r.dw=canvas.height*ir;r.ox=(canvas.width-r.dw)/2;}ctx.drawImage(img,r.ox,r.oy,r.dw,r.dh);}
                    points.forEach((p,i)=>this.drawPoint(ctx,p,i+1));return r;
                }

                drawPoint(ctx,p,n){ctx.beginPath();ctx.arc(p[0],p[1],5,0,2*Math.PI);ctx.fillStyle='rgba(59,130,246,0.9)';ctx.fill();ctx.strokeStyle='#fff';ctx.lineWidth=1.5;ctx.stroke();ctx.fillStyle='#fff';ctx.font='bold 10px sans-serif';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillText(n,p[0],p[1]);}
                
                updateLoupe(e,c,o){const i=c===this.sourceCanvas?this.sourceImage:this.templateImage;if(!i)return;const z=4;this.loupe.style.left=`${e.pageX+15}px`;this.loupe.style.top=`${e.pageY+15}px`;const rI=this.drawCanvasWithAspectRatio(document.createElement('canvas').getContext('2d'),c,i,[]);const iX=(o.x-rI.ox)/rI.dw*i.naturalWidth,iY=(o.y-rI.oy)/rI.dh*i.naturalHeight;const lC=this.loupe.querySelector('canvas')||document.createElement('canvas');if(!this.loupe.querySelector('canvas')){this.loupe.appendChild(lC);lC.width=120;lC.height=120;}const lX=lC.getContext('2d');lX.fillStyle='#111';lX.fillRect(0,0,120,120);lX.drawImage(i,iX-60/z,iY-60/z,120/z,120/z,0,0,120,120);}

                updateStatus(){const sC=this.sourcePoints.length,dC=this.destinationPoints.length;document.getElementById('source-points-count').textContent=sC;document.getElementById('dest-points-count').textContent=dC;const sS=document.getElementById('status-text');const cW=sC>=4&&sC===dC;if(cW){sS.textContent='Готово к экспорту';sS.className='status ready';this.exportBtn.disabled=false;}else if(sC!==dC){sS.textContent=`Синхронизация (${sC}/${dC})`;sS.className='status mismatch';this.exportBtn.disabled=true;}else{sS.textContent='Расставьте точки';sS.className='status';this.exportBtn.disabled=true;}}
                
                updatePreview() {
                    this.previewCtx.clearRect(0,0,this.previewCanvas.width,this.previewCanvas.height);
                    if(this.templateImage) this.drawCanvasWithAspectRatio(this.previewCtx,this.previewCanvas,this.templateImage,[]);
                    if(!this.sourceImage||this.sourcePoints.length<4||this.sourcePoints.length!==this.destinationPoints.length)return;
                    const warpedCanvas=this.getWarpedCanvas(this.sourceImage,this.sourcePoints,this.destinationPoints,this.templateCanvas.width,this.templateCanvas.height);
                    if(warpedCanvas)this.previewCtx.drawImage(warpedCanvas,0,0);
                }

                getWarpedCanvas(img,srcPts,destPts,w,h) {
                    const warpedCanvas=document.createElement('canvas');warpedCanvas.width=w;warpedCanvas.height=h;
                    const warpedCtx=warpedCanvas.getContext('2d');
                    const absSrcPts=srcPts.map(p=>[(p[0]-this.sourceRenderInfo.ox)/this.sourceRenderInfo.dw*img.naturalWidth,(p[1]-this.sourceRenderInfo.oy)/this.sourceRenderInfo.dh*img.naturalHeight]);
                    try{
                        const delaunay=d3.Delaunay.from(absSrcPts);
                        const triangles=delaunay.triangles;
                        for(let i=0;i<triangles.length;i+=3){
                            const p_src_abs=[absSrcPts[triangles[i]],absSrcPts[triangles[i+1]],absSrcPts[triangles[i+2]]];
                            const p_dest=[destPts[triangles[i]],destPts[triangles[i+1]],destPts[triangles[i+2]]];
                            const triArea=(p0,p1,p2)=>0.5*Math.abs(p0[0]*(p1[1]-p2[1])+p1[0]*(p2[1]-p0[1])+p2[0]*(p0[1]-p1[1]));
                            if(triArea(p_src_abs[0],p_src_abs[1],p_src_abs[2])<0.1)continue;
                            warpedCtx.save();
                            warpedCtx.beginPath();
                            warpedCtx.moveTo(p_dest[0][0],p_dest[0][1]);
                            warpedCtx.lineTo(p_dest[1][0],p_dest[1][1]);
                            warpedCtx.lineTo(p_dest[2][0],p_dest[2][1]);
                            warpedCtx.closePath();
                            warpedCtx.clip();
                            const transform=this.getAffineTransform(p_src_abs,p_dest);
                            if(transform){warpedCtx.setTransform(transform.a,transform.b,transform.c,transform.d,transform.e,transform.f);warpedCtx.drawImage(img,0,0);}
                            warpedCtx.restore();
                        }
                        return warpedCanvas;
                    }catch(e){console.error("Warping failed:",e);return null;}
                }

                // ИСПРАВЛЕНИЕ: Используем math.js для стабильного решения
                getAffineTransform(src, dst) {
                    const [p1,p2,p3]=src; const [q1,q2,q3]=dst;
                    try {
                        const M = math.matrix([[p1[0],p1[1],1,0,0,0],[0,0,0,p1[0],p1[1],1],[p2[0],p2[1],1,0,0,0],[0,0,0,p2[0],p2[1],1],[p3[0],p3[1],1,0,0,0],[0,0,0,p3[0],p3[1],1]]);
                        const b = math.matrix([q1[0],q1[1],q2[0],q2[1],q3[0],q3[1]]);
                        const t = math.lusolve(M, b).valueOf().flat();
                        return {a:t[0],b:t[3],c:t[1],d:t[4],e:t[2],f:t[5]};
                    } catch (e) {
                        console.error("Matrix solving failed for triangle:", src, e);
                        return null; // Возвращаем null при ошибке
                    }
                }

                handleExport() {
                    const diameter=parseFloat(document.getElementById('gobo-diameter').value);
                    const dpi=parseInt(document.getElementById('gobo-dpi').value);
                    if(isNaN(diameter)||isNaN(dpi)||diameter<=0||dpi<=0){alert('Введите корректные значения.');return;}
                    const exportSizePx=Math.round((diameter/25.4)*dpi);
                    const exportCanvas=document.createElement('canvas');exportCanvas.width=exportSizePx;exportCanvas.height=exportSizePx;
                    const exportCtx=exportCanvas.getContext('2d');
                    exportCtx.fillStyle='black';
                    exportCtx.beginPath();
                    exportCtx.arc(exportSizePx/2,exportSizePx/2,exportSizePx/2,0,2*Math.PI);
                    exportCtx.fill();
                    const warpedCanvas=this.getWarpedCanvas(this.sourceImage,this.sourcePoints,this.destinationPoints.map(p=>[(p[0]/this.templateCanvas.width)*exportSizePx,(p[1]/this.templateCanvas.height)*exportSizePx]),exportSizePx,exportSizePx);
                    if(warpedCanvas)exportCtx.drawImage(warpedCanvas,0,0);
                    const link=document.createElement('a');
                    link.download=`gobo_export_${diameter}mm_${dpi}dpi.png`;
                    link.href=exportCanvas.toDataURL('image/png');
                    link.click();
                    this.exportModal.style.display='none';
                }
            }
            new GoboEditor();
        });
    </script>
</body>
</html>
