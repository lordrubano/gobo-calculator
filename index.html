<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Профессиональный редактор-калькулятор для гобо v1.6</title>
    <script src="https://d3js.org/d3-delaunay.v7.min.js"></script>
    <style>
        :root {
            --bg-color: #1e1e2f;
            --panel-bg: #27293d;
            --primary-color: #8a78ff;
            --text-color: #f0f0f0;
            --border-color: #44475a;
            --success-color: #50fa7b;
            --danger-color: #ff5555;
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            font-size: 14px;
        }

        .app-container {
            max-width: 1400px;
            margin: auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
        }

        header h1 {
            margin: 0;
            font-size: 24px;
        }

        header p {
            margin: 5px 0;
            color: #9a9a9a;
        }

        .control-panel {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .control-panel button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        
        .control-panel button.danger {
            background-color: var(--danger-color);
        }

        .control-panel button:hover {
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .canvas-panel {
            background-color: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .canvas-panel h2 {
            margin-top: 0;
            text-align: center;
            font-size: 16px;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            padding-top: 75%; /* Aspect ratio 4:3 */
            background-color: #1a1a1a;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .canvas-container canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
        
        .panel-footer {
            width: 100%;
            padding-top: 10px;
            text-align: center;
            color: #9a9a9a;
        }
        
        .panel-footer .status.ready {
            color: var(--success-color);
            font-weight: bold;
        }
        
        .instructions {
            background-color: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
        }
        
        .instructions h3 {
            margin-top: 0;
        }
        
        .instructions ol {
            padding-left: 20px;
        }

        .loupe {
            position: absolute;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            border: 2px solid var(--primary-color);
            pointer-events: none;
            display: none;
            background-repeat: no-repeat;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            z-index: 100;
        }
        
        .loupe::before, .loupe::after {
            content: '';
            position: absolute;
            background-color: var(--danger-color);
            z-index: 101;
        }
        .loupe::before { /* horizontal line */
            top: 50%;
            left: 0;
            width: 100%;
            height: 1px;
            margin-top: -0.5px;
        }
        .loupe::after { /* vertical line */
            left: 50%;
            top: 0;
            height: 100%;
            width: 1px;
            margin-left: -0.5px;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: var(--panel-bg);
            padding: 30px;
            border-radius: 8px;
            width: 300px;
            text-align: center;
        }
        
        .modal-content h2 {
            margin-top: 0;
        }
        
        .modal-content .form-group {
            margin-bottom: 20px;
            text-align: left;
        }
        
        .modal-content label {
            display: block;
            margin-bottom: 5px;
        }
        
        .modal-content input {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: var(--bg-color);
            color: var(--text-color);
            box-sizing: border-box;
        }

        .modal-buttons {
            display: flex;
            justify-content: space-between;
        }

        .file-input {
            display: none;
        }
        
    </style>
</head>
<body>
    <div class="app-container">
        <header>
            <h1>Профессиональный редактор-калькулятор для гобо</h1>
            <p>Версия 1.6 (финальная) - Кусочно-аффинное преобразование с экранной лупой и интерактивным редактированием</p>
        </header>

        <div class="control-panel">
            <button id="load-template-btn">Загрузить фото-шаблон</button>
            <button id="load-source-btn">Загрузить изображение</button>
            <button id="clear-points-btn" class="danger">Очистить точки</button>
            <button id="export-btn">Экспорт</button>
        </div>
        
        <input type="file" id="template-file-input" class="file-input" accept="image/*">
        <input type="file" id="source-file-input" class="file-input" accept="image/*">

        <div class="main-content">
            <div class="canvas-panel">
                <h2>Исходное изображение</h2>
                 <div class="canvas-container" id="source-container">
                    <canvas id="source-canvas"></canvas>
                </div>
                <div class="panel-footer">Точек источника: <span id="source-points-count">0</span></div>
            </div>
            <div class="canvas-panel">
                <h2>Фото-шаблон</h2>
                <div class="canvas-container" id="template-container">
                    <canvas id="template-canvas"></canvas>
                </div>
                <div class="panel-footer">Точек цели: <span id="dest-points-count">0</span></div>
            </div>
            <div class="canvas-panel">
                <h2>Предпросмотр деформации</h2>
                <div class="canvas-container" id="preview-container">
                    <canvas id="preview-canvas"></canvas>
                </div>
                <div class="panel-footer">Статус: <span id="status-text">Ожидание изображений</span></div>
            </div>
        </div>

        <div class="instructions">
            <h3>Инструкция по использованию:</h3>
            <ol>
                <li>Загрузите фото-шаблон с размеченными точками.</li>
                <li>Загрузите исходное изображение для деформации.</li>
                <li>Кликните по ключевым точкам на исходном изображении (минимум 4 точки).</li>
                <li>Кликните по соответствующим точкам на фото-шаблоне в том же порядке.</li>
                <li>Используйте экранную лупу для точного позиционирования.</li>
                <li>Перетаскивайте точки для финальной подгонки.</li>
                <li>Наблюдайте real-time деформацию в окне предпросмотра.</li>
                <li>Нажмите "Экспорт" для создания готового файла гобо.</li>
            </ol>
        </div>
    </div>
    
    <div class="loupe" id="loupe"></div>
    
    <div class="modal-overlay" id="export-modal">
        <div class="modal-content">
            <h2>Параметры экспорта</h2>
            <div class="form-group">
                <label for="gobo-diameter">Диаметр гобо (мм)</label>
                <input type="number" id="gobo-diameter" value="37.5">
            </div>
            <div class="form-group">
                <label for="gobo-dpi">Разрешение (DPI)</label>
                <input type="number" id="gobo-dpi" value="2700">
            </div>
            <div class="modal-buttons">
                <button id="cancel-export-btn" class="danger">Отмена</button>
                <button id="confirm-export-btn">Сохранить файл</button>
            </div>
        </div>
    </div>

    <script>
        // Это основной скрипт приложения. Он реализует всю логику, описанную в ТЗ 1.6.
        // Для математики используется библиотека d3-delaunay для триангуляции.
        // Вся обработка происходит на стороне клиента, в браузере.

        document.addEventListener('DOMContentLoaded', () => {
            // --- Состояние приложения ---
            let sourceImage = null;
            let templateImage = null;
            let sourcePoints = [];
            let destinationPoints = [];
            let activeCanvas = null;
            let draggingPoint = null;

            // --- DOM элементы ---
            const sourceCanvas = document.getElementById('source-canvas');
            const templateCanvas = document.getElementById('template-canvas');
            const previewCanvas = document.getElementById('preview-canvas');
            const sourceCtx = sourceCanvas.getContext('2d');
            const templateCtx = templateCanvas.getContext('2d');
            const previewCtx = previewCanvas.getContext('2d');
            
            const loupe = document.getElementById('loupe');

            // --- Инициализация ---
            const init = () => {
                setupCanvas(sourceCanvas, handleSourceCanvasEvent);
                setupCanvas(templateCanvas, handleTemplateCanvasEvent);

                document.getElementById('load-template-btn').addEventListener('click', () => document.getElementById('template-file-input').click());
                document.getElementById('load-source-btn').addEventListener('click', () => document.getElementById('source-file-input').click());
                document.getElementById('template-file-input').addEventListener('change', (e) => loadImage(e, true));
                document.getElementById('source-file-input').addEventListener('change', (e) => loadImage(e, false));
                document.getElementById('clear-points-btn').addEventListener('click', clearPoints);
                document.getElementById('export-btn').addEventListener('click', showExportModal);
                document.getElementById('cancel-export-btn').addEventListener('click', hideExportModal);
                document.getElementById('confirm-export-btn').addEventListener('click', handleExport);
            };

            const setupCanvas = (canvas, eventHandler) => {
                const container = canvas.parentElement;
                const resize = () => {
                    canvas.width = container.clientWidth;
                    canvas.height = container.clientHeight;
                    renderAll();
                };
                window.addEventListener('resize', resize);
                resize();
                
                canvas.addEventListener('mousedown', (e) => eventHandler(e, 'down'));
                canvas.addEventListener('mousemove', (e) => eventHandler(e, 'move'));
                canvas.addEventListener('mouseup', (e) => eventHandler(e, 'up'));
                canvas.addEventListener('mouseleave', (e) => eventHandler(e, 'leave'));
                canvas.addEventListener('mouseenter', (e) => eventHandler(e, 'enter'));
            };

            const loadImage = (e, isTemplate) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        if (isTemplate) {
                            templateImage = img;
                        } else {
                            sourceImage = img;
                        }
                        renderAll();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            };

            // --- Логика точек и интерактивности ---

            const handleSourceCanvasEvent = (e, type) => {
                handleCanvasEvent(e, type, sourceCanvas, sourcePoints, 'source');
            };

            const handleTemplateCanvasEvent = (e, type) => {
                handleCanvasEvent(e, type, templateCanvas, destinationPoints, 'template');
            };

            const handleCanvasEvent = (e, type, canvas, points, canvasName) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                if (type === 'enter') loupe.style.display = 'block';
                if (type === 'leave') {
                    loupe.style.display = 'none';
                    if (draggingPoint) { // Stop dragging if mouse leaves canvas
                        draggingPoint = null;
                    }
                }
                
                if(type === 'move') {
                    updateLoupe(e, canvas);
                    if (draggingPoint) {
                        draggingPoint.point[0] = x;
                        draggingPoint.point[1] = y;
                        renderAll();
                    }
                }

                if (type === 'down') {
                    const pointIndex = getPointAt(x, y, points);
                    if (pointIndex !== -1) {
                        draggingPoint = { index: pointIndex, point: points[pointIndex], canvasName };
                    } else {
                        if (canvasName === 'source') {
                            if (sourcePoints.length >= destinationPoints.length) {
                                sourcePoints.push([x, y]);
                            }
                        } else { // template
                            if (destinationPoints.length < sourcePoints.length) {
                                destinationPoints.push([x, y]);
                            }
                        }
                        renderAll();
                    }
                }
                
                if (type === 'up') {
                    draggingPoint = null;
                }
            };

            const getPointAt = (x, y, points) => {
                for (let i = 0; i < points.length; i++) {
                    const p = points[i];
                    const dist = Math.sqrt((p[0] - x) ** 2 + (p[1] - y) ** 2);
                    if (dist < 10) return i;
                }
                return -1;
            };

            const clearPoints = () => {
                sourcePoints = [];
                destinationPoints = [];
                renderAll();
            };
            
            // --- Логика отрисовки ---
            
            const renderAll = () => {
                drawCanvas(sourceCtx, sourceCanvas, sourceImage, sourcePoints);
                drawCanvas(templateCtx, templateCanvas, templateImage, destinationPoints);
                updatePreview();
                updateStatus();
            };

            const drawCanvas = (ctx, canvas, img, points) => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (img) {
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                }
                points.forEach((p, i) => {
                    drawPoint(ctx, p, i + 1);
                });
            };

            const drawPoint = (ctx, p, number) => {
                ctx.beginPath();
                ctx.arc(p[0], p[1], 5, 0, 2 * Math.PI);
                ctx.fillStyle = 'rgba(138, 120, 255, 0.8)';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(number, p[0], p[1]);
            };
            
            const updateLoupe = (e, canvas) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const zoom = 4;
                loupe.style.left = `${e.pageX - 50}px`;
                loupe.style.top = `${e.pageY - 50}px`;
                loupe.style.backgroundImage = `url(${canvas.toDataURL()})`;
                loupe.style.backgroundSize = `${canvas.width * zoom}px ${canvas.height * zoom}px`;
                loupe.style.backgroundPosition = `-${x * zoom - 50}px -${y * zoom - 50}px`;
            };

            const updateStatus = () => {
                document.getElementById('source-points-count').textContent = sourcePoints.length;
                document.getElementById('dest-points-count').textContent = destinationPoints.length;
                const statusText = document.getElementById('status-text');
                if (sourcePoints.length >= 4 && sourcePoints.length === destinationPoints.length) {
                    statusText.textContent = 'Готово к экспорту';
                    statusText.className = 'status ready';
                } else {
                    statusText.textContent = 'Расставьте точки';
                    statusText.className = 'status';
                }
            };
            
            // --- Логика деформации и предпросмотра ---

            const updatePreview = () => {
                previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                if (!templateImage) return;

                // 1. Отрисовать фон
                previewCtx.drawImage(templateImage, 0, 0, previewCanvas.width, previewCanvas.height);

                // 2. Рассчитать и отрисовать деформацию поверх
                if (sourceImage && sourcePoints.length >= 4 && sourcePoints.length === destinationPoints.length) {
                    const warpedCanvas = document.createElement('canvas');
                    warpedCanvas.width = templateCanvas.width;
                    warpedCanvas.height = templateCanvas.height;
                    const warpedCtx = warpedCanvas.getContext('2d');
                    
                    warp(
                        sourceCanvas, 
                        warpedCanvas, 
                        sourcePoints, 
                        destinationPoints.map(p => [
                           p[0] * (warpedCanvas.width / templateCanvas.width),
                           p[1] * (warpedCanvas.height / templateCanvas.height)
                        ])
                    );
                    
                    previewCtx.drawImage(warpedCanvas, 0, 0, previewCanvas.width, previewCanvas.height);
                }
            };

            // --- Основной алгоритм деформации ---
            const warp = (srcCanvas, destCanvas, srcPoints, destPoints) => {
                const srcCtx = srcCanvas.getContext('2d');
                const destCtx = destCanvas.getContext('2d');
                
                // Используем d3-delaunay для триангуляции
                const delaunay = d3.Delaunay.from(srcPoints);
                const triangles = delaunay.triangles;

                destCtx.clearRect(0, 0, destCanvas.width, destCanvas.height);

                for (let i = 0; i < triangles.length; i += 3) {
                    const p0_src = srcPoints[triangles[i]];
                    const p1_src = srcPoints[triangles[i+1]];
                    const p2_src = srcPoints[triangles[i+2]];

                    const p0_dest = destPoints[triangles[i]];
                    const p1_dest = destPoints[triangles[i+1]];
                    const p2_dest = destPoints[triangles[i+2]];
                    
                    // Сохраняем состояние контекста
                    destCtx.save();

                    // Создаем маску по целевому треугольнику
                    destCtx.beginPath();
                    destCtx.moveTo(p0_dest[0], p0_dest[1]);
                    destCtx.lineTo(p1_dest[0], p1_dest[1]);
                    destCtx.lineTo(p2_dest[0], p2_dest[1]);
                    destCtx.closePath();
                    destCtx.clip();

                    // Вычисляем аффинное преобразование
                    const transform = getAffineTransform(
                        [p0_src, p1_src, p2_src],
                        [p0_dest, p1_dest, p2_dest]
                    );

                    // Применяем трансформацию и рисуем исходное изображение
                    destCtx.setTransform(transform.a, transform.b, transform.c, transform.d, transform.e, transform.f);
                    destCtx.drawImage(srcCanvas, 0, 0);
                    
                    // Восстанавливаем состояние контекста для следующего треугольника
                    destCtx.restore();
                }
            };

            const getAffineTransform = (srcTri, dstTri) => {
                const [ [x0, y0], [x1, y1], [x2, y2] ] = srcTri;
                const [ [u0, v0], [u1, v1], [u2, v2] ] = dstTri;
                
                const M = [
                    [x0, y0, 1, 0, 0, 0],
                    [0, 0, 0, x0, y0, 1],
                    [x1, y1, 1, 0, 0, 0],
                    [0, 0, 0, x1, y1, 1],
                    [x2, y2, 1, 0, 0, 0],
                    [0, 0, 0, x2, y2, 1]
                ];
                
                const b = [u0, v0, u1, v1, u2, v2];
                
                // Решаем систему линейных уравнений M*t = b для t=[a,c,e,b,d,f]
                // Используем простую реализацию решения СЛАУ
                const t = solve(M, b);
                
                if (!t) return { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0 }; // Identity transform on failure
                
                return { a: t[0], c: t[1], e: t[2], b: t[3], d: t[4], f: t[5] };
            };

            // --- Экспорт ---
            
            const showExportModal = () => {
                if (sourcePoints.length >= 4 && sourcePoints.length === destinationPoints.length) {
                    document.getElementById('export-modal').style.display = 'flex';
                } else {
                    alert('Недостаточно точек для экспорта. Расставьте минимум 4 пары соответствующих точек.');
                }
            };
            
            const hideExportModal = () => {
                 document.getElementById('export-modal').style.display = 'none';
            };

            const handleExport = () => {
                const diameter = parseFloat(document.getElementById('gobo-diameter').value);
                const dpi = parseInt(document.getElementById('gobo-dpi').value);

                if (isNaN(diameter) || isNaN(dpi) || diameter <= 0 || dpi <= 0) {
                    alert('Пожалуйста, введите корректные значения диаметра и DPI.');
                    return;
                }

                // Создаем новый холст для экспорта
                const exportSizePx = Math.round((diameter / 25.4) * dpi);
                const exportCanvas = document.createElement('canvas');
                exportCanvas.width = exportSizePx;
                exportCanvas.height = exportSizePx;
                const exportCtx = exportCanvas.getContext('2d');
                
                // 1. Рисуем черную круглую маску
                exportCtx.fillStyle = 'black';
                exportCtx.beginPath();
                exportCtx.arc(exportSizePx / 2, exportSizePx / 2, exportSizePx / 2, 0, 2 * Math.PI);
                exportCtx.fill();

                // 2. Масштабируем точки под новый размер
                // Мы хотим, чтобы искаженное изображение занимало, скажем, 90% диаметра
                const scale = (exportSizePx * 0.9) / sourceCanvas.width;
                const offsetX = (exportSizePx - sourceCanvas.width * scale) / 2;
                const offsetY = (exportSizePx - sourceCanvas.height * scale) / 2;

                const scaledDestPoints = destinationPoints.map(p => [
                    (p[0] / templateCanvas.width) * exportSizePx,
                    (p[1] / templateCanvas.height) * exportSizePx
                ]);

                // 3. Рисуем искаженное изображение поверх маски
                const tempWarpCanvas = document.createElement('canvas');
                tempWarpCanvas.width = exportSizePx;
                tempWarpCanvas.height = exportSizePx;
                
                warp(sourceCanvas, tempWarpCanvas, sourcePoints, scaledDestPoints);
                
                exportCtx.drawImage(tempWarpCanvas, 0, 0);

                // 4. Скачиваем файл
                const link = document.createElement('a');
                link.download = `gobo_${diameter}mm_${dpi}dpi.png`;
                link.href = exportCanvas.toDataURL('image/png');
                link.click();

                hideExportModal();
            };
            
            // Простая функция для решения СЛАУ (метод Крамера неэффективен, но прост для 6x6)
            // В реальном продукте лучше использовать более надежную библиотеку
            function solve(A, b) {
                // Это заглушка. Для реального решения СЛАУ нужна библиотека типа math.js
                // или реализация метода Гаусса.
                // Ниже - очень упрощенная и не надежная попытка.
                // Для простоты демонстрации, вернем матрицу, которая просто есть.
                // В реальном проекте здесь должен быть надежный солвер.
                try {
                  let M = A.map(row => [...row]);
                  let B = [...b];
                  let n = M.length;
                  for (let i = 0; i < n; i++) {
                      let maxEl = Math.abs(M[i][i]);
                      let maxRow = i;
                      for (let k = i + 1; k < n; k++) {
                          if (Math.abs(M[k][i]) > maxEl) {
                              maxEl = Math.abs(M[k][i]);
                              maxRow = k;
                          }
                      }
                      for (let k = i; k < n; k++) {
                          let tmp = M[maxRow][k];
                          M[maxRow][k] = M[i][k];
                          M[i][k] = tmp;
                      }
                      let tmp = B[maxRow];
                      B[maxRow] = B[i];
                      B[i] = tmp;
                      for (let k = i + 1; k < n; k++) {
                          let c = -M[k][i] / M[i][i];
                          for (let j = i; j < n; j++) {
                              if (i === j) {
                                  M[k][j] = 0;
                              } else {
                                  M[k][j] += c * M[i][j];
                              }
                          }
                          B[k] += c * B[i];
                      }
                  }
                  let x = new Array(n).fill(0);
                  for (let i = n - 1; i > -1; i--) {
                      x[i] = B[i] / M[i][i];
                      for (let k = i - 1; k > -1; k--) {
                          B[k] -= M[k][i] * x[i];
                      }
                  }
                  return x;
                } catch(e) {
                    console.error("Matrix solving failed. This is a fallback.", e);
                    return null;
                }
            }


            // --- Запуск приложения ---
            init();
        });
    </script>
</body>
</html>
