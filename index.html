<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>GOBO Calculator PRO</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body { font-family: sans-serif; margin: 0; background: #f2f2f2; color: #222; }
    header { background: #2d3748; color: #fff; padding: 1rem; text-align: center; }
    .container { max-width: 960px; margin: 2rem auto; padding: 1rem; background: #fff; border-radius: 8px; box-shadow: 0 0 8px rgba(0,0,0,0.1); }
    #canvasWrapper { position: relative; }
    #photo { display: block; max-width: 100%; }
    #editorCanvas { position: absolute; top: 0; left: 0; pointer-events: none; }
    .point { width: 12px; height: 12px; background: red; border-radius: 50%; position: absolute; transform: translate(-50%, -50%); pointer-events: auto; }
    .controls, .actions { display: flex; flex-wrap: wrap; gap: 1rem; margin-top: 1rem; align-items: center; }
    label { display: flex; flex-direction: column; font-size: 0.9rem; }
    button { padding: 0.4rem 0.8rem; cursor: pointer; }
  </style>
</head>
<body>
  <header>
    <h1>GOBO Calculator PRO</h1>
    <p>–¢–æ—á–Ω–∞—è –¥–µ—Ñ–æ—Ä–º–∞—Ü–∏—è –∏ —ç–∫—Å–ø–æ—Ä—Ç –≥–æ–±–æ —Å–ª–∞–π–¥–æ–≤ (PNG / PDF)</p>
  </header>
  <div class="container">
    <input type="file" id="photoInput" accept="image/*">
    <input type="file" id="goboInput" accept="image/*">
    <div id="canvasWrapper">
      <img id="photo" />
      <canvas id="editorCanvas"></canvas>
    </div>

    <div class="controls">
      <label>–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å<input type="range" id="opacitySlider" min="0" max="100" value="100"></label>
      <label>–ú–∞—Å—à—Ç–∞–±<input type="range" id="scaleSlider" min="10" max="300" value="100"></label>
      <label>–ü–æ–≤–æ—Ä–æ—Ç<input type="range" id="rotateSlider" min="-180" max="180" value="0"></label>
      <label>–î–∏–∞–º–µ—Ç—Ä —Å–ª–∞–π–¥–∞ (–º–º)<input type="number" id="slideDiameter" value="32" min="10" max="100"></label>
    </div>

    <div class="actions">
      <button id="saveBtn">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
      <button id="loadBtn">üìÇ –ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
      <button id="exportPNG">üì§ PNG</button>
      <button id="exportPDF">üìÑ PDF</button>
    </div>

    <div>
      <p>–ö–ª–∏–∫–Ω–∏—Ç–µ –ø–æ —Ñ–æ—Ç–æ ‚Äî –¥–æ–±–∞–≤—å—Ç–µ –¥–æ 32 —Ç–æ—á–µ–∫. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –º—ã—à—å –∏–ª–∏ –∫–∞—Å–∞–Ω–∏–µ.</p>
      <button id="undo">‚Ü∂ Undo</button>
      <button id="redo">‚Ü∑ Redo</button>
      <button id="clear">–û—á–∏—Å—Ç–∏—Ç—å</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script>
    const photo = document.getElementById('photo');
    const canvas = document.getElementById('editorCanvas');
    const ctx = canvas.getContext('2d');
    const wrapper = document.getElementById('canvasWrapper');
    let gobo = null;
    let points = [], history = [], future = [];
    let transform = { x: 0, y: 0, scale: 1, rotate: 0, opacity: 1 };

    const maxPoints = 32;

    function updateCanvasSize() {
      canvas.width = photo.naturalWidth;
      canvas.height = photo.naturalHeight;
      canvas.style.width = photo.clientWidth + 'px';
      canvas.style.height = photo.clientHeight + 'px';
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!gobo) return;
      ctx.save();
      ctx.globalAlpha = transform.opacity;
      ctx.translate(transform.x, transform.y);
      ctx.rotate(transform.rotate * Math.PI / 180);
      ctx.scale(transform.scale, transform.scale);
      ctx.drawImage(gobo, -gobo.width / 2, -gobo.height / 2);
      ctx.restore();
    }

    function saveHistory() {
      history.push(JSON.stringify({ points, transform }));
      if (history.length > 100) history.shift();
      future = [];
    }

    function renderPoints() {
      document.querySelectorAll(".point").forEach(p => p.remove());
      const rect = canvas.getBoundingClientRect();
      points.forEach((pt, i) => {
        const el = document.createElement("div");
        el.className = "point";
        el.style.left = rect.left + pt.x * rect.width / canvas.width + "px";
        el.style.top = rect.top + pt.y * rect.height / canvas.height + "px";
        wrapper.appendChild(el);
      });
    }

    document.getElementById("photoInput").onchange = e => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = ev => {
        photo.src = ev.target.result;
        photo.onload = () => {
          updateCanvasSize();
          transform.x = canvas.width / 2;
          transform.y = canvas.height / 2;
          draw();
        };
      };
      reader.readAsDataURL(file);
    };

    document.getElementById("goboInput").onchange = e => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = ev => {
        gobo = new Image();
        gobo.src = ev.target.result;
        gobo.onload = () => draw();
      };
      reader.readAsDataURL(file);
    };

    canvas.addEventListener("click", e => {
      if (points.length >= maxPoints) return;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * canvas.width / rect.width;
      const y = (e.clientY - rect.top) * canvas.height / rect.height;
      points.push({ x, y });
      renderPoints();
      saveHistory();
    });

    document.getElementById("opacitySlider").oninput = e => {
      transform.opacity = e.target.value / 100;
      draw();
    };
    document.getElementById("scaleSlider").oninput = e => {
      transform.scale = e.target.value / 100;
      draw();
    };
    document.getElementById("rotateSlider").oninput = e => {
      transform.rotate = parseInt(e.target.value);
      draw();
    };

    document.getElementById("clear").onclick = () => {
      points = [];
      renderPoints();
      draw();
      saveHistory();
    };
    document.getElementById("undo").onclick = () => {
      if (!history.length) return;
      future.push(JSON.stringify({ points, transform }));
      let state = JSON.parse(history.pop());
      points = state.points;
      transform = state.transform;
      renderPoints();
      draw();
    };
    document.getElementById("redo").onclick = () => {
      if (!future.length) return;
      history.push(JSON.stringify({ points, transform }));
      let state = JSON.parse(future.pop());
      points = state.points;
      transform = state.transform;
      renderPoints();
      draw();
    };

    document.getElementById("saveBtn").onclick = () => {
      const data = { points, transform, gobo: gobo?.src || null, photo: photo.src };
      const blob = new Blob([JSON.stringify(data)], { type: "application/json" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "gobo-project.json";
      a.click();
    };

    document.getElementById("loadBtn").onclick = () => {
      const input = document.createElement("input");
      input.type = "file";
      input.accept = ".json";
      input.onchange = e => {
        const reader = new FileReader();
        reader.onload = ev => {
          const data = JSON.parse(ev.target.result);
          points = data.points;
          transform = data.transform;
          if (data.photo) photo.src = data.photo;
          if (data.gobo) {
            gobo = new Image();
            gobo.src = data.gobo;
            gobo.onload = () => draw();
          }
          photo.onload = () => {
            updateCanvasSize();
            renderPoints();
            draw();
          };
        };
        reader.readAsText(e.target.files[0]);
      };
      input.click();
    };

    function mmToPx(mm, dpi = 2700) {
      return Math.round(mm / 25.4 * dpi);
    }

    document.getElementById("exportPNG").onclick = () => {
      const mm = parseFloat(document.getElementById("slideDiameter").value);
      const px = mmToPx(mm);
      const tmp = document.createElement("canvas");
      tmp.width = tmp.height = px;
      const tctx = tmp.getContext("2d");
      tctx.fillStyle = "black";
      tctx.beginPath();
      tctx.arc(px / 2, px / 2, px / 2, 0, Math.PI * 2);
      tctx.fill();
      tctx.drawImage(canvas, 0, 0, px, px);
      tmp.toBlob(blob => {
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "gobo.png";
        a.click();
      });
    };

    document.getElementById("exportPDF").onclick = () => {
      const mm = parseFloat(document.getElementById("slideDiameter").value);
      const px = mmToPx(mm);
      const tmp = document.createElement("canvas");
      tmp.width = tmp.height = px;
      const tctx = tmp.getContext("2d");
      tctx.fillStyle = "black";
      tctx.beginPath();
      tctx.arc(px / 2, px / 2, px / 2, 0, Math.PI * 2);
      tctx.fill();
      tctx.drawImage(canvas, 0, 0, px, px);
      const dataUrl = tmp.toDataURL("image/png");
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF({ orientation: "portrait", unit: "px", format: [px, px] });
      pdf.addImage(dataUrl, "PNG", 0, 0, px, px);
      pdf.save("gobo.pdf");
    };
  </script>
</body>
</html>
