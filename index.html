<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Профессиональный редактор-калькулятор для гобо v1.7 (стабильная)</title>
    <script src="https://d3js.org/d3-delaunay.v7.min.js"></script>
    <style>
        :root {
            --bg-color: #1e1e2f;
            --panel-bg: #27293d;
            --primary-color: #8a78ff;
            --text-color: #f0f0f0;
            --border-color: #44475a;
            --success-color: #50fa7b;
            --danger-color: #ff5555;
            --warning-color: #f1fa8c;
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            font-size: 14px;
        }

        .app-container {
            max-width: 1400px;
            margin: auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
        }

        header h1 {
            margin: 0;
            font-size: 24px;
        }

        header p {
            margin: 5px 0;
            color: #9a9a9a;
        }

        .control-panel {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .control-panel button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        
        .control-panel button.danger {
            background-color: var(--danger-color);
        }

        .control-panel button:hover {
            opacity: 0.9;
        }
        
        .control-panel button:disabled {
            background-color: #666;
            cursor: not-allowed;
        }

        .main-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .canvas-panel {
            background-color: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .canvas-panel h2 {
            margin-top: 0;
            text-align: center;
            font-size: 16px;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            padding-top: 75%; /* Aspect ratio 4:3 */
            background-color: #111;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .canvas-container canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
        
        .panel-footer {
            width: 100%;
            padding-top: 10px;
            text-align: center;
            color: #9a9a9a;
            height: 20px;
        }
        
        .panel-footer .status.ready { color: var(--success-color); font-weight: bold; }
        .panel-footer .status.mismatch { color: var(--warning-color); font-weight: bold; }
        
        .instructions { background-color: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 8px; padding: 20px; }
        .instructions h3 { margin-top: 0; }
        .instructions ol { padding-left: 20px; }

        .loupe { position: absolute; width: 100px; height: 100px; border-radius: 50%; border: 2px solid var(--primary-color); pointer-events: none; display: none; background-repeat: no-repeat; box-shadow: 0 5px 15px rgba(0,0,0,0.5); z-index: 100; }
        .loupe::before, .loupe::after { content: ''; position: absolute; background-color: var(--danger-color); z-index: 101; }
        .loupe::before { top: 50%; left: 0; width: 100%; height: 1px; margin-top: -0.5px; }
        .loupe::after { left: 50%; top: 0; height: 100%; width: 1px; margin-left: -0.5px; }

        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); display: none; justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background-color: var(--panel-bg); padding: 30px; border-radius: 8px; width: 300px; text-align: center; }
        .modal-content h2 { margin-top: 0; }
        .modal-content .form-group { margin-bottom: 20px; text-align: left; }
        .modal-content label { display: block; margin-bottom: 5px; }
        .modal-content input { width: 100%; padding: 8px; border-radius: 4px; border: 1px solid var(--border-color); background-color: var(--bg-color); color: var(--text-color); box-sizing: border-box; }
        .modal-buttons { display: flex; justify-content: space-between; }
        .file-input { display: none; }
    </style>
</head>
<body>
    <div class="app-container">
        <header>
            <h1>Профессиональный редактор-калькулятор для гобо</h1>
            <p>Версия 1.7 (стабильная)</p>
        </header>

        <div class="control-panel">
            <button id="load-template-btn">Загрузить фото-шаблон</button>
            <button id="load-source-btn">Загрузить изображение</button>
            <button id="clear-points-btn" class="danger">Очистить точки</button>
            <button id="export-btn" disabled>Экспорт</button>
        </div>
        
        <input type="file" id="template-file-input" class="file-input" accept="image/*">
        <input type="file" id="source-file-input" class="file-input" accept="image/*">

        <div class="main-content">
            <div class="canvas-panel">
                <h2>Исходное изображение</h2>
                 <div class="canvas-container" id="source-container">
                    <canvas id="source-canvas"></canvas>
                </div>
                <div class="panel-footer">Точек источника: <span id="source-points-count">0</span></div>
            </div>
            <div class="canvas-panel">
                <h2>Фото-шаблон</h2>
                <div class="canvas-container" id="template-container">
                    <canvas id="template-canvas"></canvas>
                </div>
                <div class="panel-footer">Точек цели: <span id="dest-points-count">0</span></div>
            </div>
            <div class="canvas-panel">
                <h2>Предпросмотр деформации</h2>
                <div class="canvas-container" id="preview-container">
                    <canvas id="preview-canvas"></canvas>
                </div>
                <div class="panel-footer">Статус: <span id="status-text">Ожидание изображений</span></div>
            </div>
        </div>

        <div class="instructions">
             <h3>Инструкция по использованию:</h3>
            <ol>
                <li>Загрузите фото-шаблон с размеченными точками.</li>
                <li>Загрузите исходное изображение для деформации.</li>
                <li>Кликните по ключевым точкам на исходном изображении (минимум 4 точки).</li>
                <li>Кликните по соответствующим точкам на фото-шаблоне в том же порядке.</li>
                <li>Используйте экранную лупу для точного позиционирования.</li>
                <li>Перетаскивайте точки для финальной подгонки.</li>
                <li>Наблюдайте real-time деформацию в окне предпросмотра.</li>
                <li>Нажмите "Экспорт" для создания готового файла гобо.</li>
            </ol>
        </div>
    </div>
    
    <div class="loupe" id="loupe"></div>
    
    <div class="modal-overlay" id="export-modal">
        <div class="modal-content">
            <h2>Параметры экспорта</h2>
            <div class="form-group">
                <label for="gobo-diameter">Диаметр гобо (мм)</label>
                <input type="number" id="gobo-diameter" value="37.5" step="0.1">
            </div>
            <div class="form-group">
                <label for="gobo-dpi">Разрешение (DPI)</label>
                <input type="number" id="gobo-dpi" value="2700" step="100">
            </div>
            <div class="modal-buttons">
                <button id="cancel-export-btn" class="danger">Отмена</button>
                <button id="confirm-export-btn">Сохранить файл</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Состояние приложения ---
            let sourceImage = null;
            let templateImage = null;
            let sourcePoints = [];
            let destinationPoints = [];
            let draggingPointInfo = null; // { point, index, array }

            // --- DOM элементы ---
            const sourceCanvas = document.getElementById('source-canvas');
            const templateCanvas = document.getElementById('template-canvas');
            const previewCanvas = document.getElementById('preview-canvas');
            const sourceCtx = sourceCanvas.getContext('2d');
            const templateCtx = templateCanvas.getContext('2d');
            const previewCtx = previewCanvas.getContext('2d');
            
            const loupe = document.getElementById('loupe');
            const exportBtn = document.getElementById('export-btn');

            // --- Инициализация ---
            const init = () => {
                setupCanvas(sourceCanvas, handleSourceCanvasEvent);
                setupCanvas(templateCanvas, handleTemplateCanvasEvent);

                document.getElementById('load-template-btn').addEventListener('click', () => document.getElementById('template-file-input').click());
                document.getElementById('load-source-btn').addEventListener('click', () => document.getElementById('source-file-input').click());
                document.getElementById('template-file-input').addEventListener('change', (e) => loadImage(e, true));
                document.getElementById('source-file-input').addEventListener('change', (e) => loadImage(e, false));
                document.getElementById('clear-points-btn').addEventListener('click', clearPoints);
                exportBtn.addEventListener('click', showExportModal);
                document.getElementById('cancel-export-btn').addEventListener('click', hideExportModal);
                document.getElementById('confirm-export-btn').addEventListener('click', handleExport);
            };

            const setupCanvas = (canvas, eventHandler) => {
                const resize = () => {
                    const container = canvas.parentElement;
                    canvas.width = container.clientWidth;
                    canvas.height = container.clientHeight;
                    renderAll();
                };
                window.addEventListener('resize', resize);
                resize();
                
                canvas.addEventListener('mousedown', (e) => eventHandler(e, 'down'));
                canvas.addEventListener('mousemove', (e) => eventHandler(e, 'move'));
                canvas.addEventListener('mouseup', () => eventHandler(null, 'up'));
                canvas.addEventListener('mouseleave', () => eventHandler(null, 'leave'));
                canvas.addEventListener('mouseenter', (e) => eventHandler(e, 'enter'));
            };

            const loadImage = (e, isTemplate) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        if (isTemplate) templateImage = img;
                        else sourceImage = img;
                        renderAll();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
                e.target.value = ''; // Reset input to allow reloading the same file
            };

            // --- Логика точек и интерактивности ---
            const handleSourceCanvasEvent = (e, type) => handleCanvasEvent(e, type, sourceCanvas, sourcePoints);
            const handleTemplateCanvasEvent = (e, type) => handleCanvasEvent(e, type, templateCanvas, destinationPoints);

            const handleCanvasEvent = (e, type, canvas, points) => {
                const getCoords = (event) => {
                    if (!event) return null;
                    const rect = canvas.getBoundingClientRect();
                    return { x: event.clientX - rect.left, y: event.clientY - rect.top };
                };

                const coords = getCoords(e);

                switch (type) {
                    case 'enter':
                        loupe.style.display = 'block';
                        break;
                    case 'leave':
                        loupe.style.display = 'none';
                        draggingPointInfo = null; // Stop dragging if mouse leaves
                        break;
                    case 'move':
                        if (coords) updateLoupe(e, canvas);
                        if (draggingPointInfo) {
                            draggingPointInfo.point[0] = coords.x;
                            draggingPointInfo.point[1] = coords.y;
                            renderAll();
                        }
                        break;
                    case 'down':
                        const pointIndex = getPointAt(coords, points);
                        if (pointIndex !== -1) {
                            draggingPointInfo = { point: points[pointIndex], index: pointIndex, array: points };
                        } else {
                            // Логика добавления новой точки
                            if (canvas === sourceCanvas) {
                                points.push([coords.x, coords.y]);
                            } else if (canvas === templateCanvas && points.length < sourcePoints.length) {
                                points.push([coords.x, coords.y]);
                            }
                            renderAll();
                        }
                        break;
                    case 'up':
                        draggingPointInfo = null;
                        break;
                }
            };
            
            const getPointAt = (coords, points) => {
                for (let i = 0; i < points.length; i++) {
                    const p = points[i];
                    const dist = Math.sqrt((p[0] - coords.x) ** 2 + (p[1] - coords.y) ** 2);
                    if (dist < 10) return i;
                }
                return -1;
            };

            const clearPoints = () => {
                sourcePoints.length = 0;
                destinationPoints.length = 0;
                renderAll();
            };
            
            // --- Логика отрисовки ---
            const renderAll = () => {
                drawCanvasWithAspectRatio(sourceCtx, sourceCanvas, sourceImage, sourcePoints);
                drawCanvasWithAspectRatio(templateCtx, templateCanvas, templateImage, destinationPoints);
                updatePreview();
                updateStatus();
            };

            const drawCanvasWithAspectRatio = (ctx, canvas, img, points) => {
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                if (img) {
                    const canvasRatio = canvas.width / canvas.height;
                    const imgRatio = img.naturalWidth / img.naturalHeight;
                    let drawWidth = canvas.width, drawHeight = canvas.height;
                    let offsetX = 0, offsetY = 0;

                    if (imgRatio > canvasRatio) {
                        drawHeight = canvas.width / imgRatio;
                        offsetY = (canvas.height - drawHeight) / 2;
                    } else {
                        drawWidth = canvas.height * imgRatio;
                        offsetX = (canvas.width - drawWidth) / 2;
                    }
                    ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
                }
                points.forEach((p, i) => drawPoint(ctx, p, i + 1));
            };

            const drawPoint = (ctx, p, number) => {
                ctx.beginPath();
                ctx.arc(p[0], p[1], 5, 0, 2 * Math.PI);
                ctx.fillStyle = 'rgba(138, 120, 255, 0.9)';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(number, p[0], p[1]);
            };
            
            const updateLoupe = (e, canvas) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const zoom = 4;
                loupe.style.left = `${e.pageX - 50}px`;
                loupe.style.top = `${e.pageY - 50}px`;
                loupe.style.backgroundImage = `url(${canvas.toDataURL()})`;
                loupe.style.backgroundSize = `${canvas.width * zoom}px ${canvas.height * zoom}px`;
                loupe.style.backgroundPosition = `-${x * zoom - 50}px -${y * zoom - 50}px`;
            };

            const updateStatus = () => {
                document.getElementById('source-points-count').textContent = sourcePoints.length;
                document.getElementById('dest-points-count').textContent = destinationPoints.length;
                const statusText = document.getElementById('status-text');
                const canWarp = sourcePoints.length >= 4 && sourcePoints.length === destinationPoints.length;
                
                if (canWarp) {
                    statusText.textContent = 'Готово к экспорту';
                    statusText.className = 'status ready';
                    exportBtn.disabled = false;
                } else if (sourcePoints.length !== destinationPoints.length) {
                    statusText.textContent = `Синхронизируйте точки (${sourcePoints.length}/${destinationPoints.length})`;
                    statusText.className = 'status mismatch';
                    exportBtn.disabled = true;
                } else {
                    statusText.textContent = 'Расставьте точки';
                    statusText.className = 'status';
                    exportBtn.disabled = true;
                }
            };
            
            // --- Логика деформации и предпросмотра ---
            const updatePreview = () => {
                previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                if (!templateImage) return;
                previewCtx.drawImage(templateImage, 0, 0, previewCanvas.width, previewCanvas.height);

                const canWarp = sourceImage && sourcePoints.length >= 4 && sourcePoints.length === destinationPoints.length;
                if (!canWarp) return;

                const warpCanvas = getWarpedCanvas(sourceCanvas, templateCanvas, sourcePoints, destinationPoints);
                if(warpCanvas) {
                    previewCtx.drawImage(warpCanvas, 0, 0, previewCanvas.width, previewCanvas.height);
                }
            };

            const getWarpedCanvas = (srcCanvas, destCanvasSizeRef, srcPoints, destPoints) => {
                // Создаем временный холст нужного размера для отрисовки деформации
                const warpedCanvas = document.createElement('canvas');
                warpedCanvas.width = destCanvasSizeRef.width;
                warpedCanvas.height = destCanvasSizeRef.height;
                const warpedCtx = warpedCanvas.getContext('2d');
                
                try {
                    const delaunay = d3.Delaunay.from(srcPoints);
                    const triangles = delaunay.triangles;

                    for (let i = 0; i < triangles.length; i += 3) {
                        const p_src = [ srcPoints[triangles[i]], srcPoints[triangles[i+1]], srcPoints[triangles[i+2]] ];
                        const p_dest = [ destPoints[triangles[i]], destPoints[triangles[i+1]], destPoints[triangles[i+2]] ];
                        
                        warpedCtx.save();
                        warpedCtx.beginPath();
                        warpedCtx.moveTo(p_dest[0][0], p_dest[0][1]);
                        warpedCtx.lineTo(p_dest[1][0], p_dest[1][1]);
                        warpedCtx.lineTo(p_dest[2][0], p_dest[2][1]);
                        warpedCtx.closePath();
                        warpedCtx.clip();

                        const transform = getAffineTransform(p_src, p_dest);
                        warpedCtx.setTransform(transform.a, transform.b, transform.c, transform.d, transform.e, transform.f);
                        warpedCtx.drawImage(srcCanvas, 0, 0);
                        warpedCtx.restore();
                    }
                    return warpedCanvas;
                } catch(e) {
                    console.error("Warping failed:", e);
                    return null;
                }
            };

            const getAffineTransform = (srcTri, dstTri) => {
                const [ [x0, y0], [x1, y1], [x2, y2] ] = srcTri;
                const [ [u0, v0], [u1, v1], [u2, v2] ] = dstTri;
                
                // Решение системы линейных уравнений для матрицы аффинного преобразования
                // M * t = b, где t = [a, c, e, b, d, f]
                const M = [
                    [x0, y0, 1, 0, 0, 0], [0, 0, 0, x0, y0, 1],
                    [x1, y1, 1, 0, 0, 0], [0, 0, 0, x1, y1, 1],
                    [x2, y2, 1, 0, 0, 0], [0, 0, 0, x2, y2, 1]
                ];
                const b = [u0, v0, u1, v1, u2, v2];
                const t = solve(M, b);
                
                if (!t) return { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0 };
                return { a: t[0], c: t[1], e: t[2], b: t[3], d: t[4], f: t[5] };
            };

            // --- Экспорт ---
            const showExportModal = () => document.getElementById('export-modal').style.display = 'flex';
            const hideExportModal = () => document.getElementById('export-modal').style.display = 'none';

            const handleExport = () => {
                const diameter = parseFloat(document.getElementById('gobo-diameter').value);
                const dpi = parseInt(document.getElementById('gobo-dpi').value);

                if (isNaN(diameter) || isNaN(dpi) || diameter <= 0 || dpi <= 0) {
                    alert('Пожалуйста, введите корректные значения диаметра и DPI.');
                    return;
                }
                
                const exportSizePx = Math.round((diameter / 25.4) * dpi);
                const exportCanvas = document.createElement('canvas');
                exportCanvas.width = exportSizePx;
                exportCanvas.height = exportSizePx;
                const exportCtx = exportCanvas.getContext('2d');
                
                // 1. Рисуем черную круглую маску
                exportCtx.fillStyle = 'black';
                exportCtx.beginPath();
                exportCtx.arc(exportSizePx / 2, exportSizePx / 2, exportSizePx / 2, 0, 2 * Math.PI);
                exportCtx.fill();

                // 2. Рассчитываем и рисуем деформированное изображение
                const warpedCanvas = getWarpedCanvas(sourceCanvas, {width: exportSizePx, height: exportSizePx}, sourcePoints, destinationPoints.map(p => [
                    (p[0] / templateCanvas.width) * exportSizePx,
                    (p[1] / templateCanvas.height) * exportSizePx
                ]));
                
                if (warpedCanvas) {
                    exportCtx.drawImage(warpedCanvas, 0, 0);
                }

                // 3. Скачиваем файл
                const link = document.createElement('a');
                link.download = `gobo_export_${diameter}mm_${dpi}dpi.png`;
                link.href = exportCanvas.toDataURL('image/png');
                link.click();
                hideExportModal();
            };
            
            // Надежная функция для решения СЛАУ методом Гаусса
            function solve(A, b) {
                const n = A.length;
                for (let i = 0; i < n; i++) {
                    let maxEl = Math.abs(A[i][i]);
                    let maxRow = i;
                    for (let k = i + 1; k < n; k++) {
                        if (Math.abs(A[k][i]) > maxEl) {
                            maxEl = Math.abs(A[k][i]);
                            maxRow = k;
                        }
                    }
                    [A[i], A[maxRow]] = [A[maxRow], A[i]];
                    [b[i], b[maxRow]] = [b[maxRow], b[i]];
                    for (let k = i + 1; k < n; k++) {
                        const c = -A[k][i] / A[i][i];
                        for (let j = i; j < n; j++) {
                            if (i === j) A[k][j] = 0;
                            else A[k][j] += c * A[i][j];
                        }
                        b[k] += c * b[i];
                    }
                }
                const x = new Array(n);
                for (let i = n - 1; i > -1; i--) {
                    x[i] = b[i] / A[i][i];
                    for (let k = i - 1; k > -1; k--) {
                        b[k] -= A[k][i] * x[i];
                    }
                }
                return x;
            }

            // --- Запуск приложения ---
            init();
        });
    </script>
</body>
</html>
